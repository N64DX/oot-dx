/*In an attempt to make this more readable, I have divided it into chunks. The individual
chunks are properly branched and mostly have issues with regalloc, especially with the
float literals. However, the logic block in the second section is not properly branched.
See the .txt file for an explanation of its correct branching structure. In particular, 
it requires the compiler to put switch 2's cases far away from its jump table. I'm not sure
exactly how that works. It may require nesting switch statements, which just sounds awful.*/

void func_808CB718(BossFd* this, GlobalContext* globalCtx) {

    u8 sp1CF;
    f32 dy;
    f32 sp1B4;
    f32 sp1B0;
    Vec3f sp188;
    Vec3f sp17C;
    Vec3f sp170;
    f32 sp168;
    Vec3f sp164;
    Vec3f sp158;
    s16 sp150;
    Vec3f sp144;
    Vec3f sp138;
    Vec3f sp12C;
    Vec3f sp120;
    Vec3f sp114;
    Vec3f sp108;
    Vec3f spE0[3];
    Vec3f spBC[3];
    f32 dx2;
    f32 dz2;
    f32 dPerp;
    Camera* camera;
    Vec3f* temp_v0;
    Vec3f* temp_v0_10;
    Vec3f* temp_v0_12;
    Vec3f* holeXYZ;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f10;
    f32 temp_f12;
    f32 temp_f2_2;
    f32 temp_f2_3;
    f32 temp_f2_4;
    f32 temp_f4_3;
    s16 temp_v0_13;
    s16 temp_v0_14;
    s16 temp_v0_3;
    s16 temp_v0_6;
    s16 temp_v0_7;
    s16 temp_v0_8;
    s16 temp_v1_3;
    s16 temp_v1_4;
    s16 temp_v1_5;
    s16 temp_v1_6;
    s16 temp_v1_7;
    s16 temp_v1_8;
    s32 temp_s0_2;
    s16 temp_s0_4;
    s16 temp_s0_5;
    s32 temp_s0_7;
    s32 temp_s3_3;
    s32 temp_s5_2;
    s32 temp_s5_3;
    s32 temp_t1_2;
    u32 temp_t0;
    u32 temp_t1;
    u32 temp_t3;
    u8 temp_v0_11;
    Player* player = PLAYER;
    s16 phi_s0;
    s16 phi_s5;
    s16 phi_v1_5;
    s16 phi_v1_6;
    s16 phi_s5_2;
    s32 phi_v1_7;
    s16 phi_v1_8;
    s16 phi_v1_9;
    s32 phi_s3;
    s32 phi_s0_2;
    f32 phi_f20;
    f32 dx;
    f32 dz;
    s16 actionState;

    sp1CF = 0;
    SkelAnime_FrameUpdateMatrix(&this->skelAnime1);
    SkelAnime_FrameUpdateMatrix(&this->skelAnime2);
    SkelAnime_FrameUpdateMatrix(&this->skelAnime3);
    dx = this->targetPosition.x - this->actor.posRot.pos.x;
    dy = this->targetPosition.y - this->actor.posRot.pos.y;
    dz = this->targetPosition.z - this->actor.posRot.pos.z;
    dx += Math_Sins(this->unk_224 * (2096.0f + this->unk_2B4)) * this->unk_2B0;
    dy += Math_Sins(this->unk_224 * (1096.0f + this->unk_2B4)) * this->unk_2B0;
    dz += Math_Sins(this->unk_224 * (1796.0f + this->unk_2B4)) * this->unk_2B0;
    sp1B4 = (s16)(Math_atan2f(dx, dz) * 10430.378f);
    dx2 = dx * dx;
    dz2 = dz * dz;
    dPerp = sqrtf(dx2 + dz2);
    sp1B0 = (s16)(Math_atan2f(dy, dPerp) * 10430.378f);
    osSyncPrintf("MODE %d\n", this->actionState);
    Math_SmoothScaleMaxF(&this->unk_280, 0.1f, 1.0f, 0.02f);

    /****************************************************************************************
     *                                   Boss Intro Cutscene                                *
     ****************************************************************************************/

    if (this->introState2 != 0) {
        camera = Gameplay_GetCamera(globalCtx, 0);
        #include "Switch1.code"
        func_808CB198(this, globalCtx);
    } else {
        this->unk_2A4 = 5.0f;
    }

    /***********************************************************************************************
     *                              Attacks and Death Cutscene                                     *
     ***********************************************************************************************/
    actionState = this->actionState;
    if (actionState < 0x34) {
        if (actionState < 0x33) {
            if (actionState < 4) {
                #include "Switch2.code"
            } else if (actionState == 0x32) {
                #include "Block5.code"
            } 
        } else if (actionState == 0x33) {
            #include "Block6.code"
        }
    } else {
        if(actionState < 0x65) {
            if(actionState == 0x64){
               #include "Block7.code" 
            }    
        } else {
            #include "Switch1.code"
        }
    }
        
   
    /*************************************************************************************************
     *                                 Body segments and Mane                                        *
     *************************************************************************************************/

    if (this->unk_244 == 0) {
        Math_SmoothScaleMaxS(&this->actor.posRot.rot.y, sp1B4, 0xA, this->unk_2A8);

        if (((this->actionState == 0x64) || (this->actionState == 0x65)) && (this->actor.posRot.pos.y < 110.0f) &&
            (sp1B0 < 0.0f)) {
            sp1B0 = 0.0f;
            Math_SmoothScaleMaxF(&this->actor.posRot.pos.y, 110.0f, 1.0f, 5.0f);
        }

        Math_SmoothScaleMaxS(&this->actor.posRot.rot.x, sp1B0, 0xA, this->unk_2A8);
        Math_SmoothScaleMaxF(&this->unk_2A8, this->unk_2AC, 1.0f, 20000.0f);
        Math_SmoothScaleMaxF(&this->actor.speedXZ, this->unk_2A4, 1.0f, 0.1f);
        if (this->actionState < 0xCC) {
            func_8002D908(&this->actor);
        }
        func_8002D7EC(&this->actor);
        this->leadBodySegment++;
        if (this->leadBodySegment >= 0x64) {
            this->leadBodySegment = 0;
        }
        temp_s0_4 = this->leadBodySegment;
        this->bodySegmentsPos[temp_s0_4].x = this->actor.posRot.pos.x;
        this->bodySegmentsPos[temp_s0_4].y = this->actor.posRot.pos.y;
        this->bodySegmentsPos[temp_s0_4].z = this->actor.posRot.pos.z;
        this->bodySegmentsRot[temp_s0_4].x = (this->actor.posRot.rot.x / 32768.0f) * 3.1415927f;
        this->bodySegmentsRot[temp_s0_4].y = (this->actor.posRot.rot.y / 32768.0f) * 3.1415927f;
        this->bodySegmentsRot[temp_s0_4].z = (this->actor.posRot.rot.z / 32768.0f) * 3.1415927f;
        this->leadManeSegment++;
        if (this->leadManeSegment >= 0x1E) {
            this->leadManeSegment = 0;
        }
        temp_s0_5 = (this->leadManeSegment);
        this->centerManeScale[temp_s0_5] = (Math_Sins(((this->unk_224 * 5596.0f))) * 0.3f) + 1.0f;
        this->rightManeScale[temp_s0_5] = (Math_Sins(((this->unk_224 * 5496.0f))) * 0.3f) + 1.0f;
        this->leftManeScale[temp_s0_5] = (Math_Coss(((this->unk_224 * 5696.0f))) * 0.3f) + 1.0f;
        this->centerManePos[temp_s0_5] = this->centerManeHead;
        this->fireManeRot[temp_s0_5].x = (this->actor.posRot.rot.x / 32768.0f) * 3.1415927f;
        this->fireManeRot[temp_s0_5].y = (this->actor.posRot.rot.y / 32768.0f) * 3.1415927f;
        this->fireManeRot[temp_s0_5].z = (this->actor.posRot.rot.z / 32768.0f) * 3.1415927f;
        this->rightManePos[temp_s0_5] = this->rightManeHead;
        this->leftManePos[temp_s0_5] = this->leftManeHead;
        temp_v0_14 = this->actor.posRot.rot.x;
        if ((temp_v0_14 < 0x3000) && (temp_v0_14 >= -0x2FFF)) {
            Math_SmoothScaleMaxF(&this->flattenMane, 1.0f, 1.0f, 0.05f);
        } else {
            Math_SmoothScaleMaxF(&this->flattenMane, 0.5f, 1.0f, 0.05f);
        }

        if (this->actionState < 0xCC) {
            if ((this->actor.pos4.y < 90.0f) && (90.0f <= this->actor.posRot.pos.y)) {
                this->animationTimers[4] = 0x50;
                func_80033E1C(globalCtx, 1, 0x50, 0x5000);
                this->roarTimer = 0x28;
                this->maneEmbersTimer = 0x1E;
                this->holeSplashTimer = 0xA;
            }
            if ((90.0f < this->actor.pos4.y) && (this->actor.posRot.pos.y <= 90.0f)) {
                this->animationTimers[4] = 0x50;
                func_80033E1C(globalCtx, 1, 0x50, 0x5000);
                this->maneEmbersTimer = 0x1E;
                this->holeSplashTimer = 0xA;
            }
        }
        if (sp1CF == 0) {
            temp_f2_3 = Math_Sins(((this->unk_224 * 1500.0f))) * 3000.0f;
            spE0[0].y = temp_f2_3;
            spE0[0].x = temp_f2_3;
            spE0[1].x = Math_Sins(((this->unk_224 * 2000.0f))) * 4000.0f;
            spE0[1].y = Math_Sins(((this->unk_224 * 2200.0f))) * 4000.0f;
            spE0[2].x = Math_Sins(((this->unk_224 * 1700.0f))) * 2000.0f;
            spE0[2].y = Math_Sins(((this->unk_224 * 1900.0f))) * 2000.0f;
            spBC[0].x = spBC[0].y = Math_Sins(((this->unk_224 * 1500.0f))) * -3000.0f;
            spBC[1].x = Math_Sins(((this->unk_224 * 2200.0f))) * -4000.0f;
            spBC[1].y = Math_Sins(((this->unk_224 * 2000.0f))) * -4000.0f;
            spBC[2].x = Math_Sins(((this->unk_224 * 1900.0f))) * -2000.0f;
            spBC[2].y = Math_Sins(((this->unk_224 * 1700.0f))) * -2000.0f;
            phi_s3 = 0;
            for (phi_s3 = 0; phi_s3 < 3; phi_s3++) {
                Math_SmoothScaleMaxF(&this->unk_C3C[phi_s3].x, spE0[phi_s3].x, 1.0f, 1000.0f);
                Math_SmoothScaleMaxF(&this->unk_C3C[phi_s3].y, spE0[phi_s3].y, 1.0f, 1000.0f);
                Math_SmoothScaleMaxF(&this->unk_C6C[phi_s3].x, spBC[phi_s3].x, 1.0f, 1000.0f);
                Math_SmoothScaleMaxF(&this->unk_C6C[phi_s3].y, spBC[phi_s3].y, 1.0f, 1000.0f);
            }
        } else { //Loops are wrong. Use pointer iterators.
            for (phi_s0_2 = 0; phi_s0_2 < 3; phi_s0_2++) {
                Math_SmoothDownscaleMaxF(&this->unk_C3C[phi_s0_2].y, 0.1f, 100.0f);
                Math_SmoothDownscaleMaxF(&this->unk_C6C[phi_s0_2].y, 0.1f, 100.0f);
                phi_f20 = (phi_s0_2 == 0) ? -3000.0f : 0.0f;
                Math_SmoothScaleMaxF(&this->unk_C3C[phi_s0_2].x, phi_f20, 0.1f, 100.0f);
                Math_SmoothScaleMaxF(&this->unk_C6C[phi_s0_2].x, -phi_f20, 0.1f, 100.0f);
            }
        }
    }
}
