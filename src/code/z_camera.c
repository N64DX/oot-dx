#include <ultra64.h>
#include <global.h>
#include <vt.h>

s16 Camera_ChangeSetting(Camera*, s16, s16);
void Camera_ChangeModeDefaultFlags(Camera* camera, s16 mode);
s32 func_8005A7A8(Camera* arg0, s32 arg1);
Vec3f *func_80044E68(Vec3f* arg0, s16 arg1, s16 arg2, s16 arg3);
void Camera_UpdateInterface(s16);
s32 func_800458D4(Camera* camera, VecSph* arg1, f32 arg2, f32* arg3, s16 arg4);
s16 func_80046CB4(Camera* camera, s16 arg1, s16 arg2, f32 arg3, f32 arg4);

//#define NON_MATCHING

/* Camera Setting Macros */
#define CAM_MODE_INIT(funcIdx, modeValues) { funcIdx, ARRAY_COUNT(modeValues), modeValues, }
#define CAM_MODE_NONE { CAM_FUNC_NONE, 0, NULL, }
#define NEXTSETTING ((values++)->val)

#define CAM_IFACE_INIT(interfaceFlags) { interfaceFlags, 9 }

#define RELOAD_PARAMS (camera->animState == 0 || camera->animState == 0xA || camera->animState == 0x14 || R_RELOAD_CAM_PARAMS)

#define PCT(x) (0.01f * x)
#define NEXTPCT PCT(NEXTSETTING)


typedef struct {
    s16 val;
    s16 param;
} CameraModeValue;

typedef struct {
    s16 funcIdx;
    s16 valueCnt;
    CameraModeValue* values;
} CameraMode;

typedef struct {
    union {
        u32 unk_00;
        struct {
            u32 unk_bit0 : 1;
            u32 unk_bit1 : 1;
            u32 validModes : 30;
        };
    };
    CameraMode* cameraModes;
} CameraSetting;

typedef enum {
    CAM_STATUS_UNK0,
    CAM_STATUS_UNK1,
    CAM_STATUS_UNK2,
    CAM_STATUS_UNK3,
    CAM_STATUS_UNK4,
    CAM_STATUS_UNK5,
    CAM_STATUS_UNK6,
    CAM_STATUS_ACTIVE,
    CAM_STATUS_UNK100 = 0x100
} CameraStatusType;

typedef enum {
    CAM_SET_NONE,
    CAM_SET_NORMAL0,
    CAM_SET_NORMAL1,
    CAM_SET_DUNGEON0,
    CAM_SET_DUNGEON1,
    CAM_SET_NORMAL3,
    CAM_SET_HORSE0,
    CAM_SET_BOSS_GOMA,
    CAM_SET_BOSS_DODO,
    CAM_SET_BOSS_BARI,
    CAM_SET_BOSS_FGANON,
    CAM_SET_BOSS_BAL,
    CAM_SET_BOSS_SHADES,
    CAM_SET_BOSS_MOFA,
    CAM_SET_TWIN0,
    CAM_SET_TWIN1,
    CAM_SET_BOSS_GANON1,
    CAM_SET_BOSS_GANON2,
    CAM_SET_TOWER0,
    CAM_SET_TOWER1,
    CAM_SET_FIXED0,
    CAM_SET_FIXED1,
    CAM_SET_CIRCLE0,
    CAM_SET_CIRCLE2,
    CAM_SET_CIRCLE3,
    CAM_SET_PREREND0,
    CAM_SET_PREREND1,
    CAM_SET_PREREND3,
    CAM_SET_DOOR0,
    CAM_SET_DOORC,
    CAM_SET_RAIL3,
    CAM_SET_START0,
    CAM_SET_START1,
    CAM_SET_FREE0,
    CAM_SET_FREE2,
    CAM_SET_CIRCLE4,
    CAM_SET_CIRCLE5,
    CAM_SET_DEMO0,
    CAM_SET_DEMO1,
    CAM_SET_MORI1,
    CAM_SET_ITEM0,
    CAM_SET_ITEM1,
    CAM_SET_DEMO3,
    CAM_SET_DEMO4,
    CAM_SET_UFOBEAN,
    CAM_SET_LIFTBEAN,
    CAM_SET_SCENE0,
    CAM_SET_SCENE1,
    CAM_SET_HIDAN1,
    CAM_SET_HIDAN2,
    CAM_SET_MORI2,
    CAM_SET_MORI3,
    CAM_SET_TAKO,
    CAM_SET_SPOT05A,
    CAM_SET_SPOT05B,
    CAM_SET_HIDAN3,
    CAM_SET_ITEM2,
    CAM_SET_CIRCLE6,
    CAM_SET_NORMAL2,
    CAM_SET_FISHING,
    CAM_SET_DEMOC,
    CAM_SET_UO_FIBER,
    CAM_SET_DUNGEON2,
    CAM_SET_TEPPEN,
    CAM_SET_CIRCLE7,
    CAM_SET_NORMAL4,
    CAM_SET_MAX
} CameraSettingType;

typedef enum {
    CAM_MODE_NORMAL,
    CAM_MODE_PARALLEL,
    CAM_MODE_KEEPON,
    CAM_MODE_TALK,
    CAM_MODE_BATTLE,
    CAM_MODE_CLIMB,
    CAM_MODE_SUBJECT,
    CAM_MODE_BOWARROW,
    CAM_MODE_BOWARROWZ,
    CAM_MODE_FOOKSHOT,
    CAM_MODE_BOOMERANG,
    CAM_MODE_PACHINCO,
    CAM_MODE_CLIMBZ,
    CAM_MODE_JUMP,
    CAM_MODE_HANG,
    CAM_MODE_HANGZ,
    CAM_MODE_FREEFALL,
    CAM_MODE_CHARGE,
    CAM_MODE_STILL,
    CAM_MODE_PUSHPULL,
    CAM_MODE_BOOKEEPON
} CameraModeType;

typedef enum {
    CAM_FUNC_NONE,
    CAM_FUNC_NORM0,
    CAM_FUNC_NORM1,
    CAM_FUNC_NORM2,
    CAM_FUNC_NORM3,
    CAM_FUNC_NORM4,
    CAM_FUNC_PARA0,
    CAM_FUNC_PARA1,
    CAM_FUNC_PARA2,
    CAM_FUNC_PARA3,
    CAM_FUNC_PARA4,
    CAM_FUNC_KEEP0,
    CAM_FUNC_KEEP1,
    CAM_FUNC_KEEP2,
    CAM_FUNC_KEEP3,
    CAM_FUNC_KEEP4,
    CAM_FUNC_SUBJ0,
    CAM_FUNC_SUBJ1,
    CAM_FUNC_SUBJ2,
    CAM_FUNC_SUBJ3,
    CAM_FUNC_SUBJ4,
    CAM_FUNC_JUMP0,
    CAM_FUNC_JUMP1,
    CAM_FUNC_JUMP2,
    CAM_FUNC_JUMP3,
    CAM_FUNC_JUMP4,
    CAM_FUNC_BATT0,
    CAM_FUNC_BATT1,
    CAM_FUNC_BATT2,
    CAM_FUNC_BATT3,
    CAM_FUNC_BATT4,
    CAM_FUNC_FIXD0,
    CAM_FUNC_FIXD1,
    CAM_FUNC_FIXD2,
    CAM_FUNC_FIXD3,
    CAM_FUNC_FIXD4,
    CAM_FUNC_DATA0,
    CAM_FUNC_DATA1,
    CAM_FUNC_DATA2,
    CAM_FUNC_DATA3,
    CAM_FUNC_DATA4,
    CAM_FUNC_UNIQ0,
    CAM_FUNC_UNIQ1,
    CAM_FUNC_UNIQ2,
    CAM_FUNC_UNIQ3,
    CAM_FUNC_UNIQ4,
    CAM_FUNC_UNIQ5,
    CAM_FUNC_UNIQ6,
    CAM_FUNC_UNIQ7,
    CAM_FUNC_UNIQ8,
    CAM_FUNC_UNIQ9,
    CAM_FUNC_DEMO0,
    CAM_FUNC_DEMO1,
    CAM_FUNC_DEMO2,
    CAM_FUNC_DEMO3,
    CAM_FUNC_DEMO4,
    CAM_FUNC_DEMO5,
    CAM_FUNC_DEMO6,
    CAM_FUNC_DEMO7,
    CAM_FUNC_DEMO8,
    CAM_FUNC_DEMO9,
    CAM_FUNC_SPEC0,
    CAM_FUNC_SPEC1,
    CAM_FUNC_SPEC2,
    CAM_FUNC_SPEC3,
    CAM_FUNC_SPEC4,
    CAM_FUNC_SPEC5,
    CAM_FUNC_SPEC6,
    CAM_FUNC_SPEC7,
    CAM_FUNC_SPEC8,
    CAM_FUNC_SPEC9,
    CAM_FUNC_MAX
};

/*==================================================================*/
// Data
s16 sOREGInit[] = {
    0,   1,   5,  5,  5,   14500, 20,  16, 150, 25,   150, 6,  10, 10, 0,  0,   1,     100,
    250, 120, 80, 30, 120, 4,     1,   50, 20,  1800, 50,  50, 50, 20, 20, -10, -5460, -9100,
    -6,  8,   15, 75, 60,  12,    110, 40, 50,  250,  -10, 30, 30, 70, 20, 20,  20,
};

s16 sOREGInitCnt = 53;

s16 sPREGInit[] = {
    -20, 200, 300, 10, 12, 10, 35, 60, 60, 3, 0, -40, 20, 25, 45, -5, 15, 15, 20, 0, 0, 0, 6, 60, 30, 0, 5,
};

s16 sPREGInitCnt = 27;

char sCameraSettingNames[][12] = {
    "NONE      ",  "NORMAL0    ", "NORMAL1    ", "DUNGEON0   ", "DUNGEON1   ", "NORMAL3    ", "HORSE0     ",
    "BOSS_GOMA  ", "BOSS_DODO  ", "BOSS_BARI  ", "BOSS_FGANON", "BOSS_BAL   ", "BOSS_SHADES", "BOSS_MOFA  ",
    "BOSS_TWIN0 ", "BOSS_TWIN1 ", "BOSS_GANON1", "BOSS_GANON2", "TOWER0     ", "TOWER1     ", "FIXED0     ",
    "FIXED1     ", "CIRCLE0    ", "CIRCLE2    ", "CIRCLE3    ", "PREREND0   ", "PREREND1   ", "PREREND3   ",
    "DOOR0      ", "DOORC      ", "RAIL3      ", "START0     ", "START1     ", "FREE0      ", "FREE2      ",
    "CIRCLE4    ", "CIRCLE5    ", "DEMO0      ", "DEMO1      ", "MORI1      ", "ITEM0      ", "ITEM1      ",
    "DEMO3      ", "DEMO4      ", "UFOBEAN    ", "LIFTBEAN   ", "SCENE0     ", "SCENE1     ", "HIDAN1     ",
    "HIDAN2     ", "MORI2      ", "MORI3      ", "TAKO       ", "SPOT05A    ", "SPOT05B    ", "HIDAN3     ",
    "ITEM2      ", "CIRCLE6    ", "NORMAL2    ", "FISHING    ", "DEMOC      ", "UO_FIBER   ", "DUNGEON2   ",
    "TEPPEN     ", "CIRCLE7    ", "NORMAL4    ",
};

char sCameraModeNames[][12] = {
    "NORMAL     ", "PARALLEL   ", "KEEPON     ", "TALK       ", "BATTLE     ", "CLIMB      ", "SUBJECT    ",
    "BOWARROW   ", "BOWARROWZ  ", "FOOKSHOT   ", "BOOMERANG  ", "PACHINCO   ", "CLIMBZ     ", "JUMP       ",
    "HANG       ", "HANGZ      ", "FREEFALL   ", "CHARGE     ", "STILL      ", "PUSHPULL   ", "BOOKEEPON  ",
};

CameraModeValue D_8011A3A0[] = {
    { -20, 0 }, { 200, 1 }, { 300, 2 }, { 10, 3 }, { 12, 4 }, { 10, 5 }, { 35, 6 }, { 60, 7 }, { 60, 8 }, { 3, 9 },
};

#define CAM_PARA1_INIT(val0, distLERPTarget, phiLERPTarget, thetaLERPTarget, val4, val5, \
                       fovLERPTarget, val7, interfaceFlags, val9, val10) \
                       { \
                        { val0, 0 }, { distLERPTarget, 1 }, { phiLERPTarget, 3 }, \
                        { thetaLERPTarget, 10 }, { val4, 4 }, { val5, 5 }, \
                        { fovLERPTarget, 7 }, { val7, 8 }, { interfaceFlags, 9 },  \
                        { val9, 11 }, { val10, 12 } \
                      }

CameraModeValue D_8011A3C8[] = CAM_PARA1_INIT(-20, 250, 0x0000, 0x0000, 5, 5, 45, 50, 0x200A, -40, 20);

CameraModeValue D_8011A3F4[] = {
    { -20, 0 }, { 120, 1 }, { 140, 2 }, { 25, 13 },  { 45, 14 },  { -5, 15 }, { 15, 16 },
    { 15, 17 }, { 45, 7 },  { 50, 8 },  { 8193, 9 }, { -50, 11 }, { 30, 12 },
};

CameraModeValue D_8011A428[] = {
    { -30, 0 }, { 70, 1 },  { 200, 2 }, { 40, 13 }, { 10, 14 }, { 0, 15 },
    { 5, 16 },  { 70, 17 }, { 45, 7 },  { 50, 8 },  { 10, 4 },  { 13568, 9 },
};

CameraModeValue D_8011A458[] = {
    { -20, 0 }, { 180, 1 }, { 10, 13 }, { 80, 14 },  { 0, 15 },   { 10, 16 },
    { 25, 17 }, { 50, 7 },  { 80, 8 },  { 8194, 9 }, { -40, 11 }, { 25, 12 },
};

CameraModeValue D_8011A488[] = {
    { -20, 0 }, { 200, 1 }, { 300, 2 }, { 20, 18 }, { 5, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011A4AC[] = {
    { 0, 0 }, { 5, 1 }, { 50, 2 }, { 10, 4 }, { 0, 19 }, { 0, 20 }, { 0, 21 }, { 45, 7 }, { 0, 9 },
};

CameraModeValue D_8011A4D0[] = {
    { -7, 0 }, { 14, 1 }, { 50, 2 }, { 10, 4 }, { 0, 19 }, { -30, 20 }, { -5, 21 }, { 45, 7 }, { 8192, 9 },
};

CameraModeValue D_8011A4F4[] = {
    { 20, 0 }, { 70, 1 }, { 70, 2 }, { 10, 4 }, { -120, 19 }, { 20, 20 }, { 0, 21 }, { 45, 7 }, { 8192, 9 },
};

CameraModeValue D_8011A518[] = {
    { -20, 0 }, { 80, 1 }, { 250, 2 }, { 45, 3 }, { 60, 7 }, { 40, 8 }, { 6, 22 }, { 8192, 9 },
};

CameraModeValue D_8011A538[] = {
    { 5, 0 }, { 50, 1 }, { 50, 2 }, { 10, 4 }, { 0, 19 }, { 0, 20 }, { 0, 21 }, { 45, 7 }, { 8192, 9 },
};

CameraModeValue D_8011A55C[] = {
    { -7, 0 }, { 14, 1 }, { 50, 2 }, { 10, 4 }, { -9, 19 }, { -63, 20 }, { -30, 21 }, { 45, 7 }, { 8192, 9 },
};

CameraModeValue D_8011A580[] = {
    { -20, 0 }, { 200, 1 }, { 300, 2 }, { 20, 18 }, { 999, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 8198, 9 },
};

CameraModeValue D_8011A5A4[] = {
    { -20, 0 }, { 200, 1 }, { 300, 2 }, { 12, 4 }, { 35, 6 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011A5C4[] = {
    { -80, 0 }, { 200, 1 }, { 300, 2 }, { 40, 3 }, { 60, 7 }, { 10, 8 }, { 0, 9 },
};

CameraModeValue D_8011A5E0[] = {
    { -120, 0 }, { 300, 1 }, { 300, 2 }, { 70, 3 }, { 45, 7 }, { 10, 8 }, { 8192, 9 },
};

CameraModeValue D_8011A5FC[] = {
    { -20, 0 }, { 200, 1 }, { 300, 2 }, { 15, 4 }, { 80, 6 }, { 60, 7 }, { 20, 8 }, { 0, 9 },
};

CameraModeValue D_8011A61C[] = {
    { -20, 0 }, { 300, 1 }, { 50, 3 }, { 2, 4 }, { 80, 7 }, { 20, 8 }, { -4096, 9 },
};

CameraModeValue D_8011A638[] = {
    { -20, 0 }, { 200, 1 }, { 300, 2 }, { 10, 3 }, { 100, 4 }, { 10, 5 }, { 100, 6 }, { 60, 7 }, { 5, 8 }, { -4093, 9 },
};

CameraModeValue D_8011A660[] = {
    { 0, 0 },  { 250, 1 }, { 25, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 70, 7 }, { 30, 8 },  { 8298, 9 }, { -20, 11 }, { 30, 12 },
};

CameraModeValue D_8011A68C[] = {
    { -5, 0 },  { 120, 1 }, { 140, 2 }, { 5, 13 },   { 85, 14 },  { 10, 15 }, { 5, 16 },
    { 25, 17 }, { 45, 7 },  { 50, 8 },  { 8193, 9 }, { -15, 11 }, { 30, 12 },
};

CameraModeValue D_8011A6C0[] = {
    { 0, 0 }, { 200, 1 }, { 400, 2 }, { 10, 3 }, { 12, 4 }, { 20, 5 }, { 40, 6 }, { 60, 7 }, { 60, 8 }, { 3, 9 },
};

CameraModeValue D_8011A6E8[] = {
    { 0, 0 },  { 250, 1 }, { 0, 3 },    { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 45, 7 }, { 50, 8 },  { 8194, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011A714[] = {
    { -20, 0 }, { 120, 1 }, { 140, 2 }, { 25, 13 },  { 45, 14 },  { -5, 15 }, { 15, 16 },
    { 15, 17 }, { 45, 7 },  { 50, 8 },  { 8193, 9 }, { -50, 11 }, { 20, 12 },
};

CameraModeValue D_8011A748[] = {
    { -20, 0 }, { 250, 1 }, { 10, 13 }, { 80, 14 },  { 0, 15 },   { 10, 16 },
    { 25, 17 }, { 50, 7 },  { 65, 8 },  { 8194, 9 }, { -40, 11 }, { 25, 12 },
};

CameraModeValue D_8011A778[] = {
    { -20, 0 }, { 80, 1 }, { 250, 2 }, { 6, 22 }, { 45, 3 }, { 60, 7 }, { 40, 8 }, { 8192, 9 },
};

CameraModeValue D_8011A798[] = {
    { 0, 0 }, { 250, 1 }, { 400, 2 }, { 15, 4 }, { 50, 6 }, { 60, 7 }, { 30, 8 }, { 0, 9 },
};

CameraModeValue D_8011A7B8[] = {
    { 0, 0 }, { 200, 1 }, { 400, 2 }, { 30, 4 }, { 80, 6 }, { 60, 7 }, { 20, 8 }, { 0, 9 },
};

CameraModeValue D_8011A7D8[] = {
    { -20, 0 }, { 200, 1 }, { 400, 2 }, { 20, 18 }, { 5, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011A7FC[] = {
    { -20, 0 }, { 250, 1 }, { 400, 2 }, { 20, 18 }, { 999, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 8198, 9 },
};

CameraModeValue D_8011A820[] = {
    { 0, 0 }, { 300, 1 }, { 50, 3 }, { 2, 4 }, { 80, 7 }, { 20, 8 }, { -4096, 9 },
};

CameraModeValue D_8011A83C[] = {
    { -80, 0 }, { 200, 1 }, { 400, 2 }, { 40, 3 }, { 60, 7 }, { 10, 8 }, { 0, 9 },
};

CameraModeValue D_8011A858[] = {
    { -120, 0 }, { 400, 1 }, { 400, 2 }, { 70, 3 }, { 45, 7 }, { 10, 8 }, { 8192, 9 },
};

CameraModeValue D_8011A874[] = {
    { 0, 0 }, { 200, 1 }, { 400, 2 }, { 10, 3 }, { 100, 4 }, { 20, 5 }, { 100, 6 }, { 60, 7 }, { 5, 8 }, { -4093, 9 },
};

CameraModeValue D_8011A89C[] = {
    { -10, 0 }, { 150, 1 }, { 250, 2 }, { 5, 3 }, { 10, 4 }, { 5, 5 }, { 30, 6 }, { 60, 7 }, { 60, 8 }, { 3, 9 },
};

CameraModeValue D_8011A8C4[] = {
    { -20, 0 }, { 150, 1 }, { 0, 3 },    { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 45, 7 },  { 50, 8 },  { 8202, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011A8F0[] = {
    { -20, 0 }, { 120, 1 }, { 140, 2 }, { 25, 13 },  { 45, 14 },  { -5, 15 }, { 15, 16 },
    { 15, 17 }, { 45, 7 },  { 50, 8 },  { 8193, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011A924[] = {
    { -20, 0 }, { 180, 1 }, { 10, 13 }, { 80, 14 },  { 0, 15 },   { 10, 16 },
    { 25, 17 }, { 45, 7 },  { 80, 8 },  { 8194, 9 }, { -40, 11 }, { 25, 12 },
};

CameraModeValue D_8011A954[] = {
    { -10, 0 }, { 150, 1 }, { 250, 2 }, { 10, 4 }, { 50, 6 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011A974[] = {
    { -10, 0 }, { 150, 1 }, { 250, 2 }, { 10, 4 }, { 80, 6 }, { 60, 7 }, { 20, 8 }, { 0, 9 },
};

CameraModeValue D_8011A994[] = {
    { -40, 0 }, { 150, 1 }, { 250, 2 }, { 20, 18 }, { 5, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011A9B8[] = {
    { -40, 0 }, { 250, 1 }, { 250, 2 }, { 20, 18 }, { 999, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 8198, 9 },
};

CameraModeValue D_8011A9DC[] = {
    { -10, 0 }, { 300, 1 }, { 50, 3 }, { 2, 4 }, { 80, 7 }, { 20, 8 }, { -4096, 9 },
};

CameraModeValue D_8011A9F8[] = {
    { -80, 0 }, { 150, 1 }, { 250, 2 }, { 40, 3 }, { 60, 7 }, { 10, 8 }, { 0, 9 },
};

CameraModeValue D_8011AA14[] = {
    { -120, 0 }, { 250, 1 }, { 250, 2 }, { 70, 3 }, { 45, 7 }, { 10, 8 }, { 8192, 9 },
};

CameraModeValue D_8011AA30[] = {
    { -10, 0 }, { 150, 1 }, { 250, 2 }, { 5, 3 }, { 100, 4 }, { 5, 5 }, { 100, 6 }, { 60, 7 }, { 5, 8 }, { -4093, 9 },
};

CameraModeValue D_8011AA58[] = {
    { -40, 0 }, { 150, 1 }, { 150, 2 }, { 0, 3 }, { 10, 4 }, { 5, 5 }, { 30, 6 }, { 60, 7 }, { 60, 8 }, { 3, 9 },
};

CameraModeValue D_8011AA80[] = {
    { -20, 0 }, { 70, 1 },  { 200, 2 }, { 40, 13 }, { 10, 14 }, { 0, 15 },
    { 5, 16 },  { 70, 17 }, { 45, 7 },  { 50, 8 },  { 10, 4 },  { 13568, 9 },
};

CameraModeValue D_8011AAB0[] = {
    { -40, 0 }, { 150, 1 }, { 150, 2 }, { 10, 4 }, { 50, 6 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011AAD0[] = {
    { -40, 0 }, { 150, 1 }, { 180, 2 }, { 12, 4 }, { 80, 6 }, { 60, 7 }, { 20, 8 }, { 0, 9 },
};

CameraModeValue D_8011AAF0[] = {
    { -40, 0 }, { 150, 1 }, { 150, 2 }, { 20, 18 }, { 5, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011AB14[] = {
    { -40, 0 }, { 150, 1 }, { 150, 2 }, { 20, 18 }, { 999, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 8198, 9 },
};

CameraModeValue D_8011AB38[] = {
    { -40, 0 }, { 200, 1 }, { 50, 3 }, { 2, 4 }, { 80, 7 }, { 20, 8 }, { -4096, 9 },
};

CameraModeValue D_8011AB54[] = {
    { -80, 0 }, { 150, 1 }, { 150, 2 }, { 40, 3 }, { 60, 7 }, { 10, 8 }, { 0, 9 },
};

CameraModeValue D_8011AB70[] = {
    { -120, 0 }, { 150, 1 }, { 150, 2 }, { 70, 3 }, { 45, 7 }, { 10, 8 }, { 8192, 9 },
};

CameraModeValue D_8011AB8C[] = {
    { -40, 0 }, { 150, 1 }, { 150, 2 }, { 0, 3 }, { 100, 4 }, { 5, 5 }, { 100, 6 }, { 60, 7 }, { 5, 8 }, { -4093, 9 },
};

CameraModeValue D_8011ABB4[] = {
    { -40, 0 }, { 180, 1 }, { 25, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 60, 7 },  { 50, 8 },  { 8298, 9 }, { -20, 11 }, { 30, 12 },
};

CameraModeValue D_8011ABE0[] = {
    { -20, 0 }, { 280, 1 }, { 300, 2 }, { 20, 3 }, { 15, 4 }, { 5, 5 }, { 40, 6 }, { 60, 7 }, { 100, 8 }, { 4, 9 },
};

CameraModeValue D_8011AC08[] = {
    { -50, 0 }, { 250, 1 }, { 70, 3 },   { 0, 10 },   { 15, 4 },  { 5, 5 },
    { 60, 7 },  { 100, 8 }, { 8202, 9 }, { -50, 11 }, { 20, 12 },
};

CameraModeValue D_8011AC34[] = {
    { -30, 0 }, { 70, 1 },  { 200, 2 }, { 40, 13 }, { 10, 14 }, { 10, 15 },
    { 20, 16 }, { 70, 17 }, { 45, 7 },  { 10, 8 },  { 10, 4 },  { 13568, 9 },
};

CameraModeValue D_8011AC64[] = {
    { -40, 0 }, { 150, 1 }, { 250, 2 }, { -5, 3 }, { 18, 4 }, { 5, 5 }, { 60, 6 }, { 60, 7 }, { 40, 8 }, { 5, 9 },
};

CameraModeValue D_8011AC8C[] = {
    { -50, 0 }, { 220, 1 }, { 250, 2 }, { 10, 3 }, { 16, 4 }, { 20, 5 }, { 60, 7 }, { 100, 8 }, { 1536, 9 },
};

CameraModeValue D_8011ACB0[] = {
    { -40, 0 }, { 180, 1 }, { 220, 2 }, { -2, 3 }, { 12, 4 }, { 100, 5 }, { 45, 7 }, { 100, 8 }, { 9728, 9 },
};

CameraModeValue D_8011ACD4[] = {
    { -7, 0 }, { 14, 1 }, { 100, 2 }, { 10, 4 }, { 0, 19 }, { -30, 20 }, { -5, 21 }, { 40, 7 }, { 9728, 9 },
};

CameraModeValue D_8011ACF8[] = {
    { -60, 0 }, { 180, 1 }, { 220, 2 }, { 25, 13 },  { 45, 14 },  { -5, 15 }, { 15, 16 },
    { 15, 17 }, { 45, 7 },  { 50, 8 },  { 9729, 9 }, { -60, 11 }, { 20, 12 },
};

CameraModeValue D_8011AD2C[] = {
    { -60, 0 }, { 140, 1 }, { 200, 2 }, { 40, 13 }, { 10, 14 }, { 0, 15 },
    { 5, 16 },  { 70, 17 }, { 45, 7 },  { 50, 8 },  { 10, 4 },  { 13568, 9 },
};

CameraModeValue D_8011AD5C[] = {
    { -20, 0 }, { 150, 1 }, { 250, 2 }, { 0, 3 }, { 15, 4 }, { 5, 5 }, { 40, 6 }, { 60, 7 }, { 60, 8 }, { 1, 9 },
};

CameraModeValue D_8011AD84[] = {
    { -30, 0 }, { 150, 1 }, { 10, 13 }, { 40, 14 },  { -10, 15 }, { 0, 16 },
    { 25, 17 }, { 60, 7 },  { 40, 8 },  { 8194, 9 }, { -50, 11 }, { 20, 12 },
};

CameraModeValue D_8011ADB4[] = {
    { 0, 0 }, { 150, 1 }, { 300, 2 }, { 0, 3 }, { 12, 4 }, { 5, 5 }, { 70, 6 }, { 70, 7 }, { 40, 8 }, { 3, 9 },
};

CameraModeValue D_8011ADDC[] = {
    { -20, 0 }, { 160, 1 }, { 10, 13 }, { 60, 14 },  { -5, 15 },  { 0, 16 },
    { 25, 17 }, { 70, 7 },  { 50, 8 },  { 8194, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011AE0C[] = {
    { -20, 0 }, { 150, 1 }, { 300, 2 }, { -5, 3 }, { 15, 4 }, { 5, 5 }, { 40, 6 }, { 70, 7 }, { 70, 8 }, { 3, 9 },
};

CameraModeValue D_8011AE34[] = {
    { -30, 0 }, { 125, 1 }, { 10, 13 }, { 10, 14 },  { 0, 15 },   { 0, 16 },
    { 50, 17 }, { 60, 7 },  { 50, 8 },  { 8194, 9 }, { -50, 11 }, { 20, 12 },
};

CameraModeValue D_8011AE64[] = {
    { 10, 0 }, { 150, 1 }, { 250, 2 }, { 0, 3 }, { 15, 4 }, { 15, 5 }, { 40, 6 }, { 60, 7 }, { 100, 8 }, { 3, 9 },
};

CameraModeValue D_8011AE8C[] = {
    { -20, 0 }, { 200, 1 }, { 45, 13 }, { 40, 14 },  { 5, 15 },   { -5, 16 },
    { 35, 17 }, { 60, 7 },  { 100, 8 }, { 8194, 9 }, { -40, 11 }, { 60, 12 },
};

CameraModeValue D_8011AEBC[] = {
    { -20, 0 }, { 500, 1 }, { 500, 2 }, { 10, 3 }, { 16, 4 }, { 10, 5 }, { 40, 6 }, { 60, 7 }, { 80, 8 }, { 3, 9 },
};

CameraModeValue D_8011AEE4[] = {
    { -20, 0 }, { 200, 1 }, { 20, 13 }, { 60, 14 },  { 0, 15 },   { 10, 16 },
    { 15, 17 }, { 45, 7 },  { 50, 8 },  { 8194, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011AF14[] = {
    { -20, 0 }, { 500, 1 }, { 500, 2 }, { 10, 3 }, { 20, 4 }, { 10, 5 }, { 40, 6 }, { 60, 7 }, { 80, 8 }, { 131, 9 },
};

CameraModeValue D_8011AF3C[] = {
    { -20, 0 }, { 200, 1 }, { 20, 13 }, { 60, 14 },  { 0, 15 },   { 10, 16 },
    { 15, 17 }, { 45, 7 },  { 50, 8 },  { 8322, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011AF6C[] = {
    { -20, 0 }, { 500, 1 }, { 500, 2 }, { 10, 3 }, { 20, 4 }, { 10, 5 }, { 80, 6 }, { 60, 7 }, { 80, 8 }, { 131, 9 },
};

CameraModeValue D_8011AF94[] = {
    { -20, 0 }, { 100, 1 }, { 150, 2 }, { -10, 3 }, { 15, 4 }, { 10, 5 }, { 40, 6 }, { 80, 7 }, { 60, 8 }, { 3, 9 },
};

CameraModeValue D_8011AFBC[] = {
    { -20, 0 }, { 200, 1 }, { 10, 13 }, { 80, 14 },  { -10, 15 }, { 10, 16 },
    { 25, 17 }, { 70, 7 },  { 40, 8 },  { 8194, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011AFEC[] = {
    { -20, 0 }, { 150, 1 }, { 300, 2 }, { 0, 3 }, { 20, 4 }, { 10, 5 }, { 40, 6 }, { 60, 7 }, { 80, 8 }, { 3, 9 },
};

CameraModeValue D_8011B014[] = {
    { 0, 0 },   { 400, 1 }, { 0, 13 }, { 60, 14 },  { -10, 15 }, { 5, 16 },
    { 25, 17 }, { 45, 7 },  { 40, 8 }, { 8194, 9 }, { -20, 11 }, { 20, 12 },
};

CameraModeValue D_8011B044[] = {
    { -10, 0 }, { 150, 1 }, { 200, 2 }, { -10, 3 }, { 12, 4 }, { 10, 5 }, { 40, 6 }, { 60, 7 }, { 50, 8 }, { 3, 9 },
};

CameraModeValue D_8011B06C[] = {
    { 40, 0 }, { 330, 1 }, { 330, 2 }, { -5, 3 }, { 15, 4 }, { 15, 5 }, { 40, 6 }, { 60, 7 }, { 100, 8 }, { 0, 9 },
};

CameraModeValue D_8011B094[] = {
    { -40, 0 }, { 250, 1 }, { 0, 3 }, { 2, 4 }, { 80, 7 }, { 20, 8 }, { -4096, 9 },
};

CameraModeValue D_8011B0B0[] = {
    { -20, 0 }, { 500, 1 }, { 500, 2 }, { 10, 3 }, { 20, 4 }, { 10, 5 }, { 40, 6 }, { 60, 7 }, { 80, 8 }, { 3, 9 },
};

CameraModeValue D_8011B0D8[] = {
    { -20, 0 }, { 180, 1 }, { 20, 13 }, { 60, 14 },  { 0, 15 },   { 10, 16 },
    { 25, 17 }, { 45, 7 },  { 50, 8 },  { 8194, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011B108[] = {
    { 0, 0 }, { 120, 1 }, { 280, 2 }, { 60, 23 }, { 8, 4 }, { 40, 6 }, { 60, 7 }, { 50, 8 }, { 0, 9 },
};

CameraModeValue D_8011B12C[] = {
    { 0, 0 }, { 120, 1 }, { 280, 2 }, { 60, 23 }, { 8, 4 }, { 40, 6 }, { 60, 7 }, { 50, 8 }, { 128, 9 },
};

CameraModeValue D_8011B150[] = {
    { 0, 0 }, { 270, 1 }, { 300, 2 }, { 120, 23 }, { 8, 4 }, { 60, 6 }, { 60, 7 }, { 100, 8 }, { 0, 9 },
};

CameraModeValue D_8011B174[] = {
    { 0, 0 }, { 270, 1 }, { 300, 2 }, { 120, 23 }, { 6, 4 }, { 60, 6 }, { 60, 7 }, { 100, 8 }, { 0, 9 },
};

CameraModeValue D_8011B198[] = {
    { -40, 0 },
    { 100, 4 },
    { 60, 7 },
    { 0, 9 },
};

CameraModeValue D_8011B1A8[] = {
    { -40, 0 },
    { 100, 4 },
    { 60, 7 },
    { 8192, 9 },
};

CameraModeValue D_8011B1B8[] = {
    { -40, 0 },
    { 100, 4 },
    { 60, 7 },
    { 13568, 9 },
};

CameraModeValue D_8011B1C8[] = {
    { -40, 0 },
    { 25, 4 },
    { 60, 7 },
    { 0, 9 },
};

CameraModeValue D_8011B1D8[] = {
    { -40, 0 }, { 50, 4 }, { 80, 5 }, { 60, 7 }, { 1, 9 },
};

CameraModeValue sData4Normal[] = {
    { -40, 0 },
    { 60, 7 },
    { 16128, 9 },
};

CameraModeValue D_8011B1F8[] = {
    { -40, 0 }, { 50, 4 }, { 80, 5 }, { 60, 7 }, { 4, 9 },
};

CameraModeValue D_8011B20C[] = {
    CAM_IFACE_INIT(0),
};

CameraModeValue D_8011B210[] = {
    CAM_IFACE_INIT(0x2000),
};

CameraModeValue D_8011B214[] = {
    { 60, 7 },
    { 0, 9 },
};

CameraModeValue D_8011B21C[] = {
    { 60, 7 },
    { 8192, 9 },
};

CameraModeValue D_8011B224[] = {
    { 30, 24 },
    { 0, 25 },
    { 4, 4 },
    { 13568, 9 },
};

CameraModeValue D_8011B234[] = {
    { -40, 0 },
    { 60, 7 },
    { 12800, 9 },
};

CameraModeValue D_8011B240[] = {
    { -5, 0 },
    { 60, 7 },
    { 12802, 9 },
};

CameraModeValue D_8011B24C[] = {
    { -5, 0 },
    { 60, 7 },
    { 12810, 9 },
};

CameraModeValue D_8011B258[] = {
    { 0, 0 }, { 2, 1 }, { 30, 2 }, { 10, 4 }, { 45, 7 }, { 12800, 9 },
};

CameraModeValue D_8011B270[] = {
    { 1, 9 },
};

CameraModeValue D_8011B274[] = {
    { -256, 9 },
};

CameraModeValue D_8011B278[] = {
    { -255, 9 },
};

CameraModeValue D_8011B27C[] = {
    { -40, 0 }, { 100, 4 }, { 80, 5 }, { 60, 7 }, { 0, 9 },
};

CameraModeValue D_8011B290[] = {
    { -40, 0 },
    { 60, 1 },
    { 60, 7 },
    { 2, 9 },
};

CameraModeValue D_8011B2A0[] = {
    { -30, 0 },
    { 45, 1 },
    { 100, 7 },
    { 8193, 9 },
};

CameraModeValue D_8011B2B0[] = {
    { 12800, 9 },
};

CameraModeValue D_8011B2B4[] = {
    { -50, 0 }, { 450, 1 }, { 40, 3 }, { 180, 10 }, { 5, 4 },   { 5, 5 },
    { 70, 7 },  { 30, 8 },  { 12, 9 }, { -50, 11 }, { 20, 12 },
};

CameraModeValue D_8011B2E0[] = {
    { 13569, 9 },
};

CameraModeValue D_8011B2E4[] = {
    { 60, 7 },
    { 30, 8 },
    { 12800, 9 },
};

CameraModeValue D_8011B2F0[] = {
    { 12818, 9 },
};

CameraModeValue D_8011B2F4[] = {
    { -50, 0 }, { 300, 1 }, { 300, 2 }, { 50, 3 }, { 20, 4 }, { 10, 5 }, { 50, 6 }, { 70, 7 }, { 40, 8 }, { 2, 9 },
};

CameraModeValue D_8011B31C[] = {
    { -50, 0 }, { 300, 1 }, { 10, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 45, 7 },  { 50, 8 },  { 8202, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011B348[] = {
    { -50, 0 }, { 300, 1 }, { 300, 2 }, { 12, 4 }, { 35, 6 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011B368[] = {
    { -80, 0 }, { 300, 1 }, { 300, 2 }, { 60, 3 }, { 70, 7 }, { 30, 8 }, { 0, 9 },
};

CameraModeValue D_8011B384[] = {
    { -120, 0 }, { 300, 1 }, { 300, 2 }, { 70, 3 }, { 50, 7 }, { 30, 8 }, { 8192, 9 },
};

CameraModeValue D_8011B3A0[] = {
    { -20, 0 }, { 300, 1 }, { 350, 2 }, { 50, 3 }, { 100, 4 },
    { 10, 5 },  { 100, 6 }, { 70, 7 },  { 30, 8 }, { -4094, 9 },
};

CameraModeValue D_8011B3C8[] = {
    { -50, 0 }, { 200, 1 }, { 200, 2 }, { 20, 3 }, { 16, 4 }, { 10, 5 }, { 50, 6 }, { 60, 7 }, { 50, 8 }, { 2, 9 },
};

CameraModeValue D_8011B3F0[] = {
    { -50, 0 }, { 200, 1 }, { 40, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 45, 7 },  { 50, 8 },  { 8202, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011B41C[] = {
    { -50, 0 }, { 150, 1 }, { 250, 2 }, { 12, 4 }, { 35, 6 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011B43C[] = {
    { -80, 0 }, { 200, 1 }, { 200, 2 }, { 40, 3 }, { 60, 7 }, { 30, 8 }, { 0, 9 },
};

CameraModeValue D_8011B458[] = {
    { -120, 0 }, { 200, 1 }, { 200, 2 }, { 60, 3 }, { 50, 7 }, { 30, 8 }, { 8192, 9 },
};

CameraModeValue D_8011B474[] = {
    { -20, 0 }, { 200, 1 }, { 250, 2 }, { 20, 3 }, { 100, 4 },
    { 10, 5 },  { 100, 6 }, { 60, 7 },  { 30, 8 }, { -4094, 9 },
};

CameraModeValue D_8011B49C[] = {
    { -30, 0 },
    { 60, 7 },
    { 266, 9 },
};

CameraModeValue D_8011B4A8[] = {
    { -20, 0 },
    { 150, 1 },
    { 60, 7 },
    { 528, 9 },
};

CameraModeValue D_8011B4B8[] = {
    { 0, 0 }, { 400, 1 }, { 500, 2 }, { 35, 3 }, { 14, 4 }, { 5, 5 }, { 20, 6 }, { 60, 7 }, { 40, 8 }, { 18, 9 },
};

CameraModeValue D_8011B4E0[] = {
    { -20, 0 }, { 250, 1 }, { 5, 13 }, { 10, 14 },  { 30, 15 },  { 20, 16 },
    { 25, 17 }, { 45, 7 },  { 60, 8 }, { 8194, 9 }, { -40, 11 }, { 25, 12 },
};

CameraModeValue D_8011B510[] = {
    { 0, 0 }, { 300, 1 }, { 500, 2 }, { 60, 3 }, { 8, 4 }, { 5, 5 }, { 60, 6 }, { 60, 7 }, { 30, 8 }, { 18, 9 },
};

CameraModeValue D_8011B538[] = {
    { -20, 0 }, { 500, 1 }, { 500, 2 }, { 80, 3 }, { 20, 4 }, { 10, 5 }, { 70, 6 }, { 70, 7 }, { 80, 8 }, { 18, 9 },
};

CameraModeValue D_8011B560[] = {
    { -20, 0 }, { 500, 1 }, { 80, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 70, 7 },  { 80, 8 },  { 8218, 9 }, { -40, 11 }, { 40, 12 },
};

CameraModeValue D_8011B58C[] = {
    { -20, 0 }, { 500, 1 }, { 80, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 60, 7 },  { 80, 8 },  { 8218, 9 }, { -40, 11 }, { 40, 12 },
};

CameraModeValue D_8011B5B8[] = {
    { -20, 0 }, { 500, 1 }, { 500, 2 }, { 80, 3 }, { 20, 4 }, { 10, 5 }, { 80, 6 }, { 60, 7 }, { 20, 8 }, { 18, 9 },
};

CameraModeValue D_8011B5E0[] = {
    { -20, 0 }, { 750, 1 }, { 750, 2 }, { 80, 3 }, { 20, 4 }, { 10, 5 }, { 70, 6 }, { 70, 7 }, { 80, 8 }, { 18, 9 },
};

CameraModeValue D_8011B608[] = {
    { -20, 0 }, { 750, 1 }, { 80, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 70, 7 },  { 80, 8 },  { 8218, 9 }, { -40, 11 }, { 40, 12 },
};

CameraModeValue D_8011B634[] = {
    { -20, 0 }, { 750, 1 }, { 80, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 70, 7 },  { 80, 8 },  { 8202, 9 }, { -40, 11 }, { 40, 12 },
};

CameraModeValue D_8011B660[] = {
    { -20, 0 }, { 750, 1 }, { 750, 2 }, { 80, 3 }, { 20, 4 }, { 10, 5 }, { 80, 6 }, { 70, 7 }, { 20, 8 }, { 18, 9 },
};

CameraModeValue D_8011B688[] = {
    { -20, 0 }, { 500, 1 }, { 500, 2 }, { 80, 3 }, { 20, 4 }, { 10, 5 }, { 70, 6 }, { 70, 7 }, { 80, 8 }, { 2, 9 },
};

CameraModeValue D_8011B6B0[] = {
    { -20, 0 }, { 500, 1 }, { 80, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 70, 7 },  { 80, 8 },  { 8202, 9 }, { -40, 11 }, { 40, 12 },
};

CameraModeValue D_8011B6DC[] = {
    { -20, 0 }, { 500, 1 }, { 80, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 60, 7 },  { 80, 8 },  { 8202, 9 }, { -40, 11 }, { 40, 12 },
};

CameraModeValue D_8011B708[] = {
    { -20, 0 }, { 500, 1 }, { 500, 2 }, { 80, 3 }, { 20, 4 }, { 10, 5 }, { 80, 6 }, { 60, 7 }, { 20, 8 }, { 2, 9 },
};

CameraModeValue D_8011B730[] = {
    { -30, 0 }, { 120, 1 }, { -10, 3 }, { 170, 10 }, { 0, 21 }, { 60, 7 }, { 9474, 9 }, { 25, 4 }, { 6, 22 },
};

CameraModeValue D_8011B754[] = {
    { 20, 4 },
    { 12800, 9 },
};

CameraModeValue D_8011B75C[] = {
    { -20, 0 }, { 200, 1 }, { 300, 2 }, { 10, 3 }, { 12, 4 }, { 10, 5 }, { 35, 6 }, { 60, 7 }, { 60, 8 }, { 2, 9 },
};

CameraModeValue D_8011B784[] = {
    { 0, 0 }, { 200, 1 }, { 300, 2 }, { 20, 3 }, { 12, 4 }, { 10, 5 }, { 35, 6 }, { 55, 7 }, { 60, 8 }, { 3842, 9 },
};

CameraModeValue D_8011B7AC[] = {
    { -20, 0 }, { 250, 1 }, { 0, 3 },     { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 45, 7 },  { 50, 8 },  { 12042, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011B7D8[] = {
    { -20, 0 }, { 250, 1 }, { 0, 13 }, { 80, 14 },   { 0, 15 },   { 0, 16 },
    { 25, 17 }, { 55, 7 },  { 80, 8 }, { 12034, 9 }, { -40, 11 }, { 25, 12 },
};

CameraModeValue D_8011B808[] = {
    { -30, 0 }, { 70, 1 },  { 200, 2 }, { 40, 13 }, { 10, 14 }, { 0, 15 },
    { 5, 16 },  { 70, 17 }, { 45, 7 },  { 50, 8 },  { 10, 4 },  { 16160, 9 },
};

CameraModeValue D_8011B838[] = {
    { 0, 0 }, { 5, 1 }, { 50, 2 }, { 10, 4 }, { 0, 19 }, { 0, 20 }, { 0, 21 }, { 45, 7 }, { 3840, 9 },
};

CameraModeValue D_8011B85C[] = {
    { -20, 0 }, { 200, 1 }, { 300, 2 }, { 12, 4 }, { 35, 6 }, { 60, 7 }, { 40, 8 }, { 3840, 9 },
};

CameraModeValue D_8011B87C[] = {
    { -20, 0 }, { 200, 1 }, { 300, 2 }, { 15, 4 }, { 80, 6 }, { 60, 7 }, { 20, 8 }, { 3840, 9 },
};

CameraModeValue D_8011B89C[] = {
    { -80, 0 }, { 200, 1 }, { 300, 2 }, { 40, 3 }, { 60, 7 }, { 10, 8 }, { 3840, 9 },
};

CameraModeValue D_8011B8B8[] = {
    { -120, 0 }, { 300, 1 }, { 300, 2 }, { 70, 3 }, { 45, 7 }, { 10, 8 }, { 12032, 9 },
};

CameraModeValue D_8011B8D4[] = {
    { 16128, 9 },
};

CameraModeValue D_8011B8D8[] = {
    { 30, 0 }, { 200, 1 }, { 300, 2 }, { -20, 3 }, { 15, 4 }, { 5, 26 }, { 50, 6 }, { 70, 7 }, { 70, 8 }, { 3, 9 },
};

CameraModeValue D_8011B900[] = {
    { -30, 0 }, { 160, 1 }, { 10, 13 }, { 10, 14 },  { 0, 15 },   { 0, 16 },
    { 70, 17 }, { 60, 7 },  { 40, 8 },  { 8194, 9 }, { -50, 11 }, { 20, 12 },
};

CameraModeValue D_8011B930[] = {
    { -20, 0 }, { 350, 1 }, { 350, 2 }, { 20, 3 }, { 15, 4 }, { 5, 5 }, { 30, 6 }, { 60, 7 }, { 60, 8 }, { 3, 9 },
};

CameraModeValue D_8011B958[] = {
    { -20, 0 }, { 200, 1 }, { 0, 3 },    { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 45, 7 },  { 50, 8 },  { 8202, 9 }, { -40, 11 }, { 20, 12 },
};

CameraModeValue D_8011B984[] = {
    { -20, 0 }, { 180, 1 }, { 10, 13 }, { 80, 14 },  { -10, 15 }, { 10, 16 },
    { 25, 17 }, { 45, 7 },  { 80, 8 },  { 8194, 9 }, { -40, 11 }, { 25, 12 },
};

CameraModeValue D_8011B9B4[] = {
    { -20, 0 }, { 350, 1 }, { 350, 2 }, { 10, 4 }, { 50, 6 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011B9D4[] = {
    { -20, 0 }, { 350, 1 }, { 350, 2 }, { 15, 4 }, { 80, 6 }, { 60, 7 }, { 20, 8 }, { 0, 9 },
};

CameraModeValue D_8011B9F4[] = {
    { -40, 0 }, { 350, 1 }, { 350, 2 }, { 20, 18 }, { 5, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 0, 9 },
};

CameraModeValue D_8011BA18[] = {
    { -40, 0 }, { 350, 1 }, { 350, 2 }, { 20, 18 }, { 999, 4 }, { 5, 5 }, { 60, 7 }, { 40, 8 }, { 8198, 9 },
};

CameraModeValue D_8011BA3C[] = {
    { -50, 0 }, { 350, 1 }, { 350, 2 }, { 40, 3 }, { 60, 7 }, { 10, 8 }, { 0, 9 },
};

CameraModeValue D_8011BA58[] = {
    { -100, 0 }, { 350, 1 }, { 350, 2 }, { 70, 3 }, { 45, 7 }, { 10, 8 }, { 8192, 9 },
};

CameraModeValue D_8011BA74[] = {
    { -10, 0 }, { 350, 1 }, { 350, 2 }, { 20, 3 }, { 100, 4 }, { 5, 5 }, { 100, 6 }, { 60, 7 }, { 5, 8 }, { -4093, 9 },
};

CameraModeValue D_8011BA9C[] = {
    { 0, 0 },  { 280, 1 }, { 25, 3 },   { 0, 10 },   { 5, 4 },   { 5, 5 },
    { 70, 7 }, { 30, 8 },  { 8298, 9 }, { -20, 11 }, { 30, 12 },
};

CameraModeValue D_8011BAC8[] = {
    { -10, 0 }, { 280, 1 }, { 320, 2 }, { -8, 3 }, { 20, 4 }, { 10, 5 }, { 80, 6 }, { 60, 7 }, { 80, 8 }, { 2, 9 },
};

CameraModeValue D_8011BAF0[] = {
    { -20, 0 }, { 180, 1 }, { 200, 2 }, { 35, 13 },  { 45, 14 },  { 0, 15 },  { -5, 16 },
    { 20, 17 }, { 50, 7 },  { 50, 8 },  { 8193, 9 }, { -50, 11 }, { 30, 12 },
};

CameraModeValue D_8011BB24[] = {
    { -80, 0 }, { 200, 1 }, { 250, 2 }, { 30, 13 }, { 10, 14 }, { -8, 15 },
    { -8, 16 }, { 30, 17 }, { 50, 7 },  { 50, 8 },  { 10, 4 },  { 13600, 9 },
};

CameraModeValue D_8011BB54[] = {
    { -30, 0 }, { 70, 1 },  { 200, 2 }, { 40, 13 }, { 10, 14 }, { 0, 15 },
    { 5, 16 },  { 70, 17 }, { 45, 7 },  { 50, 8 },  { 10, 4 },  { 13728, 9 },
};

CameraMode D_8011BB84[] = {
    { 2, 10, D_8011A3A0 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011A458 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5FC },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011BC2C[] = {
    { 2, 10, D_8011A6C0 },  { 7, 11, D_8011A6E8 }, { 12, 13, D_8011A714 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011A748 }, { 23, 9, D_8011A7D8 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A778 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A7FC },  { 22, 8, D_8011A798 }, { 42, 7, D_8011A83C },  { 42, 7, D_8011A858 },
    { 22, 8, D_8011A7B8 },  { 30, 7, D_8011A820 }, { 2, 10, D_8011A874 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011BCD4[] = {
    { 2, 10, D_8011A89C },  { 7, 11, D_8011A8C4 }, { 12, 13, D_8011A8F0 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011A924 }, { 23, 9, D_8011A994 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A778 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A9B8 },  { 22, 8, D_8011A954 }, { 42, 7, D_8011A9F8 },  { 42, 7, D_8011AA14 },
    { 22, 8, D_8011A974 },  { 30, 7, D_8011A9DC }, { 2, 10, D_8011AA30 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011BD7C[] = {
    { 2, 10, D_8011AA58 },  { 7, 11, D_8011A8C4 }, { 12, 13, D_8011A714 }, { 14, 12, D_8011AA80 },
    { 27, 12, D_8011A924 }, { 23, 9, D_8011AAF0 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A778 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011AB14 },  { 22, 8, D_8011AAB0 }, { 42, 7, D_8011AB54 },  { 42, 7, D_8011AB70 },
    { 22, 8, D_8011AAD0 },  { 30, 7, D_8011AB38 }, { 2, 10, D_8011AB8C },  { 7, 11, D_8011ABB4 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011BE24[] = {
    { 24, 10, D_8011ABE0 }, { 7, 11, D_8011AC08 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011AC34 },
    { 27, 12, D_8011A458 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 24, 10, D_8011AC64 }, { 0, 0, NULL },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
};

CameraMode D_8011BEC4[] = {
    { 4, 9, D_8011AC8C }, { 4, 9, D_8011ACB0 }, { 12, 13, D_8011ACF8 }, { 14, 12, D_8011AD2C }, { 0, 0, NULL },
    { 0, 0, NULL },       { 0, 0, NULL },       { 19, 9, D_8011ACD4 },  { 19, 9, D_8011A4F4 },
};

CameraMode D_8011BF0C[] = {
    { 2, 10, D_8011AD5C },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011AD84 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A9DC }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011BFB4[] = {
    { 2, 10, D_8011ADB4 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011ADDC }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C05C[] = {
    { 2, 10, D_8011AE0C },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011AE34 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C104[] = {
    { 2, 10, D_8011AE64 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011AE8C }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C1AC[] = {
    { 2, 10, D_8011AEBC },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011AEE4 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C254[] = {
    { 2, 10, D_8011AF14 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011AF3C }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 2, 10, D_8011AF6C }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 2, 10, D_8011AF6C },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C2FC[] = {
    { 2, 10, D_8011AF94 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011AFBC }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C3A4[] = {
    { 2, 10, D_8011AFEC },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011B014 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C44C[] = {
    { 2, 10, D_8011B044 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011B014 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C4F4[] = {
    { 2, 10, D_8011B06C },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011AE8C }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011B094 }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C59C[] = {
    { 2, 10, D_8011B0B0 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011B0D8 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C644[] = {
    { 3, 9, D_8011B108 },   { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011A458 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 3, 9, D_8011B12C },  { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C6EC[] = {
    { 3, 9, D_8011B150 },   { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011A458 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 3, 9, D_8011B174 },  { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C794[] = {
    { 32, 4, D_8011B198 },
    { 0, 0, NULL },
    { 32, 4, D_8011B1A8 },
    { 32, 4, D_8011B1B8 },
};

CameraMode D_8011C7B4[] = {
    { 32, 4, D_8011B1C8 },
};

CameraMode D_8011C7BC[] = {
    { 33, 5, D_8011B1D8 },
};

CameraMode sData4Modes[] = {
    { 40, 3, sData4Normal },
};

CameraMode D_8011C7CC[] = {
    { 35, 5, D_8011B1F8 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011A748 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 0, 0, NULL },        { 0, 0, NULL },         { 0, 0, NULL },
    { 0, 0, NULL },         { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011C874[] = {
    CAM_MODE_INIT(CAM_FUNC_FIXD3, D_8011B20C),
    CAM_MODE_NONE,
    CAM_MODE_INIT(CAM_FUNC_FIXD3, D_8011B210),
    CAM_MODE_INIT(CAM_FUNC_FIXD3, D_8011B210),
};

CameraMode D_8011C894[] = {
    CAM_MODE_INIT(CAM_FUNC_UNIQ7, D_8011B214),
    CAM_MODE_NONE,
    CAM_MODE_INIT(CAM_FUNC_UNIQ7, D_8011B21C),
    CAM_MODE_INIT(CAM_FUNC_KEEP0, D_8011B224),
};

CameraMode D_8011C8B4[] = {
    CAM_MODE_INIT(CAM_FUNC_SPEC6, D_8011B20C),
};

CameraMode D_8011C8BC[] = {
    { 44, 3, D_8011B234 },
};

CameraMode D_8011C8C4[] = {
    { 70, 3, D_8011B240 },
    { 70, 3, D_8011B24C },
};

CameraMode D_8011C8D4[] = {
    { 20, 6, D_8011B258 },
};

CameraMode D_8011C8DC[] = {
    { 41, 1, D_8011B20C },
};

CameraMode D_8011C8E4[] = {
    { 41, 1, D_8011B270 },
};

CameraMode D_8011C8EC[] = {
    { 47, 1, D_8011B274 },
};

CameraMode D_8011C8F4[] = {
    { 47, 1, D_8011B278 },
};

CameraMode D_8011C8FC[] = {
    { 33, 5, D_8011B27C },
};

CameraMode D_8011C904[] = {
    { 43, 4, D_8011B290 },
    { 43, 4, D_8011B2A0 },
};

CameraMode D_8011C914[] = {
    { 52, 1, D_8011B2B0 },
};

CameraMode D_8011C91C[] = {
    { 53, 1, D_8011B2B0 },
};

CameraMode D_8011C924[] = {
    { 7, 11, D_8011B2B4 },
    { 0, 0, NULL },
    { 0, 0, NULL },
    { 9, 1, D_8011B2E0 },
};

CameraMode D_8011C944[] = {
    { 54, 3, D_8011B2E4 },
};

CameraMode D_8011C94C[] = {
    { 55, 3, D_8011B2E4 },
};

CameraMode D_8011C954[] = {
    { 60, 1, D_8011B2F0 },
};

CameraMode D_8011C95C[] = {
    { 56, 1, D_8011B2B0 },
};

CameraMode D_8011C964[] = {
    { 2, 10, D_8011B2F4 },  { 7, 11, D_8011B31C }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011A748 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011B348 }, { 42, 7, D_8011B368 },  { 42, 7, D_8011B384 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011B3A0 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011CA0C[] = {
    { 2, 10, D_8011B3C8 },  { 7, 11, D_8011B3F0 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011A748 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011B41C }, { 42, 7, D_8011B43C },  { 42, 7, D_8011B458 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011B474 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011CAB4[] = {
    { 70, 3, D_8011B49C },
};

CameraMode D_8011CABC[] = {
    { 43, 4, D_8011B4A8 },
};

CameraMode D_8011CAC4[] = {
    { 68, 1, D_8011B20C },
};

CameraMode D_8011CACC[] = {
    { 65, 1, D_8011B2B0 },
};

CameraMode D_8011CAD4[] = {
    { 46, 1, D_8011B2B0 },
};

CameraMode D_8011CADC[] = {
    { 57, 1, D_8011B2B0 },
};

CameraMode D_8011CAE4[] = {
    { 2, 10, D_8011B4B8 },  { 7, 11, D_8011A8C4 }, { 12, 13, D_8011A8F0 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011B4E0 }, { 23, 9, D_8011A994 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A778 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A9B8 },  { 22, 8, D_8011A954 }, { 42, 7, D_8011A9F8 },  { 42, 7, D_8011AA14 },
    { 22, 8, D_8011A974 },  { 30, 7, D_8011A9DC }, { 2, 10, D_8011B510 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011CB8C[] = {
    { 2, 10, D_8011B538 }, { 7, 11, D_8011B560 }, { 0, 0, NULL },
    { 0, 0, NULL },        { 7, 11, D_8011B58C }, { 2, 10, D_8011B5B8 },
};

CameraMode D_8011CBBC[] = {
    { 2, 10, D_8011B5E0 }, { 7, 11, D_8011B608 }, { 0, 0, NULL },
    { 0, 0, NULL },        { 7, 11, D_8011B634 }, { 2, 10, D_8011B660 },
};

CameraMode D_8011CBEC[] = {
    { 2, 10, D_8011B688 }, { 7, 11, D_8011B6B0 }, { 0, 0, NULL },
    { 0, 0, NULL },        { 7, 11, D_8011B6DC }, { 2, 10, D_8011B708 },
};

CameraMode D_8011CC1C[] = {
    { 15, 9, D_8011B730 },
};

CameraMode D_8011CC24[] = {
    { 61, 2, D_8011B754 },
};

CameraMode D_8011CC2C[] = {
    { 2, 10, D_8011B75C },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011A748 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011CCD4[] = {
    { 2, 10, D_8011B784 },  { 7, 11, D_8011B7AC }, { 27, 12, D_8011B7D8 }, { 14, 12, D_8011B808 },
    { 27, 12, D_8011B7D8 }, { 0, 0, NULL },        { 19, 9, D_8011B838 },  { 0, 0, NULL },
    { 0, 0, NULL },         { 0, 0, NULL },        { 0, 0, NULL },         { 0, 0, NULL },
    { 0, 0, NULL },         { 22, 8, D_8011B85C }, { 42, 7, D_8011B89C },  { 42, 7, D_8011B8B8 },
    { 22, 8, D_8011B87C },
};

CameraMode D_8011CD5C[] = {
    { 50, 1, D_8011B8D4 },
};

CameraMode D_8011CD64[] = {
    { 2, 10, D_8011B8D8 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011B900 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011CE0C[] = {
    { 2, 10, D_8011B930 },  { 7, 11, D_8011B958 }, { 12, 13, D_8011A8F0 }, { 14, 12, D_8011A428 },
    { 27, 12, D_8011B984 }, { 23, 9, D_8011B9F4 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A778 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011BA18 },  { 22, 8, D_8011B9B4 }, { 42, 7, D_8011BA3C },  { 42, 7, D_8011BA58 },
    { 22, 8, D_8011B9D4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011BA74 },  { 7, 11, D_8011BA9C },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011CEB4[] = {
    { 2, 10, D_8011BAC8 },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011BAF0 }, { 14, 12, D_8011BB24 },
    { 27, 12, D_8011A458 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraMode D_8011CF5C[] = {
    { 35, 5, D_8011B1F8 }, { 0, 0, NULL },        { 35, 5, D_8011B1F8 }, { 14, 12, D_8011A428 },
    { 0, 0, NULL },        { 0, 0, NULL },        { 19, 9, D_8011A4AC }, { 19, 9, D_8011A4D0 },
    { 0, 0, NULL },        { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 }, { 19, 9, D_8011A55C },
};

CameraMode D_8011CFBC[] = {
    { 2, 10, D_8011B75C },  { 7, 11, D_8011A3C8 }, { 12, 13, D_8011A3F4 }, { 14, 12, D_8011BB54 },
    { 27, 12, D_8011A748 }, { 23, 9, D_8011A488 }, { 19, 9, D_8011A4AC },  { 19, 9, D_8011A4D0 },
    { 19, 9, D_8011A4F4 },  { 66, 8, D_8011A518 }, { 19, 9, D_8011A538 },  { 19, 9, D_8011A55C },
    { 23, 9, D_8011A580 },  { 22, 8, D_8011A5A4 }, { 42, 7, D_8011A5C4 },  { 42, 7, D_8011A5E0 },
    { 22, 8, D_8011A5A4 },  { 30, 7, D_8011A61C }, { 2, 10, D_8011A638 },  { 7, 11, D_8011A660 },
    { 12, 13, D_8011A68C },
};

CameraSetting sCameraSettings[] = {
    { { 0x00000000 }, NULL },       { { 0x051FFFFF }, D_8011BB84 }, { { 0x051FFFFF }, D_8011BC2C },
    { { 0x051FFFFF }, D_8011BCD4 }, { { 0x051FFFFF }, D_8011BD7C }, { { 0x050FF7FF }, D_8011BE24 },
    { { 0x8500018F }, D_8011BEC4 }, { { 0x051FFFFF }, D_8011BF0C }, { { 0x051FFFFF }, D_8011BFB4 },
    { { 0x051FFFFF }, D_8011C05C }, { { 0x051FFFFF }, D_8011C104 }, { { 0x051FFFFF }, D_8011C1AC },
    { { 0x051FFFFF }, D_8011C254 }, { { 0x051FFFFF }, D_8011C2FC }, { { 0x051FFFFF }, D_8011C3A4 },
    { { 0x051FFFFF }, D_8011C44C }, { { 0x051FFFFF }, D_8011C4F4 }, { { 0x051FFFFF }, D_8011C59C },
    { { 0x851FFFFF }, D_8011C644 }, { { 0x851FFFFF }, D_8011C6EC }, { { 0x8500000D }, D_8011C794 },
    { { 0x85000001 }, D_8011C7B4 }, { { 0x85000001 }, D_8011C7BC }, { { 0x85000001 }, sData4Modes },
    { { 0x851E1FFF }, D_8011C7CC }, { { 0x8C00000D }, D_8011C874 }, { { 0x8C00000D }, D_8011C894 },
    { { 0x8C000001 }, D_8011C8B4 }, { { 0xC5000001 }, D_8011C8BC }, { { 0xC5000003 }, D_8011C8C4 },
    { { 0xC5000001 }, D_8011C8D4 }, { { 0xC5000001 }, D_8011C8DC }, { { 0xC5000001 }, D_8011C8E4 },
    { { 0x05000001 }, D_8011C8EC }, { { 0x05000001 }, D_8011C8F4 }, { { 0x85000001 }, D_8011C8FC },
    { { 0x05000003 }, D_8011C904 }, { { 0xCE000001 }, D_8011C914 }, { { 0x4E000001 }, D_8011C91C },
    { { 0x05000009 }, D_8011C924 }, { { 0x45000001 }, D_8011C944 }, { { 0x45000001 }, D_8011C94C },
    { { 0x45000001 }, D_8011C954 }, { { 0x45000001 }, D_8011C95C }, { { 0x451FFFFF }, D_8011C964 },
    { { 0x451FFFFF }, D_8011CA0C }, { { 0xC5000001 }, D_8011CAB4 }, { { 0x45000001 }, D_8011CABC },
    { { 0x05000001 }, D_8011CAC4 }, { { 0x45000001 }, D_8011CACC }, { { 0x45000001 }, D_8011CAD4 },
    { { 0x45000001 }, D_8011CADC }, { { 0x451FFFFF }, D_8011CAE4 }, { { 0x05000033 }, D_8011CB8C },
    { { 0x05000033 }, D_8011CBBC }, { { 0x05000033 }, D_8011CBEC }, { { 0x4A000001 }, D_8011CC1C },
    { { 0x05000001 }, D_8011CC24 }, { { 0x051FFFFF }, D_8011CC2C }, { { 0x0501E05F }, D_8011CCD4 },
    { { 0x45000001 }, D_8011CD5C }, { { 0x051FFFFF }, D_8011CD64 }, { { 0x051FFFFF }, D_8011CE0C },
    { { 0x051FFFFF }, D_8011CEB4 }, { { 0xC5000ECD }, D_8011CF5C }, { { 0x051FFFFF }, D_8011CFBC },
};

s32 Camera_Normal0(Camera* camera);
s32 Camera_Normal1(Camera* camera);
s32 Camera_Normal2(Camera* camera);
s32 Camera_Normal3(Camera* camera);
s32 Camera_Normal4(Camera* camera);
s32 Camera_Parallel0(Camera* camera);
void Camera_Parallel1(Camera* camera);
s32 Camera_Parallel2(Camera* camera);
void Camera_Parallel3(Camera* camera);
s32 Camera_Parallel4(Camera* camera);
s32 Camera_KeepOn0(Camera* camera);
s32 Camera_KeepOn1(Camera* camera);
s32 Camera_KeepOn2(Camera* camera);
s32 Camera_KeepOn3(Camera* camera);
s32 Camera_KeepOn4(Camera* camera);
s32 Camera_Subj0(Camera* camera);
s32 Camera_Subj1(Camera* camera);
s32 Camera_Subj2(Camera* camera);
s32 Camera_Subj3(Camera* camera);
s32 Camera_Subj4(Camera* camera);
s32 Camera_Jump0(Camera* camera);
s32 Camera_Jump1(Camera* camera);
s32 Camera_Jump2(Camera* camera);
s32 Camera_Jump3(Camera* camera);
s32 Camera_Jump4(Camera* camera);
s32 Camera_Battle0(Camera* camera);
void Camera_Battle1(Camera* camera);
s32 Camera_Battle2(Camera* camera);
s32 Camera_Battle3(Camera* camera);
s32 Camera_Battle4(Camera* camera);
s32 Camera_Fixed0(Camera* camera);
s32 Camera_Fixed1(Camera* camera);
s32 Camera_Fixed2(Camera* camera);
s32 Camera_Fixed3(Camera* camera);
s32 Camera_Fixed4(Camera* camera);
s32 Camera_Data0(Camera* camera);
s32 Camera_Data1(Camera* camera);
s32 Camera_Data2(Camera* camera);
s32 Camera_Data3(Camera* camera);
s32 Camera_Data4(Camera* camera);
s32 Camera_Unique0(Camera* camera);
s32 Camera_Unique1(Camera* camera);
s32 Camera_Unique2(Camera* camera);
s32 Camera_Unique3(Camera* camera);
s32 Camera_Unique4(Camera* camera);
s32 Camera_Unique5(Camera* camera);
s32 Camera_Unique6(Camera* camera);
s32 Camera_Unique7(Camera* camera);
s32 Camera_Unique8(Camera* camera);
s32 Camera_Unique9(Camera* camera);
s32 Camera_Demo0(Camera* camera);
s32 Camera_Demo1(Camera* camera);
s32 Camera_Demo2(Camera* camera);
s32 Camera_Demo3(Camera* camera);
s32 Camera_Demo4(Camera* camera);
s32 Camera_Demo5(Camera* camera);
s32 Camera_Demo6(Camera* camera);
void Camera_Demo7(Camera* camera);
s32 Camera_Demo8(Camera* camera);
s32 Camera_Demo9(Camera* camera);
s32 Camera_Special0(Camera* camera);
s32 Camera_Special1(Camera* camera);
s32 Camera_Special2(Camera* camera);
s32 Camera_Special3(Camera* camera);
s32 Camera_Special4(Camera* camera);
s32 Camera_Special5(Camera* camera);
s32 Camera_Special6(Camera* camera);
s32 Camera_Special7(Camera* camera);
s32 Camera_Special8(Camera* camera);
s32 Camera_Special9(Camera* camera);

typedef s32(*CameraFunc)(Camera*);
CameraFunc sCameraFunctions[] = {
    NULL,
    Camera_Normal0,
    Camera_Normal1,
    Camera_Normal2,
    Camera_Normal3,
    Camera_Normal4,
    Camera_Parallel0,
    Camera_Parallel1,
    Camera_Parallel2,
    Camera_Parallel3,
    Camera_Parallel4,
    Camera_KeepOn0,
    Camera_KeepOn1,
    Camera_KeepOn2,
    Camera_KeepOn3,
    Camera_KeepOn4,
    Camera_Subj0,
    Camera_Subj1,
    Camera_Subj2,
    Camera_Subj3,
    Camera_Subj4,
    Camera_Jump0,
    Camera_Jump1,
    Camera_Jump2,
    Camera_Jump3,
    Camera_Jump4,
    Camera_Battle0,
    Camera_Battle1,
    Camera_Battle2,
    Camera_Battle3,
    Camera_Battle4,
    Camera_Fixed0,
    Camera_Fixed1,
    Camera_Fixed2,
    Camera_Fixed3,
    Camera_Fixed4,
    Camera_Data0,
    Camera_Data1,
    Camera_Data2,
    Camera_Data3,
    Camera_Data4,
    Camera_Unique0,
    Camera_Unique1,
    Camera_Unique2,
    Camera_Unique3,
    Camera_Unique4,
    Camera_Unique5,
    Camera_Unique6,
    Camera_Unique7,
    Camera_Unique8,
    Camera_Unique9,
    Camera_Demo0,
    Camera_Demo1,
    Camera_Demo2,
    Camera_Demo3,
    Camera_Demo4,
    Camera_Demo5,
    Camera_Demo6,
    Camera_Demo7,
    Camera_Demo8,
    Camera_Demo9,
    Camera_Special0,
    Camera_Special1,
    Camera_Special2,
    Camera_Special3,
    Camera_Special4,
    Camera_Special5,
    Camera_Special6,
    Camera_Special7,
    Camera_Special8,
    Camera_Special9,
};

s32 sInitRegs = 1; // 8011D390

UNK_TYPE gDbgCamEnabled = 0;
s32 D_8011D398 = -1;
s16 sNextUID = 0; // size = 4 ?

s32 sCameraInterfaceFlags = 1;


s32 D_8011D3A4 = 0x02;
s32 D_8011D3A8 = 0x20;
s32 D_8011D3AC = -1;

s16 D_8011D3B0[] = {
    0x0AAA, 0xF556, 0x1555, 0xEAAB, 0x2AAA, 0xD556, 0x3FFF, 0xC001, 0x5555, 0xAAAB, 0x6AAA, 0x9556, 0x7FFF, 0x0000,
};

s16 D_8011D3CC[] = {
    0x0000, 0x02C6, 0x058C, 0x0000, 0x0000, 0xFD3A, 0x0000, 0x0852, 0x0000, 0x0000, 0x0B18, 0x02C6, 0xFA74, 0x0000,
};

s32 sUpdateCameraDirection = 0; // size = 8?
s32 D_8011D3EC = 0;
s32 D_8011D3F0 = 0;

s32 D_8011D3F4 = -16;

char sCameraFunctionNames[][8] = {
    "NONE   ", "NORM0()", "NORM1()", "NORM2()", "NORM3()", "NORM4()", "PARA0()", "PARA1()", "PARA2()", "PARA3()",
    "PARA4()", "KEEP0()", "KEEP1()", "KEEP2()", "KEEP3()", "KEEP4()", "SUBJ0()", "SUBJ1()", "SUBJ2()", "SUBJ3()",
    "SUBJ4()", "JUMP0()", "JUMP1()", "JUMP2()", "JUMP3()", "JUMP4()", "BATT0()", "BATT1()", "BATT2()", "BATT3()",
    "BATT4()", "FIXD0()", "FIXD1()", "FIXD2()", "FIXD3()", "FIXD4()", "DATA0()", "DATA1()", "DATA2()", "DATA3()",
    "DATA4()", "UNIQ0()", "UNIQ1()", "UNIQ2()", "UNIQ3()", "UNIQ4()", "UNIQ5()", "UNIQ6()", "UNIQ7()", "UNIQ8()",
    "UNIQ9()", "DEMO0()", "DEMO1()", "DEMO2()", "DEMO3()", "DEMO4()", "DEMO5()", "DEMO6()", "DEMO7()", "DEMO8()",
    "DEMO9()", "SPEC0()", "SPEC1()", "SPEC2()", "SPEC3()", "SPEC4()", "SPEC5()", "SPEC6()", "SPEC7()", "SPEC8()",
    "SPEC9()", "",        "",        "",        "",        "",
};

VecSph D_8011D658[] = {
    { 50.0f, 0xEE3A, 0xD558 },
    { 75.0f, 0x0000, 0x8008 },
    { 80.0f, 0xEE3A, 0x8008 },
    { 15.0f, 0xEE3A, 0x8008 },
};

Vec3f D_8011D678[] = {
    { 0.0f, 40.0f, 20.0f },
    { 0.0f, 40.0f, 0.0f },
    { 0.0f, 3.0f, -3.0f },
    { 0.0f, 3.0f, -3.0 },
};

s32 D_8011D6A8 = -200;

u8 D_8011D6AC[] = {
    0x8F, 0xFF, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xFF, 0x03, 0x03,
};

u8 D_8011D6D8[] = {
    0x00, 0x13, 0x00, 0x00, 0x42, 0x34, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xA0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0xFF,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF,
    0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
};

u8 D_8011D724[] = {
    0x8F, 0xFF, 0x24, 0x24, 0x00, 0x01, 0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00,
    0xC1, 0xA0, 0x00, 0x00, 0x81, 0xFF, 0x21, 0x21, 0x00, 0x13, 0x00, 0x00, 0x42, 0x48, 0x00, 0x00, 0x3F, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC1, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x42, 0x70,
    0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
    0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
};

u8 D_8011D79C[] = {
    0xCF, 0xFF, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC1, 0xFF, 0x03, 0x03, 0x00, 0x13, 0x00, 0x00, 0x42, 0x34, 0x00, 0x00, 0x3F, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC1, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC1, 0x20, 0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0xC1, 0xFF, 0x03, 0x03, 0x00, 0x09, 0x00, 0x00, 0x42, 0x70,
    0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
    0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
};

u8 D_8011D83C[] = {
    0x83, 0xFF, 0x21, 0x41, 0x00, 0x14, 0x00, 0x00, 0x42, 0x34, 0x00, 0x00, 0x3E, 0x4C, 0xCC, 0xCD,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
    0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
};

u8 D_8011D88C[] = {
    0x81, 0xFF, 0x03, 0x03, 0x00, 0x14, 0x00, 0x00, 0x42, 0x34, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
    0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
};

u8 D_8011D8DC[] = {
    0x8F, 0xFF, 0x04, 0x04, 0x00, 0x14, 0x00, 0x01, 0x42, 0x48, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00,
    0xC2, 0xA0, 0x00, 0x00, 0x82, 0xFF, 0x21, 0x21, 0x00, 0x05, 0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xA0, 0x00, 0x00,
    0x40, 0xA0, 0x00, 0x00, 0xC3, 0x48, 0x00, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x42, 0x70,
    0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
    0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
};

u8 D_8011D954[] = {
    0x0F, 0xFF, 0xC1, 0xC1, 0x00, 0x14, 0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x43, 0x7A, 0x00, 0x00, 0x83, 0xFF, 0x05, 0xB1, 0x00, 0x05, 0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x3D, 0xCC,
    0xCC, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00, 0x42, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0x20, 0x00, 0x00, 0x42, 0xC8, 0x00, 0x00, 0x82, 0xFF, 0x21, 0x21, 0x00, 0x05, 0x00, 0x02, 0x42, 0x70,
    0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x41, 0xA0, 0x00, 0x00, 0xC3, 0x16, 0x00, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
    0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
};

u8 D_8011D9F4[] = {
    0x8F, 0xFF, 0x05, 0x04, 0x00, 0x14, 0x00, 0x02, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x42, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xA0, 0x00, 0x00,
    0x43, 0x96, 0x00, 0x00, 0x82, 0xFF, 0x21, 0x21, 0x00, 0x05, 0x00, 0x02, 0x42, 0x70, 0x00, 0x00, 0x3F, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0xA0, 0x00, 0x00, 0xC3, 0x16, 0x00, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x42, 0x70,
    0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
    0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00,
};

Vec3f D_8011DA6C[] = {
    { 3050.0f, 700.0f, 0.0f },
    { 1755.0f, 3415.0f, -380.0f },
    { -3120.0f, 3160.0f, 245.0f },
    { 0.0f, -10.0f, 240.0f }
};

Vec3f D_8011DA9C[] = {
    { 3160.0f, 2150.0f, 0.0f },
    { 1515.0f, 4130.0f, -835.0f },
    { -3040.0f, 4135.0f, 230.0f },
    { -50.0f, 600.0f, -75.0f }, 
};

f32 D_8011DACC[] = {
    1570.0f, 3680.0f, 3700.0f, 395.0f
};

f32 D_8011DADC[] = {
    320.0f, 320.0f, 320.0f, 0.0f
};

s16 D_8011DAEC[] = { -2000, -1000, 0, 0, 0, 0, 0, 0 };

s16 D_8011DAFC[] = {
    CAM_SET_NORMAL0, CAM_SET_NORMAL1, CAM_SET_NORMAL2, CAM_SET_DUNGEON0, CAM_SET_DUNGEON1, CAM_SET_DUNGEON2,
};

// BSS
typedef struct {
    Vec3f unk_00;
    Vec3f unk_0C;
    CollisionPoly* unk_18;
    VecSph unk_1C;
    s32 unk_24;
} struct_80043D18;

Vec3f D_8015BD50; // 8015BD50
// 8015BD5C
char D_8015BD5C[0x10];
Vec3f D_8015BD70; // 8015BD70
GlobalContext* D_8015BD7C; // 8015BD7C
DBCamera D_8015BD80; // 8015BD80
CollisionPoly *playerFloorPoly;
f32 D_8015CE50;
f32 D_8015CE54;

struct_80043D18 D_8015CE58;
struct_80043D18 D_8015CE80;
struct_80043D18 D_8015CEA8;
struct_80043D18 D_8015CED0;

extern DBCamera D_8015BD80;
extern GlobalContext* D_8015BD7C;
extern CollisionPoly* playerFloorPoly;

/*===============================================================*/


f32 func_800437F0(f32 arg0, f32 arg1) {
    const f32 percent = 0.4f;
    f32 ret = fabsf(arg1);

    if (arg0 < ret) {
        ret = 1;
    } else if (ret < (f32)arg0 * (1 - percent)) { //! float cast needed to match
        ret = (SQ(arg1) * (1 - percent)) / SQ((1 - percent) * arg0);
    } else {
        ret = 1 - (0.4f * SQ(arg0 - ret)) / SQ(0.4f * arg0);
    }

    return ret;
}

/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded up to `target`
*/
f32 Camera_LERPCeilF(f32 target, f32 cur, f32 stepScale, f32 minDiff) {
    f32 diff = target - cur;
    f32 step;
    f32 ret;

    if (fabsf(diff) >= minDiff) {
        step = diff * stepScale;
        ret = cur + step;
    } else {
        ret = target;
    }

    return ret;
}

/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded down to `cur`
*/
f32 Camera_LERPFloorF(f32 target, f32 cur, f32 stepScale, f32 minDiff) {
    f32 diff = target - cur;
    f32 step;
    f32 ret;

    if (fabsf(diff) >= minDiff) {
        step = diff * stepScale;
        ret = cur + step;
    } else {
        ret = cur;
    }

    return ret;
}

/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded up to `target`
*/
s16 Camera_LERPCeilS(s16 target, s16 cur, f32 stepScale, s16 minDiff) {
    s16 diff = target - cur;
    s16 step;
    s32 ret;

    if (ABS(diff) >= minDiff) {
        step = diff * stepScale + 0.5f;
        ret = cur + step;
    } else {
        ret = target;
    }

    return ret;
}

/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded down to `cur`
*/
s16 Camera_LERPFloorS(s16 target, s16 cur, f32 stepScale, s16 minDiff) {
    s16 diff = target - cur;
    s16 step;
    s32 ret;

    if (ABS(diff) >= minDiff) {
        step = diff * stepScale + 0.5f;
        ret = cur + step;
    } else {
        ret = cur;
    }

    return ret;
}

/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded up to `target`
*/
void Camera_LERPCeilVec3f(Vec3f* target, Vec3f* cur, f32 yStepScale, f32 xzStepScale, f32 minDiff) {
    cur->x = Camera_LERPCeilF(target->x, cur->x, xzStepScale, minDiff);
    cur->y = Camera_LERPCeilF(target->y, cur->y, yStepScale, minDiff);
    cur->z = Camera_LERPCeilF(target->z, cur->z, xzStepScale, minDiff);
}

void func_80043ABC(Camera* camera) {
    camera->thetaUpdateRateInv = 100.0f;
    camera->phiUpdateRateInv = OREG(7);
    camera->rUpdateRateInv = OREG(6);
    camera->xzOffsetUpdateRate = OREG(2) * 0.01f;
    camera->yOffsetUpdateRate = OREG(3) * 0.01f;
    camera->fovUpdateRate = OREG(4) * 0.01f;
}

void func_80043B60(Camera* camera) {
    camera->rUpdateRateInv = OREG(27);
    camera->thetaUpdateRateInv = OREG(27);
    camera->phiUpdateRateInv = OREG(27);
    camera->xzOffsetUpdateRate = 0.001f;
    camera->yOffsetUpdateRate = 0.001f;
    camera->fovUpdateRate = 0.001f;
}

Vec3f* Camera_Vec3sToVec3f(Vec3f* dest, Vec3s* src) {
    Vec3f copy;

    copy.x = src->x;
    copy.y = src->y;
    copy.z = src->z;

    *dest = copy;
    return dest;
}

Vec3f* Camera_Vec3fVecSphAdd(Vec3f* dest, Vec3f* a, VecSph* b) {
    Vec3f copy, vecB;
    OLib_VecSphRot90ToVec3f(&vecB, b);

    copy.x = a->x + vecB.x;
    copy.y = a->y + vecB.y;
    copy.z = a->z + vecB.z;

    *dest = copy;
    return dest;
}

Vec3f* Camera_Vec3fScaleXYZFactor(Vec3f* dest, Vec3f* src, Vec3f* scale, f32 scaleFactor) {
    Vec3f copy;

    copy.x = src->x + (scale->x * scaleFactor);
    copy.y = src->y + (scale->y * scaleFactor);
    copy.z = src->z + (scale->z * scaleFactor);

    *dest = copy;
    return dest;
}

s32 func_80043D18(Camera* camera, Vec3f* arg1, struct_80043D18* arg2) {
    CollisionContext* colCtx;
    Vec3f sp68, sp5C, sp50;
    f32 temp_ret;
    CollisionPoly* sp48;
    s32 sp44;
    VecSph sp3C;

    colCtx = &camera->globalCtx->colCtx;
    OLib_Vec3fDiffToVecSphRot90(&sp3C, arg1, &arg2->unk_00);
    sp3C.r += 8.0f;
    Camera_Vec3fVecSphAdd(&sp5C, arg1, &sp3C);

    if (func_8003DD6C(colCtx, arg1, &sp5C, &sp68, &arg2->unk_18, 1, 1, 1, -1, &arg2->unk_24) == 0) {
        OLib_Vec3fDistNormalize(&sp50, arg1, &arg2->unk_00);

        arg2->unk_0C.x = -sp50.x;
        arg2->unk_0C.y = -sp50.y;
        arg2->unk_0C.z = -sp50.z;

        sp68 = arg2->unk_00;
        sp68.y += 5.0f;
        temp_ret = func_8003CCA4(colCtx, &sp48, &sp44, &sp68);

        if ((arg2->unk_00.y - temp_ret) > 5.0f) {
            arg2->unk_00.x += arg2->unk_0C.x;
            arg2->unk_00.y += arg2->unk_0C.y;
            arg2->unk_00.z += arg2->unk_0C.z;
            return 0;
        }

        arg2->unk_18 = sp48;
        sp68.y = temp_ret + 1.0f;
        arg2->unk_24 = sp44;
    }

    arg2->unk_0C.x = arg2->unk_18->norm.x * (1.f / 32767);
    arg2->unk_0C.y = arg2->unk_18->norm.y * (1.f / 32767);
    arg2->unk_0C.z = arg2->unk_18->norm.z * (1.f / 32767);
    arg2->unk_00.x = arg2->unk_0C.x + sp68.x;
    arg2->unk_00.y = arg2->unk_0C.y + sp68.y;
    arg2->unk_00.z = arg2->unk_0C.z + sp68.z;

    return sp44 + 1;
}

s32 func_80043F34(Camera* camera, Vec3f* arg1, Vec3f* arg2) {
    struct_80043D18 sp20;
    s32 ret;

    sp20.unk_00 = *arg2;
    ret = func_80043D18(camera, arg1, &sp20);
    *arg2 = sp20.unk_00;
    return ret;
}

// 242 lines
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80043F94.s")

void func_80044340(Camera* camera, Vec3f* arg1, Vec3f* arg2) {
    struct_80043D18 sp20;
    Vec3s unused;

    sp20.unk_00 = *arg2;
    func_80043F94(camera, arg1, &sp20);
    *arg2 = sp20.unk_00;
}

s32 func_800443A0(Camera* camera, Vec3f* arg1, Vec3f* arg2) {
    s32 pad;
    Vec3f sp40;
    s32 pad2;
    s32 sp38;
    CollisionPoly* sp34;
    CollisionContext* colCtx;
    colCtx = &camera->globalCtx->colCtx;

    sp34 = NULL;
    if (func_8003DD6C(colCtx, arg1, arg2, &sp40, &sp34, 1, 1, 1, 0, &sp38) && (func_80038B7C(sp34, arg1) < 0.0f)) {
        return true;
    }

    return false;
}

f32 func_80044434(Camera* camera, Vec3f* arg1, Vec3f* arg2, s32* arg3) {
    s32 sp2C; // unused
    CollisionPoly* sp28;
    f32 temp_ret = func_8003C940(&camera->globalCtx->colCtx, &sp28, arg3, arg2);

    if (temp_ret == -32000.0f) {
        arg1->x = 0.0f;
        arg1->z = 0.0f;
        arg1->y = 1.0f;
    } else {
        arg1->x = sp28->norm.x * (1.f / 32767);
        arg1->y = sp28->norm.y * (1.f / 32767);
        arg1->z = sp28->norm.z * (1.f / 32767);
    }

    return temp_ret;
}

f32 func_80044510(Camera* camera, Vec3f* arg1) {
    Vec3f sp2C, sp20;
    s32 sp1C;

    sp2C = *arg1;
    sp2C.y += 80.0f;

    return func_80044434(camera, &sp20, &sp2C, &sp1C);
}

f32 func_80044568(Camera *camera, Vec3f *arg1, Vec3f *arg2, s32 *arg3) {
    CollisionPoly *sp6C;
    CollisionContext *colCtx = &camera->globalCtx->colCtx;
    f32 temp_f0;
    s32 i;

    for(i = 3; i > 0; i--){
        temp_f0 = func_8003CCA4(colCtx, &sp6C, arg3, arg2);
        // ! is needed, inverting the conditional does not match
        if (temp_f0 == -32000.0f || (camera->unk_104 < temp_f0 && !((sp6C->norm.y * (1.0f / 32767.0f)) > 0.5f))) {
            arg1->x = 0.0f;
            arg1->y = 1.0f;
            arg1->z = 0.0f;
            temp_f0 = -32000.0f;
            break;
        } else if (func_80041D4C(colCtx, sp6C, *arg3) == 1) {
            // poly behavior == 1, what is 1? grass in kokiri forest
            arg2->y = temp_f0 - 10.0f;
            continue;
        } else {
            arg1->x = sp6C->norm.x * (1.0f / 32767.0f);
            arg1->y = sp6C->norm.y * (1.0f / 32767.0f);
            arg1->z = sp6C->norm.z * (1.0f / 32767.0f);
            break;
        }
    }
    if (i == 0) {
        osSyncPrintf(VT_COL(YELLOW, BLACK) "camera: foward check: too many layer!\n" VT_RST);
    }
    return temp_f0;
}

s16 Camera_GetCamDataSetting(Camera* camera, s32 camDataIdx) {
    return func_80041A4C(&camera->globalCtx->colCtx, camDataIdx, 50);
}

CamPosData* func_8004476C(Camera* camera) {
    return func_80041C10(&camera->globalCtx->colCtx, camera->camDataIdx, 50);
}

s32 func_8004479C(Camera* camera, s32* arg1, Vec3f* arg2) {
    s32 temp_ret;
    PosRot sp20;
    s32 ret;

    func_8002EF44(&sp20, &camera->player->actor);
    temp_ret = func_80041A28(&camera->globalCtx->colCtx, arg2, *arg1);

    if (func_80041A4C(&camera->globalCtx->colCtx, temp_ret, *arg1) == 0) {
        ret = -1;
    } else {
        ret = temp_ret;
    }
    return ret;
}

CamPosData* func_8004481C(Camera* camera, s16* arg1) {
    CollisionPoly* sp44;
    s32 sp40; // unused
    s32 sp3C;
    PosRot sp28;

    func_8002EF44(&sp28, &camera->player->actor);
    sp28.pos.y += Player_GetCameraYOffset(camera->player);
    if (func_8003C940(&camera->globalCtx->colCtx, &sp44, &sp3C, &sp28.pos) == -32000.0f) {
        return 0;
    }
    *arg1 = func_80041B80(&camera->globalCtx->colCtx, sp44, sp3C);
    return func_80041C98(&camera->globalCtx->colCtx, sp44, sp3C);
}

s32 func_800448CC(Camera* camera, f32* arg1) {
    PosRot sp34;
    s32 sp30;
    s32 temp_ret;

    func_8002EF44(&sp34, &camera->player->actor);
    *arg1 = sp34.pos.y;

    if (func_8004213C(camera->globalCtx, &camera->globalCtx->colCtx, sp34.pos.x, sp34.pos.z, arg1, &sp30) == 0) {
        *arg1 = -32000.0f;
        return -1;
    }
    if (!(camera->player->stateFlags1 & 0x8000000)) {
        *arg1 = -32000.0f;
        return -1;
    }

    temp_ret = func_80042538(&camera->globalCtx->colCtx, sp30);
    if ((temp_ret <= 0) || (func_80042548(&camera->globalCtx->colCtx, sp30) <= 0)) {
        return -2;
    }

    return temp_ret;
}

f32 func_800449AC(Camera* camera, Vec3f* arg1, s32* arg2) {
    PosRot sp2C;
    f32 sp28;
    s32 sp24;

    func_8002EF44(&sp2C, &camera->player->actor);
    sp28 = sp2C.pos.y;

    if (func_8004213C(camera->globalCtx, &camera->globalCtx->colCtx, arg1->x, arg1->z, &sp28, &sp24) == 0) {
        return -32000.f;
    }
    if (sp28 < arg1->y) {
        return -32000.f;
    }

    *arg2 = func_8004259C(&camera->globalCtx->colCtx, sp24);
    return sp28;
}

s16 func_80044A74(Vec3f* arg0, Vec3f* arg1) {
    return DEGF_TO_BINANG(RADF_TO_DEGF(Math_atan2f(arg1->x - arg0->x, arg1->z - arg0->z)));
}

s16 func_80044ADC(Camera* camera, s16, s32);
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80044ADC.s")

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80044E68.s")

f32 func_800450A4(Camera* camera, f32 arg1) {
    f32 ret;

    if (camera->atLERPStepScale < (OREG(41) * 0.01f)) {
        ret = OREG(41) * 0.01f;
    } else if (arg1 <= camera->atLERPStepScale) {
        ret = arg1;
    } else {
        ret = OREG(42) * 0.01f * camera->atLERPStepScale;
    }

    return ret;
}

void Camera_CopyModeValuesToPREG(Camera* camera, s16 mode) {
    CameraModeValue *values;
    CameraModeValue *valueP;
    s32 i;

    if (PREG(82)) {
        osSyncPrintf("camera: res: stat (%d/%d/%d)\n", camera->thisIdx, camera->setting, mode);
    }

    values = sCameraSettings[camera->setting].cameraModes[mode].values;

    for (i = 0;i < sCameraSettings[camera->setting].cameraModes[mode].valueCnt; i++) {
        valueP = &values[i];
        PREG(valueP->param) = valueP->val;
        if (PREG(82)) {
            osSyncPrintf("camera: res: PREG(%02d) = %d\n", valueP->param, valueP->val);
        }
    }
    camera->animState = 0;
}

s32 Camera_CopyPREGToModeValues(Camera* camera) {
    CameraModeValue* values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
    CameraModeValue* valueP;
    s32 i;

    for (i = 0; i < sCameraSettings[camera->setting].cameraModes[camera->mode].valueCnt; i++) {
        valueP = &values[i];
        valueP->val = PREG(valueP->param);
        if (PREG(82)) {
            osSyncPrintf("camera: res: %d = PREG(%02d)\n", valueP->val, valueP->param);
        }
    }
    return true;
}

void Camera_UpdateInterface(s16 arg0) {
    s16 phi_v1;

    if((arg0 & 0xF000) != 0xF000){
        switch(arg0 & 0x7000){
            case 0x1000:
                D_8011D3A8 = 0x1A;
                break;
            case 0x2000:
                D_8011D3A8 = 0x1B;
                break;
            case 0x3000:
                D_8011D3A8 = 0x20;
                break;
            default:
                D_8011D3A8 = 0;
                break;
        }

        if(arg0 & 0x8000){
            func_800B38A4(D_8011D3A8);
        } else {
            func_800B3840(D_8011D3A8);
        }
    }

    if ((arg0 & 0xF00) != 0xF00) {
        phi_v1 = (arg0 & 0xF00) >> 8;
        if(phi_v1 == 0) {
            phi_v1 = 0x32;
        }
        if (phi_v1 != D_8011D3A4) {
            D_8011D3A4 = phi_v1;
            Interface_ChangeAlpha(D_8011D3A4);
        }
    }
}

void* func_8004545C(Vec3f* arg0, s32 arg1, s32 arg2, struct_80043D18* arg3, struct_80043D18* arg4) {
    Vec3f sp24;

    if (func_800427B4(arg3->unk_18, arg4->unk_18, arg1, arg2, &sp24) == 0) {
        osSyncPrintf(VT_COL(YELLOW, BLACK) "camera: corner check no cross point %x %x\n" VT_RST, arg3, arg4);
        *arg0 = arg3->unk_00;
        return arg0;
    }

    *arg0 = sp24;
    return arg0;
}

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80045508.s")

#ifdef NON_MATCHING
// CLOSE: stack is 4 bytes too big
f32 func_80045714(Vec3f* arg0, s16 arg1, s16 arg2, f32 arg3) {
    VecSph sp1C;
    f32 sp18;

    OLib_Vec3fToVecSphRot90(&sp1C, arg0);
    sp18 = Math_Coss(sp1C.phi);
    sp18 = fabsf(Math_Coss(arg1 - sp1C.theta) * sp18);
    return Math_Coss(arg1 - arg2) * (sp18 * arg3);
}
#else
f32 func_80045714(Vec3f* a, s16 b, s16 c, f32 arg3);
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80045714.s")
#endif

f32 func_8007C0A8(f32, f32);

s32 func_800457A8(Camera* camera, VecSph* arg1, f32 arg2, s16 arg3) {
    f32 unused;
    Vec3f sp50;
    Vec3f sp44;
    s32 unused2;
    PosRot* sp2C;
    f32 temp_ret;

    temp_ret = Player_GetCameraYOffset(camera->player);

    sp50.x = 0.f;
    sp50.z = 0.f;
    sp50.y = temp_ret + arg2;

    sp2C = &camera->playerPosRot;
    if (arg3 != 0) {
        sp50.y -= func_8007C0A8(func_80045714(&camera->unk_108, sp2C->rot.y, arg1->theta, OREG(9)), temp_ret);
    }
    Camera_LERPCeilVec3f(&sp50, &camera->posOffset, camera->yOffsetUpdateRate, camera->xzOffsetUpdateRate, 0.1f);

    sp44.x = sp2C->pos.x + camera->posOffset.x;
    sp44.y = sp2C->pos.y + camera->posOffset.y;
    sp44.z = sp2C->pos.z + camera->posOffset.z;
    Camera_LERPCeilVec3f(&sp44, &camera->at, camera->atLERPStepScale, camera->atLERPStepScale, 0.2f);

    return 1;
}

#ifdef NON_MATCHING
// CLOSE: regalloc
s32 func_800458D4(Camera* camera, VecSph* arg1, f32 arg2, f32* arg3, s16 arg4) {
    f32 phi_f2;
    Vec3f sp60;
    Vec3f sp54;
    f32 temp_ret;
    PosRot* playerPosRot;
    f32 sp48;
    s32 pad[2];

    sp60.y = Player_GetCameraYOffset(camera->player) + arg2;
    sp60.x = 0.0f;
    sp60.z = 0.0f;

    playerPosRot = &camera->playerPosRot;
    if (arg4 != 0) {
        sp60.y -= func_80045714(&camera->unk_108, playerPosRot->rot.y, arg1->theta, OREG(9));
    }

    sp48 = playerPosRot->pos.y - *arg3;
    temp_ret = Math_atan2f(sp48, OLib_Vec3fDistXZ(&camera->at, &camera->eye));
    
    if (temp_ret > DEGF_TO_RADF(OREG(32))) {
        phi_f2 = 1.0f - sinf(DEGF_TO_RADF(temp_ret - OREG(32)));
    } else if (temp_ret < DEGF_TO_RADF(OREG(33))) {
        phi_f2 = 1.0f - sinf(DEGF_TO_RADF(OREG(33)) - temp_ret);
    } else {
        phi_f2 = 1.0f;
    }

    sp60.y -= sp48 * phi_f2;
    Camera_LERPCeilVec3f(&sp60, &camera->posOffset, OREG(29) * 0.01f, OREG(30) * 0.01f, 0.1f);

    sp54.x = playerPosRot->pos.x + camera->posOffset.x;
    sp54.y = playerPosRot->pos.y + camera->posOffset.y;
    sp54.z = playerPosRot->pos.z + camera->posOffset.z;
    Camera_LERPCeilVec3f(&sp54, &camera->at, camera->atLERPStepScale, camera->atLERPStepScale, 0.2f);

    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_800458D4.s")
#endif

s32 func_80045B08(Camera* camera, VecSph* arg1, f32 arg2, s16 arg3) {
    f32 phi_f2;
    Vec3f sp48;
    Vec3f sp3C;
    f32 sp38; // unused
    f32 temp_ret;
    PosRot* temp_s1;

    sp48.y = Player_GetCameraYOffset(camera->player) + arg2;
    sp48.x = 0.0f;
    sp48.z = 0.0f;

    temp_ret = Math_Sins(arg3);
    temp_s1 = &camera->playerPosRot;

    if (temp_ret < 0.0f) {
        phi_f2 = Math_Coss(temp_s1->rot.y - arg1->theta);
    } else {
        phi_f2 = -Math_Coss(temp_s1->rot.y - arg1->theta);
    }

    sp48.y -= temp_ret * phi_f2 * OREG(9);
    Camera_LERPCeilVec3f(&sp48, &camera->posOffset, camera->yOffsetUpdateRate, camera->xzOffsetUpdateRate, 0.1f);

    sp3C.x = temp_s1->pos.x + camera->posOffset.x;
    sp3C.y = temp_s1->pos.y + camera->posOffset.y;
    sp3C.z = temp_s1->pos.z + camera->posOffset.z;
    Camera_LERPCeilVec3f(&sp3C, &camera->at, camera->atLERPStepScale, camera->atLERPStepScale, 0.2f);

    return 1;
}

#ifdef NON_MATCHING
// regalloc and some minor reordering. 
s32 func_80045C74(Camera *camera, VecSph *arg1, f32 arg2, f32 *arg3, s16 arg4) {
    f32 temp_f0_4;
    Vec3f sp70;
    Vec3f sp64;
    f32 sp54;
    Vec3f *sp40 = &camera->at;
    PosRot *sp3C = &camera->playerPosRot;
    f32 temp_f14_2;
    f32 temp_f2;
    f32 phi_f20;
    f32 phi_f16;

    sp70.y = Player_GetCameraYOffset(camera->player) + arg2;
    sp70.x = 0.0f;
    sp70.z = 0.0f;
    if (PREG(76) != 0) {
        if (arg4 != 0) {
            sp70.y -= func_80045714(&camera->unk_108, sp3C->rot.y, arg1->theta, OREG(9));
        }
    }
    if (camera->unk_104 == camera->playerPosRot.pos.y || camera->player->actor.gravity > -0.1f || camera->player->stateFlags1 & 0x200000) {
        *arg3 = Camera_LERPCeilF(sp3C->pos.y, *arg3, OREG(43) * 0.01f, 0.1f);
        sp70.y-= sp3C->pos.y - *arg3;
        Camera_LERPCeilVec3f(&sp70, &camera->posOffset, camera->yOffsetUpdateRate, camera->xzOffsetUpdateRate, 0.1f);
    } else {
        if (PREG(75) == 0) {
            phi_f20 = sp3C->pos.y - *arg3;
            sp54 = OLib_Vec3fDistXZ(sp40, &camera->eye);
            Math_atan2f(phi_f20, sp54);
            temp_f2 = Math_tanf(DEG_TO_RAD(camera->fov * 0.4f)) * sp54;
            if (temp_f2 < phi_f20) {
                *arg3 += phi_f20 - temp_f2;
                phi_f20 = temp_f2;
            } else if (phi_f20 < -temp_f2) {
                *arg3 += phi_f20 + temp_f2;
                phi_f20 = -temp_f2;
            }
            sp70.y -= phi_f20;
        } else {
            phi_f20 = sp3C->pos.y - *arg3;
            temp_f0_4 = Math_atan2f(phi_f20, OLib_Vec3fDistXZ(sp40, &camera->eye));
            temp_f14_2 = DEG_TO_RAD(OREG(32));
            if (temp_f14_2 < temp_f0_4) {
                phi_f16 = 1.0f - sinf(temp_f0_4 - temp_f14_2);
            } else {
                temp_f14_2 = DEG_TO_RAD(OREG(33));
                if (temp_f0_4 < temp_f14_2) {
                    phi_f16 = 1.0f - sinf(temp_f14_2 - temp_f0_4);
                } else {
                    phi_f16 = 1.0f;
                }
            }
            sp70.y -= phi_f20 * phi_f16;
        }
        Camera_LERPCeilVec3f(&sp70, &camera->posOffset, OREG(29) * 0.01f, OREG(30) * 0.01f, 0.1f);
        camera->yOffsetUpdateRate = OREG(29) * 0.01f;
        camera->xzOffsetUpdateRate = OREG(30) * 0.01f;
    }
    sp64.x = sp3C->pos.x + camera->posOffset.x;
    sp64.y = sp3C->pos.y + camera->posOffset.y;
    sp64.z = sp3C->pos.z + camera->posOffset.z;
    Camera_LERPCeilVec3f(&sp64, sp40, camera->atLERPStepScale, camera->atLERPStepScale, 0.2f);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80045C74.s")
#endif

#ifdef NON_MATCHING
s32 func_800460A8(Camera *camera, VecSph *arg1, Vec3f *arg2, f32 arg3, f32 arg4, f32 *arg5, VecSph *arg6, s16 arg7) {
    Vec3f sp98;
    Vec3f sp8C;
    Vec3f sp80;
    VecSph sp74;
    f32 sp68;
    Vec3f *sp54;
    PosRot *sp50;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_6;
    f32 temp_f14_2;
    f32 temp_f2;
    f32 temp_f4;
    f32 phi_f20;
    f32 phi_f16;

    temp_f0 = Player_GetCameraYOffset(camera->player);
    sp98.x = 0.0f;
    sp98.z = 0.0f;
    sp98.y = temp_f0 + arg3;
    if (PREG(76)) {
        if ((arg7 & 1) != 0) {
            sp98.y -= func_80045714(&camera->unk_108, camera->playerPosRot.rot.y, arg1->theta, OREG(9));
        }
    }
    sp8C = camera->playerPosRot.pos;
    sp50 = &camera->playerPosRot;
    sp8C.y += temp_f0;
    OLib_Vec3fDiffToVecSphRot90(arg6, &sp8C, arg2);
    sp74 = *arg6;
    if (arg4 < sp74.r) {
        sp74.r = OREG(38) * 0.01f * sp74.r;
    } else {
        temp_f0_2 = func_8007C0A8((sp50->pos.y - camera->unk_104) / temp_f0, 1.0f);
        temp_f2 = OREG(39) * 0.01f;
        temp_f4 = (sp74.r * temp_f2) - (((temp_f2 - (OREG(38) * 0.01f)) * sp74.r) * (sp74.r / arg4));
        sp74.r = temp_f4 - ((temp_f4 * temp_f0_2) * temp_f0_2);
    }
    if (arg7 & 0x80) {
        sp74.r *= 0.2f;
        camera->xzOffsetUpdateRate = 0.01f;
        camera->yOffsetUpdateRate = 0.01f;
    }
    OLib_VecSphRot90ToVec3f(&sp80, &sp74);
    if (PREG(89)) {
        osSyncPrintf("%f (%f %f %f) %f\n", (sp74.r / arg4), sp80.x, sp80.y, sp80.z, camera->atLERPStepScale);
    }
    sp98.x += sp80.x;
    sp98.y += sp80.y;
    sp98.z += sp80.z;
    if (camera->playerPosRot.pos.y == camera->unk_104|| camera->player->actor.gravity > -0.1f || camera->player->stateFlags1 & 0x200000) {
        *arg5 = Camera_LERPCeilF(sp50->pos.y, *arg5, OREG(43) * 0.01f, 0.1f);;
        sp98.y -= sp50->pos.y - *arg5;
        Camera_LERPCeilVec3f(&sp98, &camera->posOffset, camera->yOffsetUpdateRate, camera->xzOffsetUpdateRate, 0.1f);
        sp54 = &camera->at;
    } else {
        if ((arg7 & 0x80) == 0) {
            sp54 = &camera->at;
            phi_f20 = sp50->pos.y - *arg5;
            sp68 = OLib_Vec3fDistXZ(&camera->at, &camera->eye);
            Math_atan2f(phi_f20, sp68);
            temp_f2 = Math_tanf(DEG_TO_RAD(camera->fov * 0.4f)) * sp68;
            if (temp_f2 < phi_f20) {
                *arg5 = (f32) (*arg5 + (phi_f20 - temp_f2));
                phi_f20 = temp_f2;
            } else {
                if (phi_f20 < -temp_f2) {
                    *arg5 = (f32) (*arg5 + (phi_f20 + temp_f2));
                    phi_f20 = -temp_f2;
                }
            }
            sp98.y -= phi_f20;
        } else {
            sp54 = &camera->at;
            phi_f20 = sp50->pos.y - *arg5;
            temp_f0_6 = Math_atan2f(phi_f20, OLib_Vec3fDistXZ(&camera->at, &camera->eye));
            temp_f14_2 = DEG_TO_RAD(OREG(32));
            if (temp_f14_2 < temp_f0_6) {
                phi_f16 = 1.0f - sinf(temp_f0_6 - temp_f14_2);
            } else {
                temp_f14_2 = DEG_TO_RAD(OREG(33));
                if (temp_f0_6 < temp_f14_2) {
                    phi_f16 = 1.0f - sinf(temp_f14_2 - temp_f0_6);
                } else {
                    phi_f16 = 1.0f;
                }
            }
            sp98.y -= phi_f20 * phi_f16;
        }
        Camera_LERPCeilVec3f(&sp98, &camera->posOffset, OREG(29) * 0.01f, OREG(30) * 0.01f, 0.1f);
        camera->yOffsetUpdateRate = OREG(29) * 0.01f;
        camera->xzOffsetUpdateRate = OREG(30) * 0.01f;
    }
    sp8C.x = sp50->pos.x + camera->posOffset.x;
    sp8C.y = sp50->pos.y + camera->posOffset.y;
    sp8C.z = sp50->pos.z + camera->posOffset.z;
    Camera_LERPCeilVec3f(&sp8C, sp54, camera->atLERPStepScale, camera->atLERPStepScale, 0.2f);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_800460A8.s")
#endif

s32 func_800466F8(Camera* camera, VecSph* arg1, f32 arg2, f32* arg3, s16 arg4) {
    s32 phi_v0;
    Vec3f sp60;
    Vec3f sp54;
    f32 sp50; // unused
    f32 sp4C; // unused
    f32 sp48; // I doubt this is a Vec3f
    Player* sp44;
    PosRot sp30;

    sp48 = Player_GetCameraYOffset(camera->player);
    sp44 = camera->player;
    func_8002EF44(&sp30, sp44->rideActor);

    if ((*(s32*)((s32)(sp44->rideActor) + 0x1F0) & 4) != 0) { // actors aren't this big, is rideActor a different type?
        phi_v0 = 1;
    } else {
        phi_v0 = 0;
    }

    if (phi_v0 != 0) {
        sp30.pos.y -= 49.f;
        *arg3 = Camera_LERPCeilF(sp30.pos.y, *arg3, 0.1f, 0.2f);
        camera->atLERPStepScale = Camera_LERPCeilF(0.4f, camera->atLERPStepScale, 0.2f, 0.02f);
    } else {
        *arg3 = Camera_LERPCeilF(sp30.pos.y, *arg3, 0.5f, 0.2f);
    }

    sp60.x = 0.0f;
    sp60.z = 0.0f;
    sp60.y = sp48 + arg2;

    if (arg4 != 0) {
        sp60.y -= func_80045714(&camera->unk_108, camera->playerPosRot.rot.y, arg1->theta, OREG(9));
    }

    Camera_LERPCeilVec3f(&sp60, &camera->posOffset, camera->yOffsetUpdateRate, camera->xzOffsetUpdateRate, 0.1f);

    sp54.x = camera->posOffset.x + sp30.pos.x;
    sp54.y = camera->posOffset.y + sp30.pos.y;
    sp54.z = camera->posOffset.z + sp30.pos.z;
    Camera_LERPCeilVec3f(&sp54, &camera->at, camera->atLERPStepScale, camera->atLERPStepScale, 0.2f);

    return 1;
}

f32 func_800468CC(Camera* camera, f32 arg1, f32 arg2, f32 arg3) {
    f32 sp1C;
    f32 phi_f12;

    if (arg1 < arg2) {
        sp1C = arg2;
        phi_f12 = OREG(6);
    } else if (arg3 < arg1) {
        sp1C = arg3;
        phi_f12 = OREG(6);
    } else {
        sp1C = arg1;
        phi_f12 = 1.0f;
    }

    camera->rUpdateRateInv = Camera_LERPCeilF(phi_f12, camera->rUpdateRateInv, OREG(25) * 0.01f, 0.1f);
    return Camera_LERPCeilF(sp1C, camera->dist, 1.f / camera->rUpdateRateInv, 0.2f);
}

f32 func_800469C0(Camera* camera, f32 arg1, f32 arg2, f32 arg3, s16 arg4) {
    f32 sp1C;
    f32 phi_f12;

    if (arg1 < arg2) {
        sp1C = arg2;

        if (arg4 != 0) {
            phi_f12 = OREG(6) * 0.5f;
        } else {
            phi_f12 = OREG(6);
        }
    } else if (arg3 < arg1) {
        sp1C = arg3;

        if (arg4 != 0) {
            phi_f12 = OREG(6) * 0.5f;
        } else {
            phi_f12 = OREG(6);
        }
    } else {
        sp1C = arg1;

        if (arg4 != 0) {
            phi_f12 = OREG(6);
        } else {
            phi_f12 = 1.0f;
        }
    }

    camera->rUpdateRateInv = Camera_LERPCeilF(phi_f12, camera->rUpdateRateInv, OREG(25) * 0.01f, 0.1f);
    return Camera_LERPCeilF(sp1C, camera->dist, 1.f / camera->rUpdateRateInv, 0.2f);
}

#ifdef NON_MATCHING
// lots of regalloc and stack issues, but that's it
s16 func_80046B44(Camera* camera, s16 arg1, s16 arg2, s16 arg3) {
    s32 pad[2];
    s16 sp1C;
    s16 phi_v1;
    s16 phi_v0;
    f32 phi_a2;

    phi_v1 = ABS(arg1);
    phi_v0 = arg3 > 0 ? (s16)(Math_Coss(arg3) * arg3) : arg3;
    sp1C = arg2 - phi_v0;
    if (ABS(sp1C) < phi_v1) {
        phi_a2 = (1.0f / camera->phiUpdateRateInv) * 3.0f;
    } else {
        phi_a2 = (1.0f / camera->phiUpdateRateInv) * func_800437F0(0.8f, 1.0f - phi_v0 * (1.0f / R_CAM_MAX_PHI));
    }
    return Camera_LERPCeilS(sp1C, arg1, phi_a2, 0xA);
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80046B44.s")
#endif

#ifdef NON_MATCHING
// stack, regalloc, tiny bit of ordering
s16 func_80046CB4(Camera* camera, s16 arg1, s16 arg2, f32 arg3, f32 arg4) {
    f32 sp34;
    s16 sp1C;
    f32 temp_ret;
    f32 phi_f14;
    s16 temp;

    if (camera->unk_D8 > 0.001f) {
        temp = BINANG_ROT180(arg1);
        sp1C = arg2 - temp;
        phi_f14 = BINANG_ROT180(sp1C) * (1.0f / 32767.0f);
    } else {
        temp = BINANG_ROT180(arg1);
        sp1C = arg2 - temp;
        phi_f14 = OREG(48) * 0.01f;
    }
    temp_ret = func_800437F0(arg3, phi_f14);
    
    sp34 = ((1.0f - temp_ret) * arg4) + temp_ret;
    if (sp34 < 0.0f) {
        sp34 = 0.0f;
    }
    
    // This is probably some binary angle calculation.
    return arg1 + (s16)(sp1C * sp34 * sp1C * (1.0f / camera->thetaUpdateRateInv) * func_800437F0(0.5f, camera->unk_E0)) + arg1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80046CB4.s")
#endif

void func_80046E20(Camera *arg0, VecSph *arg1, f32 arg2, f32 arg3, f32 *arg4, Vec3f *arg5);
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80046E20.s")

s32 Camera_NOP(Camera* camera) {
    return true;
}

#ifdef NON_MATCHING
s32 Camera_Normal1(Camera *camera) {
    f32 spA0;
    f32 sp9C;
    f32 sp98;
    f32 sp94;
    Vec3f sp88;
    VecSph sp7C;
    VecSph sp74;
    VecSph sp6C;
    Vec3f *sp40;
    Vec3f *sp3C;
    Vec3f *sp38;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f0_6;
    f32 temp_f0_7;
    f32 temp_f12;
    f32 temp_f16;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    s16 temp_t5;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s16 temp_v0_4;
    s16 phi_v1;
    f32 phi_f2;
    f32 phi_f2_2;
    f32 phi_f16;
    s32 phi_v1_2;
    s32 phi_v1_3;
    s32 phi_v0;
    f32 phi_f16_2;
    s32 phi_v1_4;
    Normal1* norm1 = &camera->params.norm1;
    Normal1_Unk24* unk24 = &norm1->unk_24;
    CameraModeValue* values;

    temp_f0 = Player_GetCameraYOffset(camera->player);
    if(RELOAD_PARAMS){
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        temp_f2 = (temp_f0 * 0.01f) * ((1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / temp_f0)));
        norm1->unk_00 = (f32) ((f32) NEXTSETTING * temp_f2);
        norm1->unk_04 = (f32) ((f32) NEXTSETTING * temp_f2);
        norm1->unk_08 = (f32) ((f32) NEXTSETTING * temp_f2);
        norm1->unk_20 = (s16) (s32) (((f32) NEXTSETTING * (65535.0f / 360.0f)) + 0.5f);
        norm1->unk_0C = (f32) NEXTSETTING;
        norm1->unk_10 = (f32) NEXTSETTING;
        norm1->unk_14 = (f32) ((f32) NEXTSETTING * 0.01f);
        norm1->unk_18 = (f32) NEXTSETTING;
        norm1->unk_1C = (f32) ((f32) NEXTSETTING * 0.01f);
        norm1->unk_22 = (s16) NEXTSETTING;
    }
    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    sp40 = &camera->eye;
    sp3C = &camera->at;
    sCameraInterfaceFlags = norm1->unk_22;
    OLib_Vec3fDiffToVecSphRot90(&sp74, &camera->at, &camera->eye);
    sp38 = &camera->eyeNext;
    OLib_Vec3fDiffToVecSphRot90(&sp6C, &camera->at, &camera->eyeNext);
    switch(camera->animState){
        case 0x14:
            camera->thetaUpdateRateInv = (f32) OREG(27);
            camera->phiUpdateRateInv = (f32) OREG(27);
        case 0:
        case 0xA:
        case 0x19:
            unk24->unk_18 = 0;
            unk24->unk_0C = 0;
            unk24->unk_24 = 0;
            unk24->unk_28 = 0xA;
            unk24->unk_14 = unk24->unk_18;
            unk24->unk_16 = unk24->unk_18;
            unk24->unk_10 = norm1->unk_0C;
            unk24->unk_1C = camera->playerPosRot.pos.y;
            unk24->unk_20 = camera->unk_D8;
            unk24->unk_1A = 0;
            unk24->unk_26 = sp74.theta;
            sUpdateCameraDirection = 0;
            unk24->unk_2A = OREG(51) + OREG(50);
            break;
        default:
        break;
    }
    camera->animState = 1;
    sUpdateCameraDirection = 1;
    if (unk24->unk_28 != 0) {
        unk24->unk_28--;
    }
    if (camera->unk_D8 > 0.001f) {
        unk24->unk_2A = (s16) (OREG(51) + OREG(50));
    } else if (unk24->unk_2A > 0) {
        if (unk24->unk_2A > OREG(50)) {
            unk24->unk_26 = sp74.theta + ((s16)((s16)(camera->playerPosRot.rot.y - 0x7FFF) - sp74.theta) / unk24->unk_2A);
        }
        unk24->unk_2A--;
    }
    temp_f16 = (OREG(25) * 0.01f) * camera->unk_E0;
    sp9C = ((f32) OREG(26) * 0.01f) * camera->unk_E0;
    if (unk24->unk_18 != 0) {
        sp98 = (OREG(25) * 0.01f);
    } else {
        sp98 = temp_f16;
    }
    temp_f2_3 = (camera->unk_D8 - unk24->unk_20) * (1.0f / 3.0f);
    phi_f2 = temp_f2_3;
    if (1.0f < temp_f2_3) {
        phi_f2 = 1.0f;
    }
    phi_f2_2 = phi_f2;
    if (-1.0f < phi_f2) {
        phi_f2_2 = -1.0f;
    }
    unk24->unk_20 = camera->unk_D8;
    if (unk24->unk_1A != 0) {
        spA0 = temp_f16;
        sp94 = phi_f2_2;
        camera->thetaUpdateRateInv = Camera_LERPCeilF(unk24->unk_10 + (f32) (unk24->unk_1A * 2), camera->thetaUpdateRateInv, sp98, 0.1f);
        camera->phiUpdateRateInv = Camera_LERPCeilF((f32) OREG(7) + (f32) (unk24->unk_1A * 2), camera->phiUpdateRateInv, sp9C, 0.1f);
        unk24->unk_1A--;
    } else {
        temp_f0_2 = unk24->unk_10;
        spA0 = temp_f16;
        sp94 = phi_f2_2;
        camera->thetaUpdateRateInv = Camera_LERPCeilF(temp_f0_2 - ((((f32) OREG(49) * 0.01f) * temp_f0_2) * phi_f2_2), camera->thetaUpdateRateInv, sp98, 0.1f);
        camera->phiUpdateRateInv = Camera_LERPCeilF(OREG(7), camera->phiUpdateRateInv, sp9C, 0.1f);
    }
    spA0 = temp_f2_2 * camera->unk_E0;
    camera->phiUpdateRateInv = Camera_LERPCeilF(OREG(7), camera->phiUpdateRateInv, sp9C, 0.1f);
    camera->xzOffsetUpdateRate = Camera_LERPCeilF(OREG(2) * 0.01f, camera->xzOffsetUpdateRate, temp_f2_2 * camera->unk_E0, 0.1f);
    camera->yOffsetUpdateRate = Camera_LERPCeilF(OREG(2) * 0.01f, camera->yOffsetUpdateRate, sp9C, 0.1f);
    camera->fovUpdateRate = Camera_LERPCeilF(OREG(3) * 0.01f, camera->yOffsetUpdateRate, camera->unk_E0 * 0.05f, 0.1f);
    if (norm1->unk_22 & 1) {
        s16 t = func_80044ADC(camera, sp74.theta - 0x7FFF, 0);
        temp_f0_4 = (1.0f / norm1->unk_10) * 0.5f;
        unk24->unk_24 = Camera_LERPCeilS(t, unk24->unk_24, temp_f0_4 + (temp_f0_4 * (1.0f - camera->unk_E0)), 0xF);
    } else {
        unk24->unk_24 = (u16)0;
        if (camera->playerPosRot.pos.y == camera->unk_104) {
            unk24->unk_1C = camera->playerPosRot.pos.y;
        }
    }
    if ((unk24->unk_18 != 0) && (norm1->unk_00 > -40.0f)) {
        temp_f0_5 = Math_Sins(unk24->unk_14);
        phi_f16 = (-40.0f * temp_f0_5) + (norm1->unk_00 * (1.0f - temp_f0_5));
    } else {
        phi_f16 = norm1->unk_00;
    }
    if (norm1->unk_22 & 0x80) {
        func_800458D4(camera, &sp6C, phi_f16, &norm1->unk_24 + 0x1C, norm1->unk_22 & 1);
    } else {
        if (norm1->unk_22 & 0x20) {
            func_80045B08(camera, &sp6C, phi_f16, unk24->unk_24);
        } else {
            func_800457A8(camera, &sp6C, phi_f16, norm1->unk_22 & 1);
        }
    }
    OLib_Vec3fDiffToVecSphRot90(&sp7C, sp3C, sp38);
    sp7C.r = func_800469C0(camera, sp7C.r, norm1->unk_04, norm1->unk_08, unk24->unk_28);
    camera->dist = sp7C.r;
    if (unk24->unk_2A <= 0) {
        sp7C.phi = sp6C.phi;
        sp7C.theta = Camera_LERPCeilS(unk24->unk_26, sp6C.theta, 1.0f / camera->thetaUpdateRateInv, 0xA);
    } else if (unk24->unk_18 != 0) {
        sp7C.theta = Camera_LERPCeilS(unk24->unk_16, sp6C.theta, 1.0f / camera->thetaUpdateRateInv, 0xA);
        sp7C.phi = Camera_LERPCeilS(unk24->unk_14, sp6C.phi, 1.0f / camera->thetaUpdateRateInv, 0xA);
    } else {
        sp7C.theta = func_80046CB4(camera, sp6C.theta, camera->playerPosRot.rot.y, norm1->unk_14, sp94);
        sp7C.phi = func_80046B44(camera, sp6C.phi, norm1->unk_20, unk24->unk_24);
    }
    if (sp7C.phi >= 0x38A5) {
        sp7C.phi = 0x38A4;
    }
    if (sp7C.phi < -0x3C8C) {
        sp7C.phi = -0x3C8C;
    }
    Camera_Vec3fVecSphAdd(sp38, sp3C, &sp7C);
    if ((camera->status == 7) &&  (!(norm1->unk_22 & 0x10))) {
        unk24->unk_26 = camera->playerPosRot.rot.y - 0x7FFF;
        if (unk24->unk_2A > 0) {
            func_80046E20(camera, &sp7C, norm1->unk_04, norm1->unk_0C, &sp98, &unk24->unk_00);
        } else {
            sp88 = *sp38;
            temp_f0_7 = norm1->unk_0C + norm1->unk_0C;
            camera->thetaUpdateRateInv = temp_f0_7;
            unk24->unk_10 = temp_f0_7;
            if (func_80043F34(camera, sp3C, &sp88)) {
                unk24->unk_2A = -1;
                unk24->unk_26 = sp6C.theta;
            } else {
                *sp40 = *sp38;
            }
            unk24->unk_18 = 0;
        }
        if (unk24->unk_18 != 0) {
            camera->direction.y = Camera_LERPCeilS(camera->direction.y + ((unk24->unk_16 - 0x7FFF) - camera->direction.y), camera->direction.y, 1.0f - (0.99f * sp98), 0xA);
        }
        if (norm1->unk_22 & 4) {
            camera->direction.x = -sp74.phi;
            camera->direction.z = 0;
            camera->direction.y = sp74.theta - 0x7FFF;
        } else {
            OLib_Vec3fDiffToVecSphRot90(&sp7C, sp40, sp3C);
            camera->direction.x = sp7C.phi;
            camera->direction.z = 0;
            camera->direction.y = sp7C.theta;
        }
        // crit wiggle
        if (gSaveContext.health <= 0x10 && ((camera->globalCtx->state.frames & 0xFF) == 0)) {
            camera->direction.y += Math_Rand_ZeroOne() * 10000.0f;
        }
    } else {
        unk24->unk_18 = (u16)0;
        unk24->unk_10 = (f32) norm1->unk_0C;
        sUpdateCameraDirection = 0;
        *sp40 = *sp38;
    }
    camera->fov = Camera_LERPCeilF(norm1->unk_18 * (gSaveContext.health <= 0x10 ? 0.8f : 1.0f), camera->fov, camera->fovUpdateRate, 1.0f);
    camera->roll = Camera_LERPCeilS(0, camera->roll, 0.5f, 0xA);
    camera->atLERPStepScale = func_800450A4(camera, norm1->unk_1C);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Normal1.s")
#endif


#ifdef NON_MATCHING
s32 Camera_Normal2(Camera *camera) {
    struct_80043D18 spAC;
    f32 spA4;
    f32 spA0;
    VecSph sp98;
    VecSph sp90;
    VecSph sp88;
    VecSph sp80;
    VecSph sp78;
    Vec3f *sp48;
    Vec3f *sp44;
    Vec3f *sp40;
    CamPosData *temp_v0_2;
    Normal2_20 *temp_s1;
    f32 temp_f14;
    f32 temp_ret;
    s16 temp_t5;
    s32 temp_v1;
    s32 temp_v1_2;
    s16 phi_v1;
    s32 phi_a1;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v1_2;
    s32 phi_a0;
    s32 phi_v1_3;
    CameraModeValue* values;
    PosRot* playerPosRot;

    temp_ret = Player_GetCameraYOffset(camera->player);
    temp_f14 = (1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / temp_ret));
    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    if(RELOAD_PARAMS){
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        camera->params.normal2.unk_00.x = NEXTSETTING * 0.01f * temp_ret * temp_f14;
        camera->params.normal2.unk_00.y = NEXTSETTING * 0.01f * temp_ret * temp_f14;
        camera->params.normal2.unk_00.z = NEXTSETTING * 0.01f * temp_ret * temp_f14;
        camera->params.normal2.unk_1C = (NEXTSETTING * (65535.0f / 360.0f)) + 0.5f;
        camera->params.normal2.unk_0C = NEXTSETTING;
        camera->params.normal2.unk_10 = NEXTSETTING * 0.01f;
        camera->params.normal2.unk_14 = NEXTSETTING;
        camera->params.normal2.unk_18 = NEXTSETTING * 0.01f;
        camera->params.normal2.unk_1E = NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }

    sCameraInterfaceFlags = camera->params.normal2.unk_1E;
    temp_s1 = &camera->params.normal2.unk_20;
    playerPosRot = &camera->playerPosRot;
    if(RELOAD_PARAMS){
        temp_v0_2 = func_8004476C(camera);
        Camera_Vec3sToVec3f(&temp_s1->unk_00, &temp_v0_2->pos);
        temp_s1->unk_20 = temp_v0_2->rot.x;
        temp_s1->unk_22 = temp_v0_2->rot.y;

        temp_s1->unk_24 = playerPosRot->pos.y;

        temp_s1->unk_1C = temp_v0_2->fov == -1 ? camera->params.normal2.unk_14 :
            temp_v0_2->fov >= 0x169 ? temp_v0_2->fov * 0.01f : temp_v0_2->fov;

        temp_s1->unk_28 = temp_v0_2->jfifId == -1 ? 0 : temp_v0_2->jfifId;
        temp_s1->unk_18 = 0.0f;

        if (camera->params.normal2.unk_1E & 4) {
            sp88.r = 100.0f;
            sp88.phi = temp_s1->unk_20;
            sp88.theta = temp_s1->unk_22 + 0x3FFF;
            OLib_VecSphRot90ToVec3f(&temp_s1->unk_0C, &sp88);
        }
        camera->animState = 1;
        camera->thetaUpdateRateInv = 50.0f;
    } else if (playerPosRot->pos.y == camera->unk_104) {
        camera->params.normal2.unk_20.unk_24 = playerPosRot->pos.y;
    }

    sp48 = &camera->eye;
    sp44 = &camera->at;
    sp40 = &camera->eyeNext;
    OLib_Vec3fDiffToVecSphRot90(&sp80, &camera->at, &camera->eye);

    OLib_Vec3fDiffToVecSphRot90(&sp78, &camera->at, &camera->eyeNext);
    camera->unk_E0 *= 0.5f;
    spA4 = OREG(25) * camera->unk_E0;
    spA0 = OREG(26) * 0.01f * camera->unk_E0;
    camera->thetaUpdateRateInv = Camera_LERPCeilF(camera->params.normal2.unk_0C, camera->thetaUpdateRateInv * camera->unk_E0, OREG(25), 0.1f);
    camera->phiUpdateRateInv = Camera_LERPCeilF(OREG(7), camera->phiUpdateRateInv, spA0, 0.1f);
    camera->xzOffsetUpdateRate = Camera_LERPCeilF(OREG(2) * 0.1f, camera->xzOffsetUpdateRate, spA4, 0.1f);
    camera->yOffsetUpdateRate = Camera_LERPCeilF(OREG(3) * 0.01f, camera->yOffsetUpdateRate, spA0, 0.1f);
    camera->fovUpdateRate = Camera_LERPCeilF(OREG(4) * 0.01f, camera->yOffsetUpdateRate, camera->unk_E0 * 0.05f, 0.1f);
    if (!(camera->params.normal2.unk_1E & 0x80)) {
        func_800457A8(camera, &sp78, camera->params.normal2.unk_00.x, camera->params.normal2.unk_1E & 1);
    } else {
        func_800458D4(camera, &sp78, camera->params.normal2.unk_00.x, &temp_s1->unk_24, camera->params.normal2.unk_1E & 1);
    }
    if (camera->params.normal2.unk_1E & 4) {
        temp_s1->unk_00.x = playerPosRot->pos.x + temp_s1->unk_0C.x;
        temp_s1->unk_00.z = playerPosRot->pos.z + temp_s1->unk_0C.z;
    }
    temp_s1->unk_00.y = playerPosRot->pos.y;
    OLib_Vec3fDiffToVecSphRot90(&sp88, &temp_s1->unk_00, sp44);
    OLib_Vec3fDiffToVecSphRot90(&sp90, sp44, sp40);

    phi_a1 = temp_s1->unk_28 & 2 ? temp_s1->unk_22 : camera->params.normal2.unk_1C;

    if (phi_a1 < 0x4000) {
        phi_v0 = ABS(sp90.theta - sp88.theta);
        temp_v1 = sp90.theta - sp88.theta;
        phi_v0 = -temp_v1;
        if (temp_v1 >= 0) {
            phi_v0 = temp_v1;
        }
        phi_v0 = ABS(sp90.theta - sp88.theta);
        phi_v1_2 = temp_v1;
        if (phi_a1 >= phi_v0) {
block_39:
            if (phi_a1 >= 0x4000) {
                temp_v1_2 = sp90.theta - sp88.theta;
                phi_v0_2 = -temp_v1_2;
                if (temp_v1_2 >= 0) {
                    phi_v0_2 = temp_v1_2;
                }
                phi_v1_2 = temp_v1_2;
                if (phi_v0_2 < phi_a1) {
block_43:
                    if (phi_v1_2 < 0) {
                        phi_a0 = -phi_a1;
                    } else {
                        phi_a0 = phi_a1;
                    }
                    sp98.theta = Camera_LERPCeilS(phi_a0 + sp88.theta, sp80.theta, (1.0f / camera->thetaUpdateRateInv) * camera->unk_E0, 0xA);
                    if (temp_s1->unk_28 & 1) {
                        sp98.phi = func_80046B44(camera, sp78.phi, temp_s1->unk_20, 0);
                    } else {
                        sp98.phi = sp80.phi;
                    }
                } else {
block_49:
                    sp98 = sp90;
                }
            } else {
                goto block_49;
            }
        } else {
            goto block_43;
        }
    } else {
        goto block_39;
    }
    camera->dist = sp98.r = func_800469C0(camera, sp90.r, camera->params.normal2.unk_00.y, camera->params.normal2.unk_00.z, 0);

    if (temp_s1->unk_28 & 1) {
        phi_v1_3 = sp98.phi;
        if (sp98.phi >= 0xE39) {
            phi_v1_3 = sp98.phi + ((0xE38 - sp98.phi) / 4);
        }
        sp98.phi = phi_v1_3;
        if (phi_v1_3 < 0) {
            sp98.phi = phi_v1_3 + ((-0x38E - phi_v1_3) / 4);
        }
    }
    Camera_Vec3fVecSphAdd(sp40, sp44, &sp98);
    if (camera->status == 7) {
        spAC.unk_00 = *sp40;
        if (camera->globalCtx->envCtx.skyDisabled != 0) {
            if (camera->params.normal2.unk_1E & 0x10) {
block_58:
                func_80043D18(camera, sp44, &spAC);
                *sp48 = spAC.unk_00;
            } else {
                func_80043F94(camera, sp44, &spAC);
                *sp48 = spAC.unk_00;
                OLib_Vec3fDiffToVecSphRot90(&sp98, sp48, sp44);
                camera->direction.x = sp98.phi;
                camera->direction.z = 0;
                camera->direction.y = sp98.theta;
            }
        } else {
            goto block_58;
        }
    }
    camera->fov = Camera_LERPCeilF(temp_s1->unk_1C, camera->fov, camera->fovUpdateRate, 1.0f);
    camera->roll = Camera_LERPCeilS(0, camera->roll, 0.5f, 0xA);
    camera->atLERPStepScale = func_800450A4(camera, camera->params.normal2.unk_18);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Normal2.s")
#endif

#ifdef NON_MATCHING
s32 Camera_Normal3(Camera* camera) {
    f32 sp98;
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    VecSph sp84;
    VecSph sp7C;
    VecSph sp74;
    Vec3f* sp48;
    Vec3f* sp44;
    Vec3f* sp40;
    f32 temp_f0;
    f32 temp_f0_3;
    f32 temp_f16;
    f32 temp_f16_2;
    f32 temp_f2;
    f32 temp_f6;
    s16 temp_t3;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s16 temp_v0_4;
    s32 temp_a0;
    s16 phi_v1;
    s32 phi_v1_2;
    s32 phi_a0;
    CameraModeValue* values;
    Normal3* normal3 = &camera->params.normal3;
    Normal3_Unk20* unk20;
    PosRot* playerPostRot;

    temp_f2 = Player_GetCameraYOffset(camera->player);
    if ((((camera->animState == 0) || (camera->animState == 0xA)) || (camera->animState == 0x14)) || R_RELOAD_CAM_PARAMS) {
        temp_f2 *= 0.01f;
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        // temp_t2 = sCameraSettings[camera->setting].unk_00 + (camera->mode * 8);
        // temp_t3 = *temp_t2->unk4;
        // temp_v0 = temp_t2->unk4 + 0x20;
        normal3->unk_00 = temp_f2 * NEXTSETTING;
        // normal3->unk_00 = (f32) ((f32) temp_t3 * temp_f2);

        normal3->unk_04 = temp_f2 * NEXTSETTING;
        // normal3->unk_04 = (f32) ((f32) temp_v0->unk-1C * temp_f2);

        normal3->unk_08 = temp_f2 * NEXTSETTING;
        // normal3->unk_08 = (f32) ((f32) temp_v0->unk-18 * temp_f2);

        normal3->unk_1C = (65535.0f / 360.0f) * NEXTSETTING + 0.5f;
        // normal3->unk_1C = (s16) (s32) (((f32) temp_v0->unk-14 * (65535.0f / 360.0f)) + 0.5f);

        normal3->unk_0C = NEXTSETTING;
        // normal3->unk_0C = (f32) temp_v0->unk-10;

        normal3->unk_10 = NEXTSETTING;
        // normal3->unk_10 = (f32) temp_v0->unk-C;

        normal3->unk_14 = NEXTSETTING;
        // normal3->unk_14 = (f32) temp_v0->unk-8;

        normal3->unk_18 = NEXTSETTING * 0.01f;
        // normal3->unk_18 = (f32) ((f32) temp_v0->unk-4 * 0.01f);

        normal3->unk_1E = NEXTSETTING;
        // normal3->unk_1E = (s16) temp_v0->unk0;
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }

    sp48 = &camera->eye;
    sp44 = &camera->at;
    sp40 = &camera->eyeNext;
    playerPostRot = &camera->playerPosRot;
    OLib_Vec3fDiffToVecSphRot90(&sp7C, sp44, sp48);
    OLib_Vec3fDiffToVecSphRot90(&sp74, sp44, sp40);
    sUpdateCameraDirection = 1;
    sCameraInterfaceFlags = normal3->unk_1E;
    unk20 = &normal3->unk_20;

    // ordering here.
    switch (camera->animState) {
        case 0:
        case 0xA:
        case 0x14:
        case 0x19:
            unk20->unk_0C = 0;
            unk20->unk_24 = 0;
            unk20->unk_1C = 0;
            unk20->unk_14 = unk20->unk_16 = unk20->unk_18 = 0;
            // unk20->unk_14 = (s16) unk20->unk_18;
            // unk20->unk_16 = (s16) unk20->unk_18;

            unk20->unk_20 = camera->unk_104;
            unk20->unk_10 = normal3->unk_0C;
            unk20->unk_2A = 0xA;
            unk20->unk_26 = (1.0f / R_DEFA_CAM_ANIM_TIME) * (s16)(playerPostRot->rot.y - 0x7FFF - sp7C.theta);
            unk20->unk_28 = R_DEFA_CAM_ANIM_TIME;
            camera->animState = 1;
            unk20->unk_1A = 0;
            break;
        default:
            break;
    }
    DECR(unk20->unk_2A);
    /*temp_v0_2 = unk20->unk_2A;
    if (temp_v0_2 != 0) {
        unk20->unk_2A = (s16) (temp_v0_2 - 1);
    }
    */
    temp_f6 = OREG(25) * 0.01f;
    temp_f16 = temp_f6 * camera->unk_E0;
    sp94 = (OREG(26) * 0.01f) * camera->unk_E0;
    temp_v0_3 = unk20->unk_1A;
    if (temp_v0_3 != 0) {
        camera->thetaUpdateRateInv = Camera_LERPCeilF(normal3->unk_0C + (temp_v0_3 * 2), camera->thetaUpdateRateInv, temp_f16, 0.1f);
        camera->phiUpdateRateInv = Camera_LERPCeilF((f32)OREG(7) + (unk20->unk_1A * 2), camera->phiUpdateRateInv, sp94, 0.1f);
        unk20->unk_1A--;
    } else {
        camera->thetaUpdateRateInv = Camera_LERPCeilF(normal3->unk_0C, camera->thetaUpdateRateInv, temp_f16, 0.1f);
        camera->phiUpdateRateInv = Camera_LERPCeilF(OREG(7), camera->phiUpdateRateInv, sp94, 0.1f);
    }
    camera->xzOffsetUpdateRate = Camera_LERPCeilF(OREG(2) * 0.01f, camera->xzOffsetUpdateRate, temp_f16, 0.1f);
    camera->yOffsetUpdateRate = Camera_LERPCeilF(OREG(3) * 0.01f, camera->yOffsetUpdateRate, sp94, 0.1f);
    camera->fovUpdateRate = Camera_LERPCeilF(OREG(4) * 0.01f, camera->fovUpdateRate, sp94, 0.1f);
    temp_f0 = (1.0f / normal3->unk_10) * 0.5f;
    unk20->unk_24 = Camera_LERPCeilS(func_80044ADC(camera, sp7C.theta - 0x7FFF, 1), unk20->unk_24,
                                  temp_f0 + (temp_f0 * (1.0f - camera->unk_E0)), 0xF);
    func_800466F8(camera, &sp74, normal3->unk_00, &unk20->unk_20, 1);
    sp90 = (normal3->unk_08 + normal3->unk_04) * 0.5f;
    OLib_Vec3fDiffToVecSphRot90(&sp84, sp44, sp40);
    sp84.r = func_800469C0(camera, sp84.r, normal3->unk_04, normal3->unk_08, unk20->unk_2A);
    camera->dist = sp84.r;
    if (0.001f < camera->unk_D8) {
        sp84.r += (sp90 - sp84.r) * 0.002f;
    }
    sp84.phi = Camera_LERPCeilS(normal3->unk_1C - unk20->unk_24, sp74.phi, 1.0f / camera->phiUpdateRateInv, 0xA);
    if (R_CAM_MAX_PHI < sp84.phi) {
        sp84.phi = R_CAM_MAX_PHI;
    }
    if (sp84.phi < R_CAM_MIN_PHI) {
        sp84.phi = R_CAM_MIN_PHI;
    }

    // Probably some type of abs/clamp.
    temp_a0 = playerPostRot->rot.y - (sp74.theta - 0x7FFF);
    phi_v1_2 = -temp_a0;
    if (temp_a0 >= 0) {
        phi_v1_2 = temp_a0;
    }
    phi_a0 = temp_a0;
    if (phi_v1_2 >= 0x2AF9) {
        if (temp_a0 > 0) {
            phi_a0 = 0x2AF8;
        } else {
            phi_a0 = -0x2AF8;
        }
    }
    temp_f16_2 = (phi_a0 * ((camera->unk_E0 * (1.0f - 0.5f)) + 0.5f)) / camera->thetaUpdateRateInv;
    if ((150.0f * (1.0f - camera->unk_E0)) < fabsf(temp_f16_2)) {
        sp84.theta = sp74.theta + temp_f16_2;
        // sp8A = sp74.theta + temp_f16_2;
    } else {
        sp84.theta = sp74.theta;
        // sp8A = sp7A;
    }
    if (unk20->unk_28 > 0) {
        sp84.theta += unk20->unk_26;
        // sp8A = sp8A + unk20->unk_26;

        unk20->unk_28--;
    }
    Camera_Vec3fVecSphAdd(sp40, sp44, &sp84);
    if (camera->status == 7) {
        func_80046E20(camera, &sp84, normal3->unk_04, normal3->unk_0C, &sp8C, &normal3->unk_20);
    } else {
        *sp48 = *sp40;
    }
    camera->fov = Camera_LERPCeilF(normal3->unk_14, camera->fov, camera->fovUpdateRate, 1.0f);
    camera->roll = Camera_LERPCeilS(0, camera->roll, 0.5f, 0xA);
    camera->atLERPStepScale = func_800450A4(camera, normal3->unk_18);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Normal3.s")
#endif

s32 Camera_Normal4(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Normal0(Camera* camera) {
    return Camera_NOP(camera);
}

#define Rot180Deg(x) ((s16)((s16)x - (s16)0x7FFF))
#define SETTINGPCT (NEXTSETTING * 0.01f)
#define SETTINGANGLE ((NEXTSETTING * (65535.0f / 360.0f)) + x)

#ifdef NON_MATCHING
void Camera_Parallel1(Camera *camera) {
    f32 spB8;
    f32 spB4;
    VecSph spA8;
    VecSph spA0;
    VecSph sp98;
    struct_80043D18 sp6C;
    s16 sp6A;
    Vec3f *sp3C;
    Parallel1Anim *sp34 = &camera->params.para1.anim;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f12;
    f32 temp_f2;
    f32 temp_f2_2;
    s16 temp_a0;
    s16 temp_a0_2;
    s16 temp_t6;
    s16 temp_v0_2;
    s16 phi_v0;
    s16 phi_v0_2;
    s16 phi_a0;
    f32 phi_f0;
    CameraModeValue* values;

    temp_f0 = Player_GetCameraYOffset((Player *) camera->player);
    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        temp_f12 = (1.0f + PCT(OREG(46))) - (PCT(OREG(46)) * (68.0f / temp_f0));
        camera->params.para1.unk_00 = (f32) ((PCT(NEXTSETTING) * temp_f0) * temp_f12);
        camera->params.para1.distTarget = (f32) ((PCT(NEXTSETTING) * temp_f0) * temp_f12);
        camera->params.para1.phiTarget = DEGF_TO_BINANG(NEXTSETTING);
        camera->params.para1.thetaTarget = DEGF_TO_BINANG(NEXTSETTING);
        camera->params.para1.unk_08 = NEXTSETTING;
        camera->params.para1.unk_0C = NEXTSETTING;
        camera->params.para1.fovTarget = NEXTSETTING;
        camera->params.para1.unk_14 = PCT(NEXTSETTING);
        camera->params.para1.interfaceFlags = NEXTSETTING;
        camera->params.para1.unk_18 = (f32) ((PCT(NEXTSETTING) * temp_f0) * temp_f12);
        camera->params.para1.unk_1C = PCT(NEXTSETTING);
    }
    if (R_RELOAD_CAM_PARAMS != 0) {
        Camera_CopyPREGToModeValues(camera);
    }

    OLib_Vec3fDiffToVecSphRot90(&spA0, &camera->at, &camera->eye);
    OLib_Vec3fDiffToVecSphRot90(&sp98, &camera->at, &camera->eyeNext);
    switch(camera->animState){
        case 0:
        case 0xA:
        case 0x14:
        case 0x19:
            sp34->unk_16 = 0;
            sp34->unk_10 = 0;
            if (camera->params.para1.interfaceFlags & 4) {
                sp34->animTimer = 0x14;
            } else {
                sp34->animTimer = OREG(23);
            }
            sp34->unk_00.x = 0.0f;
            sp34->yTarget = camera->playerPosRot.pos.y - camera->playerPosDelta.y;
            camera->animState++;
    }

    if (sp34->animTimer != 0) {
        if (camera->params.para1.interfaceFlags & 2) {
            sp34->thetaTarget = BINANG_ROT180(camera->playerPosRot.rot.y) + camera->params.para1.thetaTarget;
        } else if (camera->params.para1.interfaceFlags & 4) {
            sp34->thetaTarget = camera->params.para1.thetaTarget;
        } else {
            sp34->thetaTarget = sp98.theta;
        }
    } else {
        if ((camera->params.para1.interfaceFlags & 0x20) != 0) {
            sp34->thetaTarget = BINANG_ROT180(camera->playerPosRot.rot.y) + camera->params.para1.thetaTarget;
        }
        sCameraInterfaceFlags = camera->params.para1.interfaceFlags;
    }
    
    sp34->phiTarget = camera->params.para1.phiTarget;
    if(camera->animState == 0x15){
        sp34->unk_16 = 1;
        camera->animState = 1;
    } else if(camera->animState == 0xB){
        camera->animState = 1;
    }
    spB8 = PCT(OREG(25)) * camera->unk_E0;
    spB4 = PCT(OREG(26)) * camera->unk_E0;
    camera->rUpdateRateInv = Camera_LERPCeilF(OREG(6), camera->rUpdateRateInv, spB8, 0.1f);
    camera->thetaUpdateRateInv = Camera_LERPCeilF(camera->params.para1.unk_08, camera->thetaUpdateRateInv, spB8, 0.1f);
    camera->phiUpdateRateInv = Camera_LERPCeilF(2.0f, camera->phiUpdateRateInv, spB4, 0.1f);
    camera->xzOffsetUpdateRate = Camera_LERPCeilF(OREG(2) * 0.01f, camera->xzOffsetUpdateRate, spB8, 0.1f);
    camera->yOffsetUpdateRate = Camera_LERPCeilF(OREG(3) * 0.01f, camera->yOffsetUpdateRate, spB4, 0.1f);
    camera->fovUpdateRate = Camera_LERPCeilF(OREG(4) * 0.01f, camera->fovUpdateRate, camera->unk_E0 * 0.05f, 0.1f);
    if (camera->params.para1.interfaceFlags & 1) {
        temp_f0_2 = 1.0f / camera->params.para1.unk_0C;
        sp34->unk_10 = Camera_LERPCeilS(func_80044ADC(camera, BINANG_ROT180(spA0.theta), 1), sp34->unk_10, (temp_f0_2 * 0.3f) + ((temp_f0_2 * 0.7f) * (1.0f - camera->unk_E0)), 0xF);
    } else {
        sp34->unk_10 = (u16)0;
    }

    if (camera->playerPosRot.pos.y == camera->unk_104 || -0.1f < camera->player->actor.gravity || camera->player->stateFlags1 & 0x200000) {
        sp34->yTarget = (f32) camera->playerPosRot.pos.y;
        sp6A = (u16)0;
    } else {
        sp6A = (u16)1;
    }
    if (((camera->params.para1.interfaceFlags & 0x80) == 0) && (sp6A == 0)) {
        func_80045C74(camera, &sp98, camera->params.para1.unk_00, &sp34->yTarget, camera->params.para1.interfaceFlags & 1);
    } else {
        func_800458D4(camera, &sp98, camera->params.para1.unk_18, &sp34->yTarget, camera->params.para1.interfaceFlags & 1);
    }
    if (sp34->animTimer != 0) {
        
        camera->unk_14C |= 0x20;
        if(1){
            s32 t = (BINANG_SUB(sp34->thetaTarget, spA0.theta) / (s16)(((sp34->animTimer + 1) * sp34->animTimer) >> 1)) * sp34->animTimer;
            spA8.phi = spA0.phi;
            spA8.r = spA0.r;
            spA8.theta = spA0.theta + t;
        }
        sp34->animTimer--;
    } else {
        sp34->unk_16 = 0;
        camera->dist = Camera_LERPCeilF(camera->params.para1.distTarget, camera->dist, 1.0f / camera->rUpdateRateInv, 2.0f);
        OLib_Vec3fDiffToVecSphRot90(&spA8, &camera->at, &camera->eyeNext);
        spA8.r = camera->dist;
        spA8.theta = camera->params.para1.interfaceFlags & 0x40 ?
            Camera_LERPCeilS(sp34->thetaTarget, sp98.theta, 0.6f, 0xA) :
            Camera_LERPCeilS(sp34->thetaTarget, sp98.theta, 0.8f, 0xA);

        spA8.phi = Camera_LERPCeilS(camera->params.para1.interfaceFlags & 1 ? BINANG_SUB(sp34->phiTarget, sp34->unk_10) : sp34->phiTarget, sp98.phi, 1.0f / camera->phiUpdateRateInv, 4);
        spA8.phi = CLAMP(spA8.phi, OREG(34), OREG(5));

        /*if (OREG(5) < spA8.phi) {
            spA8.phi = OREG(5);
        }
        if (spA8.phi < OREG(34)) {
            spA8.phi = OREG(34);
        }*/
    }
    Camera_Vec3fVecSphAdd(&camera->eyeNext, &camera->at, &spA8);
    if (camera->status == 7) {
        sp6C.unk_00 = camera->eyeNext;
        if ((camera->globalCtx->envCtx.skyDisabled == 0) || camera->params.para1.interfaceFlags & 0x10) {
            func_80043D18(camera, &camera->at, &sp6C);
            camera->eye = sp6C.unk_00;
        } else {
            func_80043F94(camera, &camera->at, &sp6C);
            camera->eye = sp6C.unk_00;
            OLib_Vec3fDiffToVecSphRot90(&spA8, &camera->eye, &camera->at);
            camera->direction.x = spA8.phi;
            camera->direction.z = 0;
            camera->direction.y = spA8.theta;
        }
    }
    camera->fov = Camera_LERPCeilF(camera->params.para1.fovTarget, camera->fov, camera->fovUpdateRate, 1.0f);
    camera->roll = Camera_LERPCeilS(0, camera->roll, 0.5f, 0xA);
    if (sp6A != 0) {
        phi_f0 = camera->params.para1.unk_1C;
    } else {
        phi_f0 = camera->params.para1.unk_14;
    }
    camera->atLERPStepScale = func_800450A4(camera, phi_f0);
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Parallel1.s")
#endif

s32 Camera_Parallel2(Camera* camera) {
    return Camera_NOP(camera);
}

void Camera_Parallel3(Camera* camera) {
    CameraModeValue* reg = &sCameraSettings[camera->setting].cameraModes[camera->mode].values[0];
    s16 val = reg->val;

    sCameraInterfaceFlags = val;
    if (val & 1) {
        camera->unk_14C |= 0x400;
    }
    if (val & 2) {
        camera->unk_14C |= 0x10;
    }
}

s32 Camera_Parallel4(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Parallel0(Camera* camera) {
    return Camera_NOP(camera);
}

//#ifdef NON_MATCHING
s32 Camera_Jump1(Camera *camera) {
    s32 pad;
    s32 pad2;
    f32 temp_f2;
    Jump1 *jump1 = &camera->params.jump1;
    f32 spA4;
    Vec3f sp98;
    VecSph sp90;
    VecSph sp88;
    VecSph sp80;
    VecSph sp78;
    f32 temp_f0_2;
    PosRot sp60;
    Vec3f *sp40 = &camera->eye;
    Vec3f *sp3C = &camera->at;
    Vec3f *sp38 = &camera->eyeNext;
    f32 temp_f0;
    CameraModeValue* values;
    s32 t;
    Jump1_Unk20 *unk20 = &jump1->unk_20;

    temp_f0 = Player_GetCameraYOffset(camera->player);
    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        temp_f2 = (1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / temp_f0));
        jump1->unk_00 = (PCT(NEXTSETTING) * temp_f0) * temp_f2;
        jump1->unk_04 = (PCT(NEXTSETTING) * temp_f0) * temp_f2;
        jump1->unk_08 = (PCT(NEXTSETTING) * temp_f0) * temp_f2;
        jump1->unk_0C = NEXTSETTING;
        jump1->unk_10 = PCT(NEXTSETTING);
        jump1->unk_14 = NEXTSETTING;
        jump1->unk_18 = PCT(NEXTSETTING);
        jump1->unk_1C = NEXTSETTING;
    }
    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }

    func_8002EEE4(&sp60, camera->player);
    
    OLib_Vec3fDiffToVecSphRot90(&sp90, sp3C, sp40);
    OLib_Vec3fDiffToVecSphRot90(&sp88, sp3C, sp38);
    sCameraInterfaceFlags = jump1->unk_1C;
    if (camera->animState == 0 || camera->animState == 0xA || camera->animState == 0x14) {
        unk20->unk_16 = unk20->unk_18 = 0;
        unk20->unk_0C = 0;
        unk20->unk_24 = 0;
        unk20->unk_26 = 0xC8;
        unk20->unk_1A = 0;
        unk20->unk_10 = jump1->unk_0C;
        unk20->unk_1C = camera->playerPosRot.pos.y - camera->playerPosDelta.y;
        unk20->unk_20 = sp90.r;
        camera->posOffset.y = camera->posOffset.y - camera->playerPosDelta.y;
        camera->xzOffsetUpdateRate = 9.999999747378752e-05f;
        camera->animState++;
    }
    if (unk20->unk_1A != 0) {
        camera->thetaUpdateRateInv = Camera_LERPCeilF(jump1->unk_0C + unk20->unk_1A, camera->thetaUpdateRateInv, OREG(26) * 0.01f, 0.1f);
        camera->phiUpdateRateInv = Camera_LERPCeilF((f32)OREG(7) + unk20->unk_1A, camera->phiUpdateRateInv, OREG(26) * 0.01f, 0.1f);
        unk20->unk_1A--;
    } else {
        camera->thetaUpdateRateInv = Camera_LERPCeilF(jump1->unk_0C, camera->thetaUpdateRateInv, OREG(26) * 0.01f, 0.1f);
        camera->phiUpdateRateInv = Camera_LERPCeilF((f32)OREG(7), camera->phiUpdateRateInv, OREG(26) * 0.01f, 0.1f);
    }
    camera->xzOffsetUpdateRate = Camera_LERPCeilF(OREG(2) * 0.01f, camera->xzOffsetUpdateRate, OREG(25) * 0.01f, 0.1f);
    camera->yOffsetUpdateRate = Camera_LERPCeilF(OREG(3) * 0.01f, camera->yOffsetUpdateRate, OREG(26) * 0.01f, 0.1f);
    camera->fovUpdateRate = Camera_LERPCeilF(OREG(4) * 0.01f, camera->yOffsetUpdateRate, 0.05f, 0.1f);
    func_800458D4(camera, &sp88, jump1->unk_00, &unk20->unk_1C, 0);
    sp80 = sp90;
    OLib_Vec3fDiffToVecSphRot90(&sp78, sp3C, sp40);
    sp80.r = Camera_LERPCeilF(sp78.r, sp90.r, OREG(29) * 0.01f, 1.0f);
    sp80.phi = Camera_LERPCeilS(sp78.phi, sp90.phi, OREG(29) * 0.01f, 0xA);
    if (unk20->unk_18 != 0) {
        sp80.theta = Camera_LERPCeilS(unk20->unk_16, sp88.theta, 1.0f / camera->thetaUpdateRateInv, 0xA);
        sp80.phi = Camera_LERPCeilS(unk20->unk_14, sp88.phi, 1.0f / camera->thetaUpdateRateInv, 0xA);
    } else {
        sp80.theta = func_80046CB4(camera, sp88.theta, camera->playerPosRot.rot.y, jump1->unk_10, 0.0f);
    }

    if(sp80.r < jump1->unk_04){
        sp80.r = jump1->unk_04;
    } else if(sp80.r > jump1->unk_08){
        sp80.r = jump1->unk_08;
    }

    if(R_CAM_MAX_PHI < sp80.phi){
        sp80.phi = R_CAM_MAX_PHI;
    } else if(OREG(35) > sp80.phi){
        sp80.phi = OREG(35);
    }

    Camera_Vec3fVecSphAdd(&sp98, sp3C, &sp80);
    sp38->x = sp98.x;
    sp38->z = sp98.z;
    sp38->y += (sp98.y - sp38->y) * (OREG(31) * 0.01f);
    if ((camera->status == CAM_STATUS_ACTIVE) && ((jump1->unk_1C & 0x10) == 0)) {
        func_80046E20(camera, &sp80, jump1->unk_04, jump1->unk_0C, &spA4, &unk20->unk_00);
        if (jump1->unk_1C & 4) {
            camera->direction.x = -sp90.phi;
            camera->direction.y = BINANG_ROT180(sp90.theta);
            camera->direction.z = 0;
        } else {
            OLib_Vec3fDiffToVecSphRot90(&sp80, sp40, sp3C);
            camera->direction.x = sp80.phi;
            camera->direction.y = sp80.theta;
            camera->direction.z = 0;
        }
        if (unk20->unk_18 != 0) {
            camera->direction.y = Camera_LERPCeilS(camera->direction.y + BINANG_SUB(BINANG_ROT180(unk20->unk_16), camera->direction.y), camera->direction.y, 1.0f - (0.99f * spA4), 0xA);
        }
    } else {
        unk20->unk_10 = jump1->unk_0C;
        unk20->unk_18 = 0;
        sUpdateCameraDirection = 0;
        *sp40 = *sp38;
    }
    camera->dist = OLib_Vec3fDist(sp3C, sp40);
    camera->roll = Camera_LERPCeilS(0, camera->roll, 0.5f, 0xA);
    camera->atLERPStepScale = func_800450A4(camera, jump1->unk_18);
    return true;
}

#ifdef NON_MATCHING
s32 Camera_Jump2(Camera *camera) {
    Vec3f spC8;
    Vec3f spBC;
    VecSph spB4;
    VecSph spAC;
    VecSph spA4;
    VecSph sp9C;
    f32 sp90;
    f32 sp8C;
    s32 sp88;
    struct_80043D18 sp60;
    f32 sp48;
    Vec3f *sp38;
    Vec3f *sp34;
    Vec3f *sp30;
    PosRot *sp2C;
    void *sp28;
    PosRot *temp_t0;
    PosRot *temp_t0_2;
    f32 *temp_a2;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f12;
    f32 temp_f16;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    s16 temp_t2;
    s16 temp_t8;
    s32 temp_a1;
    s32 temp_cond;
    s32 temp_lo;
    s32 temp_v0_2;
    void *temp_t1;
    void *temp_t1_2;
    void *temp_t5;
    void *temp_v0;
    f32 phi_f2;
    s16 phi_v1;
    s32 phi_t5;
    s32 phi_v1_2;
    s32 phi_v1_3;
    s16 phi_v0;
    s32 phi_v1_4;
    s32 phi_v1_5;
    Jump2 *jump2 = &camera->params.jump2;
    Jump2_Unk24 *unk24 = &jump2->unk_24;
    CameraModeValue *values;

    sp48 = Player_GetCameraYOffset(camera->player);
    if (RELOAD_PARAMS) {
        temp_f12 = (1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / sp48));
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        phi_f2 = camera->playerPosDelta.y > 0.0f ? -10.0f : 10.0f;
        jump2->unk_00 = (f32) (((((f32) NEXTSETTING + phi_f2) * 0.01f) * sp48) * temp_f12);
        jump2->unk_04 = (f32) ((((f32) NEXTSETTING * 0.01f) * sp48) * temp_f12);
        jump2->unk_08 = (f32) ((((f32) NEXTSETTING * 0.01f) * sp48) * temp_f12);
        jump2->unk_0C = (f32) ((f32) NEXTSETTING * 0.01f);
        jump2->unk_10 = (f32) NEXTSETTING;
        jump2->unk_14 = (f32) ((f32) NEXTSETTING * 0.01f);
        jump2->unk_18 = (f32) NEXTSETTING;
        jump2->unk_1C = (f32) ((f32) NEXTSETTING * 0.01f);
        jump2->unk_20 = (s16) NEXTSETTING;
    }
    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    sp38 = &camera->eye;
    sp34 = &camera->at;
    OLib_Vec3fDiffToVecSphRot90((VecSph *) &sp9C, &camera->at, &camera->eye);
    sp30 = &camera->eyeNext;
    OLib_Vec3fDiffToVecSphRot90((VecSph *) &spA4, &camera->at, &camera->eyeNext);
    sCameraInterfaceFlags = jump2->unk_20;
    if (camera->animState == 0 || camera->animState == 0xA || camera->animState == 0x14) {
        spC8 = camera->playerPosRot.pos;
        temp_f0_2 = func_80044510(camera, &spC8);
        unk24->unk_00 = temp_f0_2;
        unk24->unk_04 = spA4.theta;
        unk24->unk_06 = 0;
        if (temp_f0_2 == -32000.0f) {
            osSyncPrintf("\x1b[43;30mcamera: climb: no floor \n\x1b[m");
            unk24->unk_0A = -1;
            unk24->unk_00 = camera->playerPosRot.pos.y - 1000.0f;
        } else if ((camera->playerPosRot.pos.y - unk24->unk_00) < sp48) {
            unk24->unk_0A = 1;
        } else {
            unk24->unk_0A = -1;
        }
        phi_t5 = ((s16)((s16)(camera->playerPosRot.rot.y - 0x7FFF) - spA4.theta) / R_DEFA_CAM_ANIM_TIME) / 4;
        unk24->unk_06 = (s16) ((phi_t5 * 4) - phi_t5);
        unk24->unk_08 = jump2->unk_20 & 2 ? 0xA : 0x2710;
        camera->playerPosRot.pos.x = camera->playerPosRot.pos.x - camera->playerPosDelta.x;
        camera->playerPosRot.pos.y = camera->playerPosRot.pos.y - camera->playerPosDelta.y;
        camera->playerPosRot.pos.z = camera->playerPosRot.pos.z - camera->playerPosDelta.z;
        unk24->unk_0C = R_DEFA_CAM_ANIM_TIME;
        camera->animState++;
        camera->atLERPStepScale = jump2->unk_1C;
    }
    camera->thetaUpdateRateInv = Camera_LERPCeilF(jump2->unk_10, camera->thetaUpdateRateInv, (OREG(25) * 0.01f) * camera->unk_E0, 0.1f);
    camera->xzOffsetUpdateRate = Camera_LERPCeilF(jump2->unk_14, camera->xzOffsetUpdateRate, (OREG(25) * 0.01f) * camera->unk_E0, 0.1f);
    camera->yOffsetUpdateRate = Camera_LERPCeilF(OREG(3) * 0.01f, camera->yOffsetUpdateRate, (OREG(26) * 0.01f) * camera->unk_E0, 0.1f);
    camera->fovUpdateRate = Camera_LERPCeilF(OREG(4) * 0.01f, camera->yOffsetUpdateRate, camera->unk_E0 * 0.05f, 0.1f);
    camera->rUpdateRateInv = OREG(27);
    func_800457A8(camera, &spA4, jump2->unk_00, 0);
    OLib_Vec3fDiffToVecSphRot90(&spB4, sp34, sp38);

    if(spB4.r < jump2->unk_08 + (jump2->unk_08 * jump2->unk_0C)){
        spB4.r = jump2->unk_08 + (jump2->unk_08 * jump2->unk_0C);
    } else if(spB4.r < jump2->unk_04 - (jump2->unk_04 * jump2->unk_0C)){
        spB4.r = jump2->unk_04 - (jump2->unk_04 * jump2->unk_0C);
    }

    temp_t2 = camera->playerPosRot.rot.y - 0x7FFF;
    temp_v0_2 = temp_t2 - spB4.theta;
    if (unk24->unk_0C != 0) {
        unk24->unk_04 = temp_t2;
        unk24->unk_0C--;
        phi_v0 = Camera_LERPCeilS(unk24->unk_04, spA4.theta, 0.5f, 0xA);
    } else {
        phi_v1_2 = ABS(temp_v0_2);
        if (unk24->unk_08 < phi_v1_2) {
            temp_a1 = temp_t2;
            if (temp_v0_2 < 0) {
                phi_v1_3 = temp_a1 + unk24->unk_08;
            } else {
                phi_v1_3 = temp_a1 - unk24->unk_08;
            }
            phi_v0 = Camera_LERPFloorS(phi_v1_3, spA4.theta, 0.1f, 0xA);
        } else {
            phi_v0 = Camera_LERPCeilS(spB4.theta, spA4.theta, 0.25f, 0xA);
        }
    }
    spB4.theta = phi_v0;
    spC8.x = (Math_Sins(camera->playerPosRot.rot.y) * 25.0f) + camera->playerPosRot.pos.x;
    spC8.y = camera->playerPosRot.pos.y + (sp48 * 2.2f);
    spC8.z = (Math_Coss(temp_t0->rot.y) * 25.0f) + camera->playerPosRot.pos.z;
    temp_f0_4 = func_80044434(camera, &spBC, &spC8, &sp88);
    if ((temp_f0_4 != -32000.0f) && (camera->playerPosRot.pos.y < temp_f0_4)) {
        camera->phiUpdateRateInv = Camera_LERPCeilF(20.0f, camera->phiUpdateRateInv, OREG(26) * 0.01f, 0.1f);
        camera->rUpdateRateInv = Camera_LERPCeilF(20.0f, camera->rUpdateRateInv, OREG(26) * 0.01f, 0.1f);
        spB4.phi = Camera_LERPCeilS(0x1F4, spA4.phi, 1.0f / camera->phiUpdateRateInv, 0xA);
    } else if ((camera->playerPosRot.pos.y - unk24->unk_00) < sp48) {
        camera->phiUpdateRateInv = Camera_LERPCeilF(20.0f, camera->phiUpdateRateInv, OREG(26) * 0.01f, 0.1f);
        camera->rUpdateRateInv = Camera_LERPCeilF(20.0f, camera->rUpdateRateInv, OREG(26) * 0.01f, 0.1f);
        spB4.theta = Camera_LERPCeilS(0x1F4, spA4.phi, 1.0f / camera->phiUpdateRateInv, 0xA);
    } else {
        camera->phiUpdateRateInv = 100.0f;
        camera->rUpdateRateInv = 100.0f;
    }
    phi_v1_5 = spB4.phi;
    if (phi_v1_4 >= 0x2AF9) {
        phi_v1_5 = 0x2AF8;
    }
    spB4.phi = (s16) phi_v1_5;
    if (phi_v1_5 < -0x2AF8) {
        spB4.phi = -0x2AF8;
    }
    Camera_Vec3fVecSphAdd(sp30, sp34, &spB4);
    sp60.unk_00 = *sp30;
    if (func_80043D18(camera, sp34, &sp60) != 0) {
        spC8 = sp60.unk_00;
        spAC.r = spB4.r;
        spAC.phi = (u16)0;
        spAC.theta = spB4.theta;
        Camera_Vec3fVecSphAdd(&sp60.unk_00, sp34, &spAC);
        if (func_80043D18(camera, sp34, &sp60) != 0) {
            *sp38 = spC8;
        } else {
            spB4.phi = Camera_LERPCeilS(0, spB4.phi, 0.2f, 0xA);
            Camera_Vec3fVecSphAdd(sp38, sp34, &spB4);
            func_80043F34(camera, sp34, sp38);
        }
    } else {
        *sp38 = *sp30;
    }
    camera->dist = spB4.r;
    camera->fov = Camera_LERPCeilF(jump2->unk_18, camera->fov, camera->fovUpdateRate, 1.0f);
    camera->roll = Camera_LERPCeilS(0, camera->roll, 0.5f, 0xA);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Jump2.s")
#endif

#ifdef NON_MATCHING
s32 Camera_Jump3(Camera *camera) {
    s32 spC8;
    f32 spC4;
    f32 spC0;
    f32 spBC;
    Vec3f spB0;
    VecSph spA8;
    VecSph sp98;
    VecSph sp90;
    f32 sp74;
    PosRot sp60;
    s32 sp54;
    Vec3f *sp40;
    Vec3f *sp3C;
    Vec3f *sp38;
    Jump3_Unk24 *temp_s1;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f18;
    f32 temp_f2;
    f32 temp_f2_2;
    s16 temp_t1;
    void *temp_t8;
    void *temp_v0;
    void *temp_v1;
    s32 phi_a3;
    s16 phi_v1;
    f32 phi_f0;
    f32 phi_f2;
    s16 phi_v0;
    CameraModeValue* values;
    Jump3* jump3 = &camera->params.jump3;
    Jump3_Unk24* unk24 = &jump3->unk_24;
    s32 tempMode;

    sp74 = Player_GetCameraYOffset(camera->player);
    func_8002EEE4(&sp60, &camera->player->actor);
    phi_a3 = 0;
    sp40 = &camera->eye;
    temp_f0 = camera->unk_114 - sp40->y;
    if ((temp_f0 < OREG(44) || camera->animState == 0) && (unk24->unk_22 != 0)) {
        unk24->unk_22 = (u16)0;
        phi_a3 = 1;
    } else if (((f32) OREG(45) < temp_f0) && (unk24->unk_22 != 0xA)) {
        unk24->unk_22 = (u16)0xA;
        phi_a3 = 1;
    }

    sp3C = &camera->at;
    OLib_Vec3fDiffToVecSphRot90(&sp98, sp3C, sp40);
    sp38 = &camera->eyeNext;
    OLib_Vec3fDiffToVecSphRot90(&sp90, &camera->at, &camera->eyeNext);
    if (camera->animState == 0 || camera->animState == 0xA || camera->animState == 0x14 || phi_a3 != 0 || R_RELOAD_CAM_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        temp_f0_2 = (sp74 * 0.01f) * ((1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / sp74)));
        jump3->unk_00 = NEXTSETTING * temp_f0_2;
        jump3->unk_04 = NEXTSETTING * temp_f0_2;
        jump3->unk_08 = NEXTSETTING * temp_f0_2;
        jump3->unk_20 = NEXTSETTING * (65535.0f / 360.0f) + 0.5f;
        jump3->unk_0C = NEXTSETTING;
        jump3->unk_10 = NEXTSETTING;
        jump3->unk_14 = NEXTSETTING * 0.01f;
        jump3->unk_18 = NEXTSETTING;
        jump3->unk_1C = NEXTSETTING * 0.01f;
        jump3->unk_22 = NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS) {
        tempMode = camera->mode;
        camera->mode = unk24->unk_22;
        Camera_CopyPREGToModeValues(camera);
        camera->mode = tempMode;
    }
    sCameraInterfaceFlags = jump3->unk_22;
    if ((((camera->animState == 0) || (camera->animState == 0xA)) || (camera->animState == 0x14)) || (camera->animState == 0x19)) {
        unk24->unk_0C = 0;
        unk24->unk_10 = (f32) jump3->unk_0C;
        unk24->unk_14 = (s16) unk24->unk_18;
        unk24->unk_16 = (s16) unk24->unk_18;
        unk24->unk_18 = (u16)0;
        unk24->unk_1C = (f32) camera->unk_104;
        unk24->unk_1A = (u16)0;
        unk24->unk_20 = (u16)0xA;
        camera->animState++;

    } else if (unk24->unk_20 != 0) {
        unk24->unk_20--;
    }
    spB0 = *sp40;
    temp_f18 = ((OREG(25) * 0.01f) * camera->unk_E0);
    spC0 = ((f32) OREG(26) * 0.01f) * camera->unk_E0;
    if (unk24->unk_18 != 0) {
        spBC = (OREG(25) * 0.01f);
    } else {
        spBC = temp_f18;
    }
    if (unk24->unk_1A != 0) {
        spC4 = temp_f18;
        camera->thetaUpdateRateInv = Camera_LERPCeilF(unk24->unk_10 + (f32) (unk24->unk_1A * 2), camera->thetaUpdateRateInv, temp_f18, 0.1f);
        camera->phiUpdateRateInv = Camera_LERPCeilF((f32) (unk24->unk_1A * 2) + 40.0f, camera->phiUpdateRateInv, spC0, 0.1f);
        unk24->unk_1A = (s16) (unk24->unk_1A - 1);
    } else {
        spC4 = temp_f18;
        camera->thetaUpdateRateInv = Camera_LERPCeilF(unk24->unk_10, camera->thetaUpdateRateInv, spBC, 0.1f);
        camera->phiUpdateRateInv = Camera_LERPCeilF(40.0f, camera->phiUpdateRateInv, spC0, 0.1f);
    }
    camera->xzOffsetUpdateRate = Camera_LERPCeilF((f32) OREG(2) * 0.01f, camera->xzOffsetUpdateRate, spC4, 0.1f);
    temp_f0_3 = Camera_LERPCeilF((f32) OREG(3) * 0.01f, camera->yOffsetUpdateRate, spC0, 0.1f);
    camera->yOffsetUpdateRate = temp_f0_3;
    camera->fovUpdateRate = Camera_LERPCeilF((f32) OREG(4) * 0.01f, temp_f0_3, camera->unk_E0 * 0.05f, 0.1f);
    func_800457A8(camera, (VecSph *) &sp90, jump3->unk_00, jump3->unk_22);
    OLib_Vec3fDiffToVecSphRot90(&spA8, sp3C, sp38);
    temp_f0_4 = func_800469C0(camera, spA8.r, jump3->unk_04, jump3->unk_08, unk24->unk_20);
    spA8.r = temp_f0_4;
    camera->dist = temp_f0_4;
    if (camera->unk_104 <= camera->playerPosRot.pos.y) {
        phi_f0 = camera->playerPosRot.pos.y - camera->unk_104;
    } else {
        phi_f0 = -(camera->playerPosRot.pos.y - camera->unk_104);
    }
    if (!(phi_f0 < 10.0f)) {
        if (camera->unk_114 <= sp60.pos.y) {
            phi_f2 = sp60.pos.y - camera->unk_114;
        } else {
            phi_f2 = -(sp60.pos.y - camera->unk_114);
        }
        if (!(phi_f2 < 50.0f)) {
            camera->phiUpdateRateInv = 100.0f;
        }
    }
    if (unk24->unk_18 != 0) {
        spA8.theta = Camera_LERPCeilS(unk24->unk_16, sp90.theta, 1.0f / camera->thetaUpdateRateInv, 0xA);
        spA8.phi = Camera_LERPCeilS(unk24->unk_14, sp90.phi, 1.0f / camera->thetaUpdateRateInv, 0xA);
    } else {
        spA8.theta = func_80046CB4(camera, sp90.theta, camera->playerPosRot.rot.y, jump3->unk_14, 0.0f);
        spA8.phi = func_80046B44(camera, sp90.phi, jump3->unk_20, (u16)0);
    }
    if (R_CAM_MAX_PHI < spA8.phi) {
        spA8.phi = R_CAM_MAX_PHI;
    }
    if (spA8.phi < R_CAM_MIN_PHI) {
        spA8.phi = R_CAM_MIN_PHI;
    }
    Camera_Vec3fVecSphAdd(sp38, sp3C, &spA8);
    if ((camera->status == 7) && ((jump3->unk_22 & 0x10) == 0)) {
        func_80046E20(camera, &spA8, jump3->unk_04, jump3->unk_0C, &spBC, &unk24->unk_00);
        if ((jump3->unk_22 & 4) != 0) {
            camera->direction.x = -sp98.phi;
            camera->direction.z = 0;
            camera->direction.y = sp98.theta - 0x7FFF;
        } else {
            OLib_Vec3fDiffToVecSphRot90(&spA8, sp40, sp3C);
            camera->direction.x = spA8.phi;
            camera->direction.z = 0;
            camera->direction.y = spA8.theta;
        }
        if (unk24->unk_18 != 0) {
            camera->direction.y = Camera_LERPCeilS(camera->direction.y + ((unk24->unk_16 - 0x7FFF) - camera->direction.y), camera->direction.y, 1.0f - (0.99f * spBC), 0xA);
        }
    } else {
        unk24->unk_18 = 0;
        unk24->unk_10 = jump3->unk_0C;
        sUpdateCameraDirection = 0;
        *sp40 = *sp38;
    }
    camera->fov = Camera_LERPCeilF(jump3->unk_18, camera->fov, camera->fovUpdateRate, 1.0f);
    camera->roll = Camera_LERPCeilS((u16)0, camera->roll, 0.5f, (u16)0xA);
    camera->atLERPStepScale = func_800450A4(camera, jump3->unk_1C);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Jump3.s")
#endif

s32 Camera_Jump4(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Jump0(Camera* camera) {
    return Camera_NOP(camera);
}

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Battle1.s")

s32 Camera_Battle2(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Battle3(Camera* camera) {
    Camera_NOP(camera);
}

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Battle4.s")

s32 Camera_Battle0(Camera* camera) {
    return Camera_NOP(camera);
}

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_KeepOn1.s")

s32 Camera_KeepOn2(Camera* camera) {
    return Camera_NOP(camera);
}

s32 func_800626B0(GlobalContext* globalCtx, CollisionCheckContext* colChkCtx, Vec3f* camera_3C, Vec3f* arg3, Actor** arg4, s32 arg5);

#ifdef NON_MATCHING
s32 Camera_KeepOn3(Camera *camera) {
    KeepOn3* keep3 = &camera->params.keep3;
    f32 spD4;
    Vec3f spD0;
    Vec3f spC4;
    f32 spBC;
    f32 spB8;
    Player *spB0;
    Actor *spAC;
    VecSph spA4;
    VecSph sp9C;
    VecSph sp94;
    VecSph sp8C;
    s32 sp84;
    s16 sp82;
    s16 sp80;
    PosRot sp6C;
    f32 sp58;
    Vec3f *sp48 = &camera->eye;
    PosRot *sp3C = &camera->playerPosRot;
    KeepOn3_Unk2C *unk2C = &keep3->unk_2C;
    PosRot *temp_s1 = &camera->targetPosRot;
    Vec3f *temp_s0 = &camera->at;
    Vec3f *temp_s1_2 = &unk2C->unk_10;
    Vec3f *temp_s2 = &camera->eyeNext;
    f32 *temp_a2;
    f32 *temp_a2_2;
    f32 *temp_a2_3;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f14;
    f32 temp_f14_2;
    f32 temp_f2;
    s16 temp_t7;
    s32 temp_s0_2;
    s32 temp_v0_2;
    void *temp_t4;
    void *temp_v0;
    s16 phi_v0;
    f32 phi_f12;
    s32 phi_a0;
    s16 phi_t3;
    s32 phi_s0;
    s32 phi_s0_2;
    CameraModeValue* values;
    f32 t;
    s16* i;
    const f32 zero6 = 0.6f;

    sp58 = Player_GetCameraYOffset(camera->player);
    if (camera->target == NULL || camera->target->update == NULL) {
        if (camera->target == NULL) {
            osSyncPrintf("\x1b[43;30mcamera: warning: talk: target is not valid, change parallel\n\x1b[m");
        }
        camera->target = NULL;
        Camera_ChangeModeDefaultFlags(camera, CAM_MODE_PARALLEL);
        return 1;
    }

    // Might be a switch
    if (((camera->animState == 0) || (camera->animState == 0xA)) || (camera->animState == 0x14)) {
        if (camera->globalCtx->view.unk_124 == 0) {
            camera->unk_14C |= 0x20;
            camera->globalCtx->view.unk_124 = camera->thisIdx | 0x50;
            return 1;
        }
        camera->unk_14C &= ~0x20;
    }

    camera->unk_14C &= ~0x10;
    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        //t = (1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / yOffset));
        t = (1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / sp58));
        keep3->unk_00 = (f32) (((((f32) NEXTSETTING) * 0.01f) * sp58) * t);
        keep3->unk_04 = NEXTSETTING;
        keep3->unk_08 = NEXTSETTING;
        keep3->unk_0C = NEXTSETTING;
        keep3->unk_10 = NEXTSETTING;
        keep3->unk_14 = NEXTSETTING;
        keep3->unk_18 = NEXTSETTING;
        keep3->unk_1C = NEXTPCT;
        keep3->unk_20 = NEXTSETTING;
        keep3->unk_24 = NEXTPCT;
        keep3->unk_28 = NEXTSETTING;
        keep3->unk_2A = NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }

    sp58 += keep3->unk_00;
    OLib_Vec3fDiffToVecSphRot90(&sp94, temp_s0, &camera->eye);
    OLib_Vec3fDiffToVecSphRot90(&sp8C, temp_s0, temp_s2);
    func_8002EEE4(temp_s1, camera->target);
    func_8002EEE4(&sp6C, &camera->player->actor);
    spD0 = sp3C->pos;
    spD0.y += sp58;
    OLib_Vec3fDiffToVecSphRot90(&spA4, &spD0, (Vec3f *) temp_s1);
    sCameraInterfaceFlags = keep3->unk_2A;
    if (camera->animState == 0 || camera->animState == 0xA || camera->animState == 0x14) {
        spAC = camera->target;
        camera->animState++;
        unk2C->unk_0C = spAC;
        phi_f12 = keep3->unk_08 < spA4.r ? 1.0f : spA4.r / keep3->unk_08;
        unk2C->unk_1C = keep3->unk_28;
        spBC = ((1.0f - phi_f12) * spA4.r) / unk2C->unk_1C;
        sp9C.phi = DEGF_TO_BINANG(keep3->unk_14 + ((keep3->unk_18 - keep3->unk_14) * phi_f12)) + (s32)-(spA4.phi * keep3->unk_1C);
        temp_f14 = keep3->unk_0C + ((keep3->unk_10 - keep3->unk_0C) * phi_f12);

        if(keep3->unk_2A & 0x10){
            sp9C.theta = (BINANG_SUB(spA4.theta, sp8C.theta) < 0 ?
                spA4.theta + DEGF_TO_BINANG(temp_f14) :
                spA4.theta - DEGF_TO_BINANG(temp_f14));
        } else if(keep3->unk_2A & 0x20){
            sp9C.theta = (BINANG_SUB(spA4.theta, sp9C.theta) < 0 ?
                BINANG_ROT180(spA4.theta) - DEGF_TO_BINANG(temp_f14) :
                BINANG_ROT180(spA4.theta) + DEGF_TO_BINANG(temp_f14));
        } else {
            if(ABS(BINANG_SUB(spA4.theta, sp8C.theta)) < 0x3FFF) {
                sp9C.theta = BINANG_SUB(spA4.theta, sp8C.theta) < 0 ? 
                    spA4.theta + DEGF_TO_BINANG(temp_f14) :
                    spA4.theta - DEGF_TO_BINANG(temp_f14);
            } else {
                sp9C.theta = BINANG_SUB(spA4.theta, sp8C.theta) < 0 ?
                BINANG_ROT180(spA4.theta) - DEGF_TO_BINANG(temp_f14) :
                BINANG_ROT180(spA4.theta) + DEGF_TO_BINANG(temp_f14);
            }
        }
        temp_f14_2 = spA4.r;
        sp80 = sp9C.theta;
        sp82 = sp9C.phi;
        spA4.r = (spBC * zero6) + (temp_f14_2 * (1.0f - zero6));
        spD0 = sp3C->pos;
        spB8 = temp_f14_2;
        spD4 = spD4 + sp58;
        Camera_Vec3fVecSphAdd(temp_s1_2, &spD0, &spA4);
        sp84 = ARRAY_COUNT(D_8011D3B0);
        phi_s0 = 0;
        spA4.r = temp_f14_2;
        sp9C.r = ((keep3->unk_04 + (temp_f14_2 * 0.5f)) - sp8C.r) + sp8C.r;
        Camera_Vec3fVecSphAdd(&spC4, temp_s1_2, &sp9C);
        if (!(keep3->unk_2A & 0x80)) {
            while(phi_s0 < sp84){
                if (func_800626B0(camera->globalCtx, &camera->globalCtx->colChkCtx, temp_s1_2, &spC4, &spAC, 2) || func_80043F34(camera, temp_s1_2, &spC4)) {
                    sp9C.theta = D_8011D3B0[phi_s0] + sp80;
                    sp9C.phi = D_8011D3CC[phi_s0] + sp82;
                    Camera_Vec3fVecSphAdd(&spC4, temp_s1_2, &sp9C);
                } else {
                    break;
                }
                phi_s0++;
            }
        }   
        osSyncPrintf("camera: talk: BG&collision check %d time(s)\n", phi_s0);
        camera->unk_14C &= ~4;
        temp_f0_2 = (f32) ((s32) ((unk2C->unk_1C + 1) * unk2C->unk_1C) >> 1);
        unk2C->unk_00.y = (f32) ((f32) ((s32) ((sp9C.theta - sp8C.theta) << 0x10) >> 0x10) / temp_f0_2);
        unk2C->unk_00.z = (f32) ((f32) ((s32) ((sp9C.phi - sp8C.phi) << 0x10) >> 0x10) / temp_f0_2);
        unk2C->unk_00.x = (f32) ((sp9C.r - sp8C.r) / temp_f0_2);
        return 1;
    }

    if (unk2C->unk_1C != 0) {
        temp_a2_3 = &sp9C;
        temp_s0->x = (f32) (temp_s0->x + ((unk2C->unk_10.x - temp_s0->x) / (f32) unk2C->unk_1C));
        temp_s0->y = (f32) (temp_s0->y + ((unk2C->unk_10.y - temp_s0->y) / (f32) unk2C->unk_1C));
        temp_s0->z = (f32) (temp_s0->z + ((unk2C->unk_10.z - temp_s0->z) / (f32) unk2C->unk_1C));
        sp9C.r = ((unk2C->unk_00.x * (f32) unk2C->unk_1C) + sp8C.r) + 1.0f;
        sp9C.theta = sp8C.theta + (s32) (unk2C->unk_00.y * (f32) unk2C->unk_1C);
        sp9C.phi = sp8C.phi + (s32) (unk2C->unk_00.z * (f32) unk2C->unk_1C);
        Camera_Vec3fVecSphAdd(temp_s2, temp_s0, &sp9C);
        *sp48 = *temp_s2;
        camera->fov = Camera_LERPCeilF(keep3->unk_20, camera->fov, 0.5f, 1.0f);
        camera->roll = Camera_LERPCeilS(0, camera->roll, 0.5f, 0xA);
        camera->atLERPStepScale = func_800450A4(camera, keep3->unk_24);
        func_80043F34(camera, temp_s0, sp48);
        unk2C->unk_1C--;
    } else {
        camera->unk_14C |= (0x400 | 0x10);
    }
    if ((camera->unk_14C & 8)) {
        sCameraInterfaceFlags = 0;
        func_80043B60(camera);
        camera->atLERPStepScale = 0.0f;
        if (camera->unk_D8 > 0.001f || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_A) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_B) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_C) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_D) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_E) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_F) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_R) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_G)) {
            camera->unk_14C |= 4;
            camera->unk_14C &= ~8;
        }
    }
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_KeepOn3.s")
#endif

typedef struct {
    Vec3f unk_00;
    char unk_04[0x14];
    Vec3f unk_20;
} struct_8015BD50;

#ifdef NON_MATCHING
s32 Camera_KeepOn4(Camera *camera) {
    static struct_8015BD50 D_8015BD50;
    
    struct Actor *spD0;
    struct Player *spCC;
    CollisionPoly *spC0;
    VecSph spB8;
    VecSph spB0;
    VecSph spA8;
    s16 spA2;
    s16 spA0;
    s16 sp9C;
    f32 sp88;
    Player *sp84;
    s16 sp82;
    s32 sp7C;
    f32 sp74;
    PosRot sp60;
    PosRot sp4C;
    Vec3f *sp44 = &camera->eye;
    Vec3f *sp40 = &camera->at;
    Vec3f *sp3C = &camera->eyeNext;
    PosRot *sp38 = &camera->playerPosRot;
    f32 *temp_a2;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;
    s16 *temp_s0 = &camera->relativeToPlayer;
    s16 temp_ret;
    s16 temp_t4;
    s16 temp_v0_3;
    s32 temp_s0_2;
    s32 temp_v0_2;
    s32 temp_v1;
    u32 temp_t3_2;
    CameraModeValue *values;
    KeepOn4* keep4 = &camera->params.keep4;
    KeepOn4_Unk20* unk20 = &keep4->unk_20;

    sp84 = camera->globalCtx->actorCtx.actorList[ACTORTYPE_PLAYER].first;
    
    if(camera->animState == 0 || camera->animState == 0xA || camera->animState == 0x14){
        if(camera->globalCtx->view.unk_124 == 0){
            camera->unk_14C |= 0x20;
            camera->unk_14C &= ~(0x4 | 0x2);
            camera->globalCtx->view.unk_124 = camera->thisIdx | 0x50;
            return 1;
        }
        camera->unk_14C &= ~0x20;
        unk20->unk_14 = *temp_s0;
    }
    
    if (unk20->unk_14 != *temp_s0) {
        osSyncPrintf("\x1b[43;30mcamera: item: item type changed %d -> %d\n\x1b[m", unk20->unk_14, *temp_s0);
        camera->unk_14C |= 0x20;
        camera->animState = 0x14;
        camera->unk_14C &= ~(0x4 | 0x2);
        camera->globalCtx->view.unk_124 = camera->thisIdx | 0x50;
        return 1;
    }
    sp88 = Player_GetCameraYOffset(camera->player);
    camera->unk_14C &= ~0x10;
    if(RELOAD_PARAMS){
        f32 t = -0.5f;
        f32 t2 = 0.01f;
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        temp_f12 = (1.0f + t) - ((68.0f / sp88) * t);
        keep4->unk_00 = NEXTSETTING * t2 * sp88 * temp_f12;
        keep4->unk_04 = NEXTSETTING * t2 * sp88 * temp_f12;
        keep4->unk_08 = NEXTSETTING;
        keep4->unk_0C = NEXTSETTING;
        keep4->unk_10 = NEXTSETTING;
        keep4->unk_18 = NEXTSETTING;
        keep4->unk_1C = NEXTSETTING;
        keep4->unk_14 = NEXTSETTING * t2;
        keep4->unk_1E = NEXTSETTING;
        osSyncPrintf("camera: item: type %d\n", *temp_s0);
        switch(*temp_s0){
            case 1:
                keep4->unk_00 = (f32) ((sp88 * -0.6f) * temp_f12);
                keep4->unk_04 = (f32) ((sp88 + sp88) * temp_f12);
                keep4->unk_08 = 10.0f;
                break;
            case 2:
            case 3:
                keep4->unk_08 = -20.0f;
                keep4->unk_18 = 80.0f;
                break;
            case 4:
                keep4->unk_00 = (f32) ((sp88 * -0.2f) * temp_f12);
                keep4->unk_08 = 25.0f;
                break;
            case 8:
                keep4->unk_00 = (f32) ((sp88 * -0.2f) * temp_f12);
                keep4->unk_04 = (f32) ((sp88 * 0.8f) * temp_f12);
                keep4->unk_08 = 50.0f;
                keep4->unk_18 = 70.0f;
                break;
            case 9:
                keep4->unk_00 = (f32) ((sp88 * 0.1f) * temp_f12);
                keep4->unk_04 = (f32) ((sp88 * 0.5f) * temp_f12);
                keep4->unk_08 = -20.0f;
                keep4->unk_0C = 0.0f;
                keep4->unk_1C = (u16)0x2540;
                break;
            case 5:
                keep4->unk_00 = (f32) ((sp88 * -0.4f) * temp_f12);
                keep4->unk_08 = -10.0f;
                keep4->unk_0C = 45.0f;
                keep4->unk_1C = (u16)0x2002;
                break;  
            case 10:
                keep4->unk_00 = (f32) ((sp88 * -0.5f) * temp_f12);
                keep4->unk_04 = (f32) ((sp88 * 1.5f) * temp_f12);
                keep4->unk_08 = -15.0f;
                keep4->unk_0C = 175.0f;
                keep4->unk_18 = 70.0f;
                keep4->unk_1C = (u16)0x2202;
                keep4->unk_1E = (u16)0x3C;
                break;
            case 12:
                keep4->unk_00 = (f32) ((sp88 * -0.6f) * temp_f12);
                keep4->unk_04 = (f32) ((sp88 * 1.6f) * temp_f12);
                keep4->unk_08 = -2.0f;
                keep4->unk_0C = 120.0f;
                keep4->unk_10 = sp84->stateFlags1 & 0x8000000 ? 0.0f : 20.0f;
                keep4->unk_1C = (u16)0x3212;
                keep4->unk_1E = (u16)0x1E;
                keep4->unk_18 = 50.0f;
                break;
            case 0x5A:
                keep4->unk_00 = (f32) ((sp88 * -0.3f) * temp_f12);
                keep4->unk_18 = 45.0f;
                keep4->unk_1C = (u16)0x2F02;
                break;
            case 0x5B:
                keep4->unk_00 = (f32) ((sp88 * -0.1f) * temp_f12);
                keep4->unk_04 = (f32) ((sp88 * 1.5f) * temp_f12);
                keep4->unk_08 = -3.0f;
                keep4->unk_0C = 10.0f;
                keep4->unk_18 = 55.0f;
                keep4->unk_1C = (u16)0x2F08;
                break;
            case 0x51:
                keep4->unk_00 = (f32) ((sp88 * -0.3f) * temp_f12);
                keep4->unk_04 = (f32) ((sp88 * 1.5f) * temp_f12);
                keep4->unk_08 = 2.0f;
                keep4->unk_0C = 20.0f;
                keep4->unk_10 = 20.0f;
                keep4->unk_1C = (u16)0x2280;
                keep4->unk_1E = (u16)0x1E;
                keep4->unk_18 = 45.0f;
                break;
            case 11:
                keep4->unk_00 = (f32) ((sp88 * -0.19f) * temp_f12);
                keep4->unk_04 = (f32) ((sp88 * 0.7f) * temp_f12);
                keep4->unk_0C = 130.0f;
                keep4->unk_10 = 10.0f;
                keep4->unk_1C = (u16)0x2522;
                break;
            default:
                break;
        }
    }
    
    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    
    sUpdateCameraDirection = 1;
    sCameraInterfaceFlags = keep4->unk_1C;
    OLib_Vec3fDiffToVecSphRot90(&spB0, sp40, sp44);
    OLib_Vec3fDiffToVecSphRot90(&spA8, sp40, sp3C);
    D_8015BD50.unk_00 = sp38->pos;
    D_8015BD50.unk_00.y += sp88;
    temp_f0_2 = func_8003CCA4(&camera->globalCtx->colCtx, &spC0, &sp7C, &D_8015BD50.unk_00);
    temp_f2 = keep4->unk_00 + D_8015BD50.unk_00.y;
    if (temp_f2 < temp_f0_2) {
        D_8015BD50.unk_00.y = (f32) (temp_f0_2 + 10.0f);
    } else {
        D_8015BD50.unk_00.y = temp_f2;
    }

    switch(camera->animState){
        case 0:
        case 0x14:
            sp9C = 1;
            spCC = camera->player;
            func_80043ABC(camera);
            camera->unk_14C &= ~(0x4 | 0x2);
            unk20->unk_10 = keep4->unk_1E;
            unk20->unk_08 = sp38->pos.y - camera->playerPosDelta.y;
            if(keep4->unk_1C & 2){
                spA2 = DEGF_TO_BINANG(keep4->unk_08);
                spA0 = BINANG_SUB(BINANG_ROT180(sp38->rot.y), spA8.theta) > 0 ? 
                    BINANG_ROT180(sp38->rot.y) + DEGF_TO_BINANG(keep4->unk_04) :
                    BINANG_ROT180(sp38->rot.y) - DEGF_TO_BINANG(keep4->unk_0C);
            } else if(keep4->unk_1C & 4){
                spA2 = DEGF_TO_BINANG(keep4->unk_08);
                spA0 = DEGF_TO_BINANG(keep4->unk_0C);
            } else if(keep4->unk_1C & 8 && camera->target != NULL){
                func_8002EF44(&sp60, camera->target);
                spA2 = DEGF_TO_BINANG(keep4->unk_08) - sp60.rot.x;
                spA0 = BINANG_SUB(BINANG_ROT180(sp60.rot.y), spA8.theta) > 0 ?
                    BINANG_ROT180(sp60.rot.y) + DEGF_TO_BINANG(keep4->unk_0C) :
                    BINANG_ROT180(sp60.rot.y) - DEGF_TO_BINANG(keep4->unk_0C);
                sp9C++;
                spD0 = camera->target;
            } else if(keep4->unk_1C & 0x80 && camera->target != NULL){
                func_8002EF14(&sp4C, camera->target);
                spA2 = DEGF_TO_BINANG(keep4->unk_08);spA2 = (s16) (s32) ((camera->params.keep4.unk_08 * 182.0416717529297f) + 0.5f);
                temp_v0_3 = func_80044A74(&sp4C.pos, &sp38->pos);
                spA0 = BINANG_SUB(temp_v0_3, spA8.theta) > 0 ?
                    temp_v0_3 + DEGF_TO_BINANG(keep4->unk_0C) :
                    temp_v0_3 - DEGF_TO_BINANG(keep4->unk_0C);
                sp9C++;
                spD0 = camera->target;
            } else if(keep4->unk_1C & 0x40){
                spA2 = DEGF_TO_BINANG(keep4->unk_08);
                spA0 = spA8.theta;
            } else {
                spA2 = spA8.phi;
                spA0 = spA8.theta;
            }
            spB8.phi = spA2;
            spB8.theta = spA0;
            spB8.r = keep4->unk_04;
            Camera_Vec3fVecSphAdd(&D_8015BD50.unk_20, &D_8015BD50.unk_00, &spB8);
            sp82 = ARRAY_COUNT(D_8011D3B0);
            if(!(keep4->unk_1C & 1)){
                for(sp7C = 0; sp7C < sp82; sp7C++){
                    if(func_800626B0(camera->globalCtx, &camera->globalCtx->colChkCtx, &D_8015BD50.unk_00, &D_8015BD50.unk_20, &spCC, sp9C) || func_80043F34(camera, &D_8015BD50.unk_00, &D_8015BD50.unk_20)){
                        spB8.theta = D_8011D3B0[sp7C] + spA0;
                        spB8.phi = D_8011D3CC[sp7C] + spA2;
                        Camera_Vec3fVecSphAdd(&D_8015BD50.unk_20, &D_8015BD50.unk_00, &spB8);
                    } else {
                        break;
                    }
                }
                osSyncPrintf("camera: item: BG&collision check %d time(s)\n", sp7C);
            }
            unk20->unk_04 = BINANG_SUB(spB8.phi, spA8.phi) / (f32)unk20->unk_10;
            unk20->unk_00 = BINANG_SUB(spB8.theta, spA8.theta) / (f32)unk20->unk_10;
            unk20->unk_0C = spA8.theta;
            unk20->unk_0E = spA8.phi;
            camera->animState++;
            unk20->unk_12 = 1;
            break;
        case 0xA:
            unk20->unk_08 = sp38->pos.y - camera->playerPosDelta.y;
            break;
        default:
            break;
    }
    camera->xzOffsetUpdateRate = 0.25f;
    camera->yOffsetUpdateRate = 0.25f;
    camera->atLERPStepScale = 0.75f;
    Camera_LERPCeilVec3f(&D_8015BD50.unk_00, sp40, 0.5f, 0.5f, 0.2f);
    if (keep4->unk_10 != 0.0f) {
        spB8.r = keep4->unk_10;
        spB8.phi = 0;
        spB8.theta = sp38->rot.y;
        Camera_Vec3fVecSphAdd(sp40, sp40, &spB8);
    }
    camera->atLERPStepScale = 0.0f;
    spB8.r = camera->dist = Camera_LERPCeilF(keep4->unk_04, camera->dist, 0.25f, 2.0f);
    if(unk20->unk_10 != 0){
        camera->unk_14C |= 0x20;
        unk20->unk_0C += (s16)unk20->unk_00;
        unk20->unk_0E += (s16)unk20->unk_04;
        unk20->unk_10--;
    } else if(keep4->unk_1C & 0x10){
        camera->unk_14C |= (0x400 | 0x10);
        camera->unk_14C |= (0x4 | 0x2);
        camera->unk_14C &= ~8;
        if(camera->unk_160 > 0){
            camera->unk_160--;
        }
    } else {
        camera->unk_14C |= (0x400 | 0x10);
        if(camera->unk_14C & 8 || keep4->unk_1C & 0x80){
            sCameraInterfaceFlags = 0;
            camera->unk_14C |= (0x4 | 0x2);
            camera->unk_14C &= ~8;
            if(camera->prevCamDataIdx < 0){
                Camera_ChangeSetting(camera, camera->prevSetting, 2);
            } else{
                func_8005A7A8(camera, camera->prevCamDataIdx);
                camera->prevCamDataIdx = -1;
            }
        }
    }
    spB8.theta = Camera_LERPCeilS(unk20->unk_0C, spA8.phi, keep4->unk_14, 4);
    spB8.phi = Camera_LERPCeilS(unk20->unk_0E, spA8.theta, keep4->unk_14, 4);
    Camera_Vec3fVecSphAdd(sp3C, sp40, &spB8);
    *sp44 = *sp3C;
    func_80043F34(camera, sp40, sp44);
    camera->fov = Camera_LERPCeilF(keep4->unk_18, camera->fov, camera->fovUpdateRate, 1.0f);
    temp_ret = Camera_LERPCeilS(0, camera->roll, 0.5f, 0xA);
    camera->roll = temp_ret;
    return (s32) temp_ret;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_KeepOn4.s")
#endif


#ifdef NON_MATCHING
s32 Camera_KeepOn0(Camera *camera) {
    s32 pad;
    KeepOn0 *keep0 = &camera->params.keep0;
    CameraModeValue* values;
    VecSph sp5C;
    VecSph sp54;
    s16 pad2;
    s16 phi_a3;
    KeepOn0_UnkC *keep0UnkC = &keep0->unk_0C;
    Vec3f *sp30 = &camera->eye;
    CamPosData *sp44;
    Vec3s sp3C;
    Vec3f *sp2C = &camera->eyeNext;
    PosRot *sp28 = &camera->targetPosRot;
    
   
    camera->unk_14C &= ~0x10;
    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        keep0->unk_00 = NEXTSETTING * 0.01f;
        keep0->unk_04 = NEXTSETTING * 0.01f;
        keep0->unk_08 = NEXTSETTING;
        keep0->unk_0A = NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    sp44 = func_8004476C(camera);
    Camera_Vec3sToVec3f(sp2C, &sp44->pos);
    *sp30 = *sp2C;
    sp3C = sp44->rot;
    phi_a3 = sp44->fov;
    if (phi_a3 == -1) {
        phi_a3 = 0x1770;
    }
    if ((camera->target == NULL) || (camera->target->update == NULL)) {
        if (camera->target == NULL) {
            osSyncPrintf("\x1b[43;30mcamera: warning: talk: target is not valid, change normal camera\n\x1b[m");
        }
        camera->target = NULL;
        Camera_ChangeModeDefaultFlags(camera, CAM_MODE_NORMAL);
        return true;
    }

    func_8002EEE4(&sp28->pos, camera->target);
    sp2C = &camera->at;
    OLib_Vec3fDiffToVecSphRot90(&sp54, sp30, sp2C);
    OLib_Vec3fDiffToVecSphRot90(&sp5C, sp30, &sp28->pos);
    sCameraInterfaceFlags = keep0->unk_0A;
    if (camera->animState == 0) {
        camera->animState++;
        camera->fov = phi_a3 * 0.01f;
        camera->roll = 0;
        camera->atLERPStepScale = 0.0f;
        keep0UnkC->unk_04 = keep0->unk_08;
        keep0UnkC->unk_00 = camera->fov - (camera->fov * keep0->unk_00);
    }

    if (keep0UnkC->unk_04 != 0) {
        sp54.theta += ((s16)(sp5C.theta - sp54.theta) / keep0UnkC->unk_04) * keep0->unk_04;
        Camera_Vec3fVecSphAdd(sp2C, sp30, &sp54);
        keep0UnkC->unk_04--;
    } else {
        camera->unk_14C |= (0x400 | 0x10);
    }
    camera->fov = Camera_LERPCeilF(keep0UnkC->unk_00, camera->fov, 0.5f, 10.0f);
    return true;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_KeepOn0.s")
#endif

s32 Camera_Fixed1(Camera *camera) {
    Vec3f *eye;
    Vec3f *at;
    PosRot *playerPosRot;
    VecSph sp6C;
    VecSph sp64;
    s32 pad;
    Vec3f adjustedPos;
    CamPosData *scenePosData;
    s32 pad2;
    Fixed1 *fixd1;
    Fixed1_InitParams* initParams;
    f32 yOffset;
    CameraModeValue *values;

    yOffset = Player_GetCameraYOffset(camera->player);
    fixd1 = &camera->params.fixd1;
    initParams = &fixd1->initParams;
    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        scenePosData = func_8004476C(camera);
        Camera_Vec3sToVec3f(&initParams->eyePos, &scenePosData->pos);
        initParams->eyeRot = scenePosData->rot;
        initParams->fov = scenePosData->fov;
        fixd1->unk_00 = NEXTSETTING * 0.01f * yOffset;
        fixd1->rotStep = NEXTSETTING * 0.01f;
        fixd1->fov = NEXTSETTING;
        fixd1->unk_0C = NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    if (initParams->fov == -1) {
        initParams->fov = fixd1->fov * 100.0f;
    } else {
        if (initParams->fov < 0x169) {
            initParams->fov *= 100;
        }
    }
    sCameraInterfaceFlags = fixd1->unk_0C;
    if (camera->animState == 0) {
        camera->animState++;
        func_80043B60(camera);
        if (initParams->fov != -1) {
            fixd1->fov = initParams->fov * 0.01f;
        }
    }
    eye = &camera->eye;
    at = &camera->at;
    playerPosRot = &camera->playerPosRot;
    OLib_Vec3fDiffToVecSphRot90(&sp64, eye, at);
    Camera_LERPCeilVec3f(&initParams->eyePos, eye, 0.1f, 0.1f, 0.2f);
    adjustedPos = playerPosRot->pos;
    adjustedPos.y += yOffset;
    camera->dist = OLib_Vec3fDist(&adjustedPos, eye);
    sp6C.r = camera->dist;
    sp6C.phi = Camera_LERPCeilS(-initParams->eyeRot.x, sp64.phi, fixd1->rotStep, 5);
    sp6C.theta = Camera_LERPCeilS(initParams->eyeRot.y, sp64.theta, fixd1->rotStep, 5);
    Camera_Vec3fVecSphAdd(at, eye, &sp6C);
    camera->eyeNext = *eye;
    camera->fov = Camera_LERPCeilF(fixd1->fov, camera->fov, fixd1->rotStep, 0.01f);
    camera->roll = 0;
    camera->atLERPStepScale = 0.0f;
    camera->posOffset.x = camera->at.x - playerPosRot->pos.x;
    camera->posOffset.y = camera->at.y - playerPosRot->pos.y;
    camera->posOffset.z = camera->at.z - playerPosRot->pos.z;
    return true;
}

s32 Camera_Fixed2(Camera *camera) {
    s32 pad;
    Fixed2 *fixd2 = &camera->params.fixd2;
    CameraModeValue* values;
    Vec3f sp78;
    Vec3f sp6C;
    f32 t;
    CamPosData *sp64;
    Vec3f *eye = &camera->eye;
    Vec3f *at = &camera->at;
    Vec3f *eyeNext = &camera->eyeNext;
    f32 yOffset;
    PosRot *playerPosRot = &camera->playerPosRot;
    Fixed2_InitParams *initParams = &fixd2->initParams;

    yOffset = Player_GetCameraYOffset(camera->player);

    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        t = (1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / yOffset));
        fixd2->unk_00.x = (f32) (((((f32) NEXTSETTING) * 0.01f) * yOffset) * t);
        fixd2->unk_00.y = NEXTSETTING * 0.01f;
        fixd2->unk_00.z = NEXTSETTING * 0.01f;
        fixd2->fov = NEXTSETTING;
        fixd2->unk_10 = NEXTSETTING;
        initParams->fov = fixd2->fov * 100.0f;
        sp64 = func_8004476C(camera);
        if (sp64 != NULL) {
            Camera_Vec3sToVec3f(&initParams->eye, &sp64->pos);
            if (sp64->fov != -1) {
                initParams->fov = sp64->fov;
            }
        } else {
            initParams->eye = *eye;
        }
        if (initParams->fov < 0x169) {
            initParams->fov *= 100;
        }
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }

    sCameraInterfaceFlags = fixd2->unk_10;
    sp6C.x = 0.0f;
    sp6C.y = fixd2->unk_00.x + yOffset;
    sp6C.z = 0.0f;

    Camera_LERPCeilVec3f(&sp6C, &camera->posOffset, fixd2->unk_00.z, fixd2->unk_00.z, 0.1f);
    sp78.x = playerPosRot->pos.x + camera->posOffset.x;
    sp78.y = playerPosRot->pos.y + camera->posOffset.y;
    sp78.z = playerPosRot->pos.z + camera->posOffset.z;
    if (camera->animState == 0) {
        camera->animState++;
        func_80043B60(camera);
        if (!(fixd2->unk_10 & 1)) {
            *eye = *eyeNext = initParams->eye;
            camera->at = sp78;
        }
    }
    Camera_LERPCeilVec3f(&sp78, &camera->at, fixd2->unk_00.z, fixd2->unk_00.z, 10.0f);
    Camera_LERPCeilVec3f(&initParams->eye, eyeNext, fixd2->unk_00.y, fixd2->unk_00.y, 0.1f);
    *eye = *eyeNext;
    camera->dist = OLib_Vec3fDist(at, eye);
    camera->roll = 0;
    camera->unk_D8 = 0.0f;
    camera->fov = initParams->fov * 0.01f;
    camera->atLERPStepScale = func_800450A4(camera, 1.0f);
    camera->posOffset.x = camera->at.x - playerPosRot->pos.x;
    camera->posOffset.y = camera->at.y - playerPosRot->pos.y;
    camera->posOffset.z = camera->at.z - playerPosRot->pos.z;
    return true;
}

s32 Camera_Fixed3(Camera *camera) {
    s32 pad;
    Fixed3 *fixd3 = &camera->params.fixd3;
    CameraModeValue *values;
    VecSph atSph;
    CamPosData *sceneCamData;
    VecSph forward;
    Vec3f *eye = &camera->eye;
    Vec3f *at = &camera->at;
    Vec3f *eyeNext = &camera->eyeNext;
    Fixed3_UpdateParams *updateParams = &fixd3->updateParams;

    sceneCamData = func_8004476C(camera);

    OLib_Vec3fDiffToVecSphRot90(&forward, eye, at);
    if (RELOAD_PARAMS){
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        fixd3->interfaceFlags = NEXTSETTING;
        Camera_Vec3sToVec3f(eyeNext, &sceneCamData->pos);
        *eye = *eyeNext;
        updateParams->rot = sceneCamData->rot;
        updateParams->fov = sceneCamData->fov;
        updateParams->jfifId = sceneCamData->jfifId;
        if (updateParams->fov == -1) {
            updateParams->fov = 6000;
        }
        if (updateParams->fov <= 360) {
            updateParams->fov *= 100;
        }
    }


    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }

    if (camera->animState == 0) {
        updateParams->updDirTimer = 5;
        R_CAM_FIXED3_FOV =  updateParams->fov;
        camera->animState++;
    }

    if (sceneCamData->jfifId != updateParams->jfifId) {
        osSyncPrintf("camera: position change %d \n", updateParams->jfifId);
        updateParams->jfifId = sceneCamData->jfifId;
        updateParams->updDirTimer = 5;
    }
    if (updateParams->updDirTimer > 0) {
        updateParams->updDirTimer--;
        sUpdateCameraDirection = true;
    } else {
        sUpdateCameraDirection = false;
    }

    atSph.r = 150.0f;
    atSph.theta = updateParams->rot.y;
    atSph.phi = -updateParams->rot.x;

    Camera_Vec3fVecSphAdd(at, eye, &atSph);
    sCameraInterfaceFlags = fixd3->interfaceFlags;
    updateParams->fov = R_CAM_FIXED3_FOV;
    camera->roll = 0;
    camera->fov = updateParams->fov * 0.01f;
    camera->atLERPStepScale = 0.0f;
    return true;
}

#ifdef NON_MATCHING
s32 Camera_Fixed4(Camera *camera) {
    Vec3f sp84;
    Vec3f sp78;
    VecSph sp70;
    VecSph sp68;
    f32 sp50;
    Vec3f *eye = &camera->eye;
    Vec3f *at = &camera->at;
    PosRot* playerPosRot = &camera->playerPosRot;
    CamPosData *temp_v0_2;
    Vec3f *eyeNext = &camera->eyeNext;
    CameraModeValue* values;
    Fixed4* fixd4 = &camera->params.fixd4;
    Fixed4_Unk14* unk14 = &fixd4->unk_14;
    f32 t;

    sp50 = Player_GetCameraYOffset(camera->player);
    if (RELOAD_PARAMS) {
        t = ((1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / sp50)));
        values =  sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        fixd4->unk_00 = (NEXTSETTING * 0.01f * sp50) * t;
        fixd4->unk_04 = NEXTSETTING * 0.01f;
        fixd4->unk_08 = NEXTSETTING * 0.01f;
        fixd4->unk_0C = NEXTSETTING;
        fixd4->unk_10 = NEXTSETTING;
        temp_v0_2 = func_8004476C(camera);
        if (temp_v0_2 != NULL) {
            Camera_Vec3sToVec3f(&unk14->unk_00, &temp_v0_2->pos);
        } else {
            unk14->unk_00 = *eye;
        }
    }
    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = fixd4->unk_10;
    if (camera->animState == 0) {
        camera->animState++;
        if (!(fixd4->unk_10 & 4)) {
            func_80043B60(camera);
        }
        unk14->unk_0C = fixd4->unk_08;
    }
    eyeNext->x += (unk14->unk_00.x - eyeNext->x) * fixd4->unk_04;
    eyeNext->y += (unk14->unk_00.y - eyeNext->y) * fixd4->unk_04;
    eyeNext->z += (unk14->unk_00.z - eyeNext->z) * fixd4->unk_04;
    *eye = *eyeNext;
    sp78.x = 0.0f;
    sp78.y = 0.0f;
    sp78.z = fixd4->unk_00 + sp50;
    Camera_LERPCeilVec3f(&sp78, &camera->posOffset, 0.1f, 0.1f, 0.1f);
    sp84.x = camera->at.x + (((playerPosRot->pos.x + camera->posOffset.x) - camera->at.x) * 0.5f);
    sp84.y = camera->at.y + (((playerPosRot->pos.y + camera->posOffset.y) - camera->at.y) * 0.5f);
    sp84.z = camera->at.z + (((playerPosRot->pos.z + camera->posOffset.z) - camera->at.z) * 0.5f);
    OLib_Vec3fDiffToVecSphRot90(&sp70, eyeNext, at);
    OLib_Vec3fDiffToVecSphRot90(&sp68, eyeNext, &sp84);
    sp70.r += (sp68.r - sp70.r) * unk14->unk_0C;
    sp70.phi = Camera_LERPCeilS(sp68.phi, sp70.phi, unk14->unk_0C * camera->unk_E0, 0xA);
    sp70.theta = Camera_LERPCeilS(sp68.theta, sp70.theta, unk14->unk_0C * camera->unk_E0, 0xA);
    Camera_Vec3fVecSphAdd(at, eyeNext, &sp70);
    camera->dist = OLib_Vec3fDist(at, eye);
    camera->roll = 0;
    camera->fov = fixd4->unk_0C;
    camera->atLERPStepScale = func_800450A4(camera, 1.0f);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Fixed4.s")
#endif

s32 Camera_Fixed0(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Subj1(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Subj2(Camera* camera) {
    return Camera_NOP(camera);
}

#ifdef NON_MATCHING
/** 
 * First person view
*/
s32 Camera_Subj3(Camera *camera) {
    Subj3* subj3 = &camera->params.subj3;
    Vec3f sp98;
    Vec3f sp8C;
    VecSph sp84;
    VecSph sp7C;
    PosRot sp60;
    f32 sp58;
    s16 sp52;
    s16 sp50;
    f32 sp3C;
    Vec3f *sp38 = &camera->eye;
    Vec3f *sp30 = &camera->eyeNext;
    Subj3_Anim* anim = &subj3->anim;
    Vec3f *temp_s1 = &camera->at;
    PosRot* playerPosRot = &camera->playerPosRot;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f6;
    f32 temp_f8;
    s32 temp_f10;
    CameraModeValue* values;
    f32 t;

    func_8002EEE4(&sp60, camera->player);
    sp3C = Player_GetCameraYOffset(camera->player);
    if (camera->globalCtx->view.unk_124 == 0) {
        camera->globalCtx->view.unk_124 = camera->thisIdx | 0x50;
        return 1;
    }
    func_80043ABC(camera);
    Camera_CopyPREGToModeValues(camera);
    values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
    subj3->eyeNextYOffset = (f32) ((NEXTPCT) * sp3C);
    subj3->eyeDist = (f32) NEXTSETTING;
    subj3->eyeNextDist = (f32) NEXTSETTING;
    subj3->unk_0C = (f32) NEXTSETTING;
    subj3->atOffset.x = NEXTPCT;
    subj3->atOffset.y = NEXTPCT;
    subj3->atOffset.z = NEXTPCT;
    subj3->fovTarget = NEXTSETTING;
    subj3->interfaceFlags = NEXTSETTING;
    sp84.r = subj3->eyeNextDist;
    sp84.theta = sp60.rot.y - 0x7FFF;
    sp84.phi = sp60.rot.x;
    sp98 = sp60.pos;
    sp98.y += subj3->eyeNextYOffset;
    Camera_Vec3fVecSphAdd(&sp8C, &sp98, &sp84);
    OLib_Vec3fDiffToVecSphRot90(&sp7C, temp_s1, sp38);
    sCameraInterfaceFlags = subj3->interfaceFlags;
    if (((camera->animState == 0) || (camera->animState == 0xA)) || (camera->animState == 0x14)) {
        anim->r = sp7C.r;
        anim->theta = sp7C.theta;
        anim->phi = sp7C.phi;
        anim->animTimer = R_DEFA_CAM_ANIM_TIME;
        camera->dist = subj3->eyeNextDist;
        camera->animState++;
        camera->rUpdateRateInv = 1.0f;
        camera->dist = subj3->eyeNextDist;
    }


    if (anim->animTimer != 0) {
        temp_s1->x += (sp98.x - temp_s1->x) * (1.0f / anim->animTimer);
        temp_s1->y += (sp98.y - temp_s1->y) * (1.0f / anim->animTimer);
        temp_s1->z += (sp98.z - temp_s1->z) * (1.0f / anim->animTimer);
        sp50 = (s16)(anim->phi - sp84.phi) * (1.0f / R_DEFA_CAM_ANIM_TIME);
        sp52 = ((s16)(anim->theta - sp84.theta)) * (1.0f / R_DEFA_CAM_ANIM_TIME);
        sp7C.r = Camera_LERPCeilF(anim->animTimer * (anim->r - sp84.r) * (1.0f / R_DEFA_CAM_ANIM_TIME) + sp84.r, sp7C.r, PCT(OREG(28)), 1.0f);
        sp7C.theta = Camera_LERPCeilS(sp84.theta + (sp52 * anim->animTimer), sp7C.theta, PCT(OREG(28)), 0xA);
        sp7C.phi = Camera_LERPCeilS(sp84.phi + (sp50 * anim->animTimer), sp7C.phi, PCT(OREG(28)), 0xA);
        Camera_Vec3fVecSphAdd(sp30, temp_s1, &sp7C);
        *sp38 = *sp30;
        anim->animTimer--;
        if (camera->globalCtx->envCtx.skyDisabled == 0) {
            func_80043F34(camera, temp_s1, sp38);
        } else {
            func_80044340(camera, temp_s1, sp38);
        }
    } else {
        sp58 = Math_Sins(-sp60.rot.x);
        temp_f0_3 = Math_Coss(-sp60.rot.x);
        sp98.x = subj3->atOffset.x;
        sp98.y = (subj3->atOffset.y * temp_f0_3) - (subj3->atOffset.z * sp58);
        sp98.z = (subj3->atOffset.y * sp58) + (subj3->atOffset.z * temp_f0_3);
        sp58 = Math_Sins(sp60.rot.y - 0x7FFF);
        temp_f0_3 = Math_Coss(sp60.rot.y - 0x7FFF);
        subj3->atOffset.x = (sp98.z * sp58) + (sp98.x * temp_f0_3);
        subj3->atOffset.y = sp98.y;
        subj3->atOffset.z = (sp98.z * temp_f0_3) - (subj3->atOffset.x * sp58);
        temp_s1->x = subj3->atOffset.x + sp60.pos.x;
        temp_s1->y = subj3->atOffset.y + sp60.pos.y;
        temp_s1->z = subj3->atOffset.z + sp60.pos.z;
        sp7C.r = subj3->eyeNextDist;
        sp7C.phi = sp60.rot.x;
        sp7C.theta = sp60.rot.y - 0x7FFF;        
        Camera_Vec3fVecSphAdd(sp30, temp_s1, &sp7C);
        sp7C.r = subj3->eyeDist;
        Camera_Vec3fVecSphAdd(sp38, temp_s1, &sp7C);
    }
    camera->posOffset.x = temp_s1->x - playerPosRot->pos.x;
    camera->posOffset.y = temp_s1->y - playerPosRot->pos.y;
    camera->posOffset.z = temp_s1->z - playerPosRot->pos.z;
    camera->fov = Camera_LERPCeilF(subj3->fovTarget, camera->fov, 0.25f, 1.0f);
    camera->roll = 0;
    camera->atLERPStepScale = 0.0f;
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Subj3.s")
#endif

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Subj4.s")

s32 Camera_Subj0(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Data0(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Data1(Camera* camera) {
    osSyncPrintf("chau!chau!\n");
    return Camera_Normal1(camera);
}

s32 Camera_Data2(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Data3(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Data4(Camera *camera)
{
    char pad2[8];
    CameraModeValue *values;
    VecSph sp74;
    VecSph sp6C;
    VecSph sp64;
    f32 t;
    s16 fov;
    Data4_InitParams *initParams;
    CamPosData *sceneCamData;
    Vec3f lookAt;
    Vec3f *at;
    Vec3f *eye;
    Data4* data4;
    f32 yOffset;
    Vec3f *eyeNext;
    char pad[4];

    yOffset = Player_GetCameraYOffset(camera->player);

    data4 = &camera->params.data4;
    initParams = &data4->initParams;
    eye = &camera->eye;
    at = &camera->at;
    eyeNext = &camera->eyeNext;

    if (RELOAD_PARAMS)
    {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        t = (1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / yOffset));
        data4->unk_00 = (f32) (((((f32) NEXTSETTING) * 0.01f) * yOffset) * t);
        data4->fov = NEXTSETTING;
        data4->unk_08 = NEXTSETTING;
        sceneCamData = func_8004476C(camera);
        Camera_Vec3sToVec3f(&initParams->eye, &sceneCamData->pos);
        initParams->rot = sceneCamData->rot;
        fov = sceneCamData->fov;
        initParams->fov = fov;
        if (fov != -1)
        {
            data4->fov = (initParams->fov < 0x169) ? (initParams->fov) : (initParams->fov * 0.01f);
        }

        initParams->jfifId = sceneCamData->jfifId;
        *eye = initParams->eye;
    }

    if (R_RELOAD_CAM_PARAMS)
    {
        Camera_CopyPREGToModeValues(camera);
    }

    sCameraInterfaceFlags = data4->unk_08;
    if (camera->animState == 0)
    {
        camera->animState++;
        func_80043B60(camera);
    }

    OLib_Vec3fDiffToVecSphRot90(&sp64, at, eyeNext);
    func_800457A8(camera, &sp64, data4->unk_00, false);
    OLib_Vec3fDiffToVecSphRot90(&sp74, eye, at);
    sp6C.r = sp74.r;
    sp6C.theta = (initParams->jfifId & 1) ? (((s16) ((camera->relativeToPlayer * (65535.0f / 360.0f)) + 0.5f)) + initParams->rot.y) : (sp74.theta);
    sp6C.phi = (initParams->jfifId & 2) ? (((s16) ((camera->unk_12E * (65535.0f / 360.0f)) + 0.5f)) + initParams->rot.x) : (sp74.phi);
    Camera_Vec3fVecSphAdd(at, eye, &sp6C);
    lookAt = camera->playerPosRot.pos;
    lookAt.y += yOffset;
    camera->dist = OLib_Vec3fDist(&lookAt, eye);
    camera->roll = 0;
    camera->unk_D8 = 0.0f;
    camera->fov = data4->fov;
    camera->atLERPStepScale = 0;
    return true;
}

#ifdef NON_MATCHING
s32 Camera_Unique1(Camera *camera) {
    Vec3f sp98;
    VecSph sp8C;
    VecSph sp84;
    VecSph sp7C;
    VecSph sp74;
    PosRot sp5C;
    Vec3f *sp38;
    Vec3f *sp34;
    Vec3f *sp30;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f2;
    s16 temp_v1;
    Unique1* uniq1 = &camera->params.uniq1;
    Unique1_Unk1C* unk1C = &uniq1->unk_1C;
    CameraModeValue* values;

    temp_f0 = Player_GetCameraYOffset(camera->player);
    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        temp_f2 = (1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / temp_f0));
        uniq1->unk_00 = (f32) ((((f32) NEXTSETTING * 0.01f) * temp_f0) * temp_f2);
        uniq1->unk_04 = (f32) ((((f32) NEXTSETTING * 0.01f) * temp_f0) * temp_f2);
        uniq1->unk_08 = (f32) ((((f32) NEXTSETTING * 0.01f) * temp_f0) * temp_f2);
        uniq1->unk_18 = (s16) (s32) (((f32) NEXTSETTING * 182.041672f) + 0.5f);
        uniq1->unk_10 = (f32) NEXTSETTING;
        uniq1->unk_14 = (f32) ((f32) NEXTSETTING * 0.01f);
        uniq1->unk_1A = (s16) NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS != 0) {
        Camera_CopyPREGToModeValues(camera);
    }
    sUpdateCameraDirection = 1;
    sp38 = &camera->eye;
    sp34 = &camera->at;
    OLib_Vec3fDiffToVecSphRot90((VecSph *) &sp7C, &camera->at, &camera->eye);
    sp30 = &camera->eyeNext;
    OLib_Vec3fDiffToVecSphRot90((VecSph *) &sp74, &camera->at, &camera->eyeNext);
    sCameraInterfaceFlags = uniq1->unk_1A;
    if (camera->animState == 0) {
        camera->posOffset.y = camera->posOffset.y - camera->playerPosDelta.y;
        unk1C->unk_00 = 0.0f;
        unk1C->unk_04 = sp74.theta;
        sp98 = camera->player->unk_908;
        OLib_Vec3fDiffToVecSphRot90(&sp84, &camera->playerPosRot, &sp98);
        unk1C->unk_08 = R_DEFA_CAM_ANIM_TIME;
        temp_v1 = sp84.theta - sp7C.theta;
        if (ABS(temp_v1) < 0x3A98) {
            unk1C->unk_06 = 0;
        } else {
            temp_v1 /= unk1C->unk_08;
            temp_v1 *= 3;
            unk1C->unk_06 = temp_v1;
            /*temp_lo = temp_v1 / (s32) unk1C->unk_08;
            phi_t8 = temp_lo >> 2;
            if (temp_lo < 0) {
                phi_t8 = (s32) (temp_lo + 3) >> 2;
            }
            unk1C->unk_06 = phi_t8 * 3;
            */
        }
        camera->animState++;
    }
    func_8002EEE4(&sp5C, &camera->player->actor);
    camera->thetaUpdateRateInv = Camera_LERPCeilF(100.0f, camera->thetaUpdateRateInv, OREG(25) * 0.01f, 0.1f);
    camera->phiUpdateRateInv = Camera_LERPCeilF(100.0f, camera->phiUpdateRateInv, OREG(25) * 0.01f, 0.1f);
    camera->xzOffsetUpdateRate = Camera_LERPCeilF(0.005f, camera->xzOffsetUpdateRate, OREG(25) * 0.01f, 0.01f);
    camera->yOffsetUpdateRate = Camera_LERPCeilF(0.01f, camera->yOffsetUpdateRate, OREG(26) * 0.01f, 0.01f);
    camera->fovUpdateRate = Camera_LERPCeilF(OREG(4) * 0.01f, camera->fovUpdateRate, 0.05f, 0.1f);
    func_800457A8(camera, &sp74, uniq1->unk_00, 1);
    OLib_Vec3fDiffToVecSphRot90(&sp8C, sp34, sp30);
    camera->dist = func_800468CC(camera, sp8C.r, uniq1->unk_04, uniq1->unk_08);
    sp8C.phi = Camera_LERPCeilS(uniq1->unk_18, sp74.phi, 1.0f / camera->phiUpdateRateInv, 0xA);
    if (OREG(5) < sp8C.phi) {
        sp8C.phi = OREG(5);
    }
    if (sp8C.phi < -OREG(5)) {
        sp8C.phi = -OREG(5);
    }
    if (unk1C->unk_08 != 0) {
        unk1C->unk_08--;
        unk1C->unk_04 = unk1C->unk_04 + unk1C->unk_06;
    }
    sp8C.theta = Camera_LERPFloorS(unk1C->unk_04, sp74.theta, 0.5f, 0x2710);
    Camera_Vec3fVecSphAdd(sp30, sp34, &sp8C);
    *sp38 = *sp30;
    func_80043F34(camera, sp34, sp38);
    camera->fov = Camera_LERPCeilF(uniq1->unk_10, camera->fov, camera->fovUpdateRate, 1.0f);
    camera->roll = 0;
    camera->atLERPStepScale = func_800450A4(camera, uniq1->unk_14);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Unique1.s")
#endif

#ifdef NON_MATCHING
s32 Camera_Unique2(Camera *camera) {
    Vec3f sp70;
    VecSph sp68;
    VecSph sp60;
    f32 sp48;
    Vec3f *sp3C;
    Vec3f *sp34;
    Vec3f *temp_s1;
    f32 phi_f16;
    Unique2* uniq2 = &camera->params.uniq2;
    Unique2_Unk10* unk10 = &uniq2->unk_10;
    CameraModeValue* values;
    Vec3f *eyeNext;

    temp_s1 = &camera->at;
    sp48 = Player_GetCameraYOffset(camera->player);
    sp3C = &camera->eye;
    sp34 = &camera->eyeNext;
    OLib_Vec3fDiffToVecSphRot90(&sp60, temp_s1, sp3C);
    if (RELOAD_PARAMS) {
        f32 t = ((1.0f + (OREG(46) * 0.01f)) - ((OREG(46) * 0.01f) * (68.0f / sp48)));
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        uniq2->unk_00 = (f32) ((((f32) NEXTSETTING * 0.01f) * sp48) * t);
        uniq2->unk_04 = (f32) NEXTSETTING;
        uniq2->unk_08 = (f32) NEXTSETTING;
        uniq2->unk_0C = (s16) NEXTSETTING;
    }
    if (R_RELOAD_CAM_PARAMS != 0) {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = uniq2->unk_0C;
    if ((camera->animState == 0) || (unk10->unk_04 != uniq2->unk_0C)) {
        unk10->unk_04 = uniq2->unk_0C;
    }
    if (camera->animState == 0) {
        camera->animState = 1;
        func_80043B60(camera);
        unk10->unk_00 = 200.0f;
        if (uniq2->unk_0C & 0x10) {
            camera->unk_14C &= ~4;
        }
    }
    sp70 = camera->playerPosRot.pos;
    phi_f16 = (uniq2->unk_0C & 1 ? 1.0f : camera->unk_E0);
    temp_s1->x += (((sp70.x - temp_s1->x) * phi_f16) * 0.6f);
    temp_s1->y += ((((sp70.y + sp48) + uniq2->unk_00) - temp_s1->y) * 0.4f);
    temp_s1->z += (((sp70.z - temp_s1->z) * phi_f16) * 0.6f);
    unk10->unk_00 = (f32) (unk10->unk_00 + ((2.0f - unk10->unk_00) * 0.05f));
    if (uniq2->unk_0C & 1) {
        OLib_Vec3fDiffToVecSphRot90(&sp68, temp_s1, sp34);
        sp68.r = uniq2->unk_04;
        Camera_Vec3fVecSphAdd(&sp70, temp_s1, &sp68);
        Camera_LERPCeilVec3f(&sp70, sp3C, 0.25f, 0.25f, 0.2f);
    } else if (uniq2->unk_0C & 2) {
        if (OLib_Vec3fDistXZ(temp_s1, sp34) < uniq2->unk_04) {
            OLib_Vec3fDiffToVecSphRot90(&sp68, temp_s1, sp34);
            sp68.theta = Camera_LERPCeilS(sp68.theta, sp60.theta, 0.1f, (u16)0xA);
            sp68.r = uniq2->unk_04;
            sp68.phi = 0;
            Camera_Vec3fVecSphAdd(sp3C, temp_s1, &sp68);
            sp3C->y = sp34->y;
        } else {
            Camera_LERPCeilVec3f(sp34, sp3C, 0.25f, 0.25f, 0.2f);
        }
    }
    func_80043F34(camera, temp_s1, sp3C);
    camera->dist = OLib_Vec3fDist(temp_s1, sp3C);
    camera->roll = (u16)0;
    camera->fov = Camera_LERPCeilF(uniq2->unk_08, camera->fov, 0.2f, 0.1f);
    camera->atLERPStepScale = func_800450A4(camera, 1.0f);
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Unique2.s")
#endif

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Unique3.s")

#ifdef NON_MATCHING
s32 Camera_Unique0(Camera *camera) {
    CameraModeValue* values;
    f32 sp84;
    Player *sp7C;
    Vec3f sp70;
    VecSph sp68;
    CamPosData *sp64;
    Vec3s sp5C;
    PosRot *sp34;
    s16 *sp30;
    Unique0 *uniq0 = &camera->params.uniq0;
    Unique0_Unk10 *unk10 = &uniq0->unk_10;
    Vec3f *eye;
    s32 pad;

    sp84 = Player_GetCameraYOffset(camera->player);
    sp7C = camera->player;
    sp30 = &uniq0->unk_0C;
    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        *sp30 = NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    sp34 = &camera->playerPosRot;
    sp70 = sp34->pos;
    sp70.y += sp84;
    sCameraInterfaceFlags = *sp30;
    eye = &camera->eye;
    if (camera->animState == 0) {
        func_80043B60(camera);
        camera->unk_14C &= ~4;
        sp64 = func_8004476C(camera);
        Camera_Vec3sToVec3f(&unk10->unk_10.a, &sp64->pos);

        *eye = camera->eyeNext = unk10->unk_10.a;
        sp5C = sp64->rot;
        if (sp64->fov != -1) {
            camera->fov = sp64->fov < 0x169 ? sp64->fov : sp64->fov * 0.01f;
        }
        unk10->unk_0C = sp64->jfifId;
        if (unk10->unk_0C == -1) {
            unk10->unk_0C = uniq0->unk_06 + uniq0->unk_08;
        }
        sp68.r = OLib_Vec3fDist(&sp70, eye);
        sp68.phi = -sp5C.x;
        sp68.theta = sp5C.y;
        OLib_VecSphRot90ToVec3f(&unk10->unk_10.b, &sp68);
        Math3D_LineVsPos(&unk10->unk_10, sp34, &camera->at);
        unk10->unk_00 = sp34->pos;
        camera->animState++;
    }

    if (sp7C->stateFlags1 & 0x20000000) {
        unk10->unk_00 = sp34->pos;
    }
    if (*sp30 & 1) {
        if (unk10->unk_0C > 0) {
            unk10->unk_0C--;
            unk10->unk_00 = sp34->pos;
        } else if ((!(sp7C->stateFlags1 & 0x20000000)) && ((10.0f <= OLib_Vec3fDistXZ(&sp34->pos, &uniq0->unk_10.unk_00)) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_A) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_B) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_C) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_D) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_E) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_F) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_R) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_G))){
            camera->dist = OLib_Vec3fDist(&camera->at, eye);
            camera->posOffset.x = (f32) (camera->at.x - sp34->pos.x);
            camera->posOffset.y = (f32) (camera->at.y - sp34->pos.y);
            camera->posOffset.z = camera->at.z - sp34->pos.z;
            camera->atLERPStepScale = 0.0f;
            camera->unk_14C |= 4;
            Camera_ChangeSetting(camera, camera->prevSetting, 2);
        }
    } else {
        if (unk10->unk_0C > 0) {
            unk10->unk_0C--;
            if (unk10->unk_0C == 0) {
                sCameraInterfaceFlags = 0;
            }
        } else {
            unk10->unk_00 = sp34->pos;
        }
        if ((!(sp7C->stateFlags1 & 0x20000000)) && ((0.001f < camera->unk_D8) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_A) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_B) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_C) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_D) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_E) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_F) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_R) || CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_G))){
            camera->dist = OLib_Vec3fDist(&camera->at, &camera->eye);
            camera->posOffset.x = camera->at.x - sp34->pos.x;
            camera->posOffset.y = camera->at.y - sp34->pos.y;
            camera->posOffset.z = camera->at.z - sp34->pos.z;
            camera->atLERPStepScale = 0.0f;
            Camera_ChangeSetting(camera, camera->prevSetting, 2);
            camera->unk_14C |= 4;
        }
    }
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Unique0.s")
#endif

s32 Camera_Unique4(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Unique5(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Unique6(Camera* camera) {
    CameraModeValue* values;
    s32 pad;
    Vec3f sp2C;
    Vec3f* playerPosRot;
    f32 offset;

    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        camera->params.uniq6.unk_00 = NEXTSETTING;
    }
    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = camera->params.uniq6.unk_00;
    if (camera->animState == 0) {
        camera->animState++;
        func_80043ABC(camera);
    }
    if (camera->player != NULL) {
        offset = Player_GetCameraYOffset(camera->player);
        playerPosRot = &camera->playerPosRot.pos;
        sp2C = *playerPosRot;
        sp2C.y += offset;
        camera->dist = OLib_Vec3fDist(&sp2C, &camera->eye);
        camera->posOffset.x = camera->at.x - playerPosRot->x;
        camera->posOffset.y = camera->at.y - playerPosRot->y;
        camera->posOffset.z = camera->at.z - playerPosRot->z;
    } else {
        camera->dist = OLib_Vec3fDist(&camera->at, &camera->eye);
    }
    if (camera->params.uniq6.unk_00 & 1) {
        if (camera->unk_160 > 0) {
            camera->unk_160--;
        }
    }
    return 1;
}

s32 Camera_Unique7(Camera *camera) {
    s32 pad;
    Unique7* uniq7 = &camera->params.uniq7;
    CameraModeValue* values;
    VecSph sp4C;
    s16 phi_v1_2;
    CamPosData *sp44;
    Vec3s sp3C;
    Vec3f *at = &camera->at;
    PosRot *playerPosRot = &camera->playerPosRot;
    Vec3f *eye = &camera->eye;
    Vec3f *sp20 = &camera->eyeNext;
    Unique7_Unk8* unk08 = &uniq7->unk_08;

    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        uniq7->unk_00 = (f32) NEXTSETTING;
        uniq7->unk_04 = (s16) NEXTSETTING;
    }
    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    sp44 = func_8004476C(camera);
    Camera_Vec3sToVec3f(sp20, &sp44->pos);
    *eye = *sp20;
    sp3C = sp44->rot;

    OLib_Vec3fDiffToVecSphRot90(&sp4C, eye, &playerPosRot->pos);
    phi_v1_2 = sp44->fov;
    if (phi_v1_2 == -1) {
        phi_v1_2 = uniq7->unk_00 * 100.0f;
    }
    if (phi_v1_2 < 0x169) {
        phi_v1_2 *= 100;
    }
    sCameraInterfaceFlags = uniq7->unk_04;
    if (camera->animState == 0) {
        camera->animState++;
        camera->fov = phi_v1_2 * 0.01f;
        camera->atLERPStepScale = 0.0f;
        camera->roll = 0;
        unk08->unk_00.x = sp4C.theta;
    }
    camera->fov = 60.0f;
    unk08->unk_00.x = Camera_LERPFloorS(sp4C.theta, unk08->unk_00.x, 0.4f, 0x7D0);
    sp4C.phi = Math_Coss(sp4C.theta - sp44->rot.y) * -sp44->rot.x;
    Camera_Vec3fVecSphAdd(at, eye, &sp4C);
    camera->unk_14C |= 0x400;
    return true;
}

s32 Camera_Unique8(Camera* camera) {
    return Camera_NOP(camera);
}

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Unique9.s")

void Camera_DebugPrintSplineArray(char* name, s16 length, CutsceneCameraPoint cameraPoints[]) {
    s32 i;

    osSyncPrintf("static SplinedatZ  %s[] = {\n", name);
    for (i = 0; i < length; i++) {
        osSyncPrintf("    /* key frame %2d */ {\n", i);
        osSyncPrintf("    /*     code     */ %d,\n", cameraPoints[i].continueFlag);
        osSyncPrintf("    /*     z        */ %d,\n", cameraPoints[i].cameraRoll);
        osSyncPrintf("    /*     T        */ %d,\n", cameraPoints[i].nextPointFrame);
        osSyncPrintf("    /*     zoom     */ %f,\n", cameraPoints[i].viewAngle);
        osSyncPrintf("    /*     pos      */ { %d, %d, %d }\n", cameraPoints[i].pos.x, cameraPoints[i].pos.y,
                     cameraPoints[i].pos.z);
        osSyncPrintf("    },\n");
    }
    osSyncPrintf("};\n\n");
}

void Camera_Vec3fCopy(Vec3f* src, Vec3f* dst) {
    dst->x = src->x;
    dst->y = src->y;
    dst->z = src->z;
}

void func_80054478(PosRot* arg0, Vec3f* arg1, Vec3f* arg2) {
    VecSph sp28;
    Vec3f sp1C;

    Camera_Vec3fCopy(arg1, &sp1C);
    OLib_Vec3fToVecSphRot90(&sp28, &sp1C);
    sp28.theta += arg0->rot.y;
    Camera_Vec3fVecSphAdd(arg2, &arg0->pos, &sp28);
}

s32 func_800BB2B4(Vec3f*, f32*, f32*, CutsceneCameraPoint*, s16*, Demo1_unk_04*);

#ifdef NON_MATCHING
s32 Camera_Demo1(Camera* camera) {
    s32 pad;
    Demo1* demo1 = &camera->params.demo1;
    Demo1_unk_04* unk_04 = &demo1->unk_04;
    CameraModeValue* values;
    CutsceneCameraPoint* sp84;
    CutsceneCameraPoint* sp80;
    PosRot sp68;
    Vec3f sp5C;
    Vec3f sp50;
    f32 sp4C;
    f32* fov = &camera->fov;
    s16* relativeToPlayer = &camera->relativeToPlayer;
    Vec3f* eye = &camera->eye;
    Vec3f* at = &camera->at; // sp34
    Vec3f* eyeNext = &camera->eyeNext; //sp30

    sp84 = camera->atPoints;
    sp80 = camera->eyePoints;
    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        demo1->unk_00 = values->val;
    }
    sCameraInterfaceFlags = demo1->unk_00;

    switch (camera->animState) {
        case 0:
            unk_04->unk_04 = 0;
            unk_04->unk_00 = 0.0f;
            camera->animState++;
            // absolute / relative
            osSyncPrintf("\x1b[1m%06u:\x1b[m camera: spline demo: start %s \n", camera->globalCtx->state.frames, *relativeToPlayer == 0 ? "絶対" : "相対");
            if (PREG(93)) {
                Camera_DebugPrintSplineArray("CENTER", 5, sp84);
                Camera_DebugPrintSplineArray("   EYE", 5, sp80);
            }
        case 1:
            // follow CutsceneCameraPoints.  function returns 1 if at the end.
            // animState appears to be some kind of state of the cutscene?  0 is init, 1 is update, anything else is stop.
            if (func_800BB2B4(&sp5C, &sp4C, fov, sp80, &unk_04->unk_04, unk_04) ||
                func_800BB2B4(&sp50, &sp4C, fov, sp84, &unk_04->unk_04, unk_04)) {
                camera->animState++;
            }
            if (*relativeToPlayer) {
                if (camera->player != NULL && camera->player->actor.update != NULL) {
                    func_8002EF14(&sp68, &camera->player->actor);
                    func_80054478(&sp68, &sp5C, eyeNext);
                    func_80054478(&sp68, &sp50, at);
                } else {
                    osSyncPrintf("\x1b[41;37mcamera: spline demo: owner dead\n\x1b[m");
                }
            } else {
                Camera_Vec3fCopy(&sp5C, eyeNext);
                Camera_Vec3fCopy(&sp50, at);
            }
            *eye = *eyeNext;
            camera->roll = sp4C * 256.0f;
            camera->dist = OLib_Vec3fDist(at, eye);
            break;
    }
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Demo1.s")
#endif

s32 Camera_Demo2(Camera* camera) {
    return Camera_NOP(camera);
}

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Demo3.s")

s32 Camera_Demo4(Camera* camera) {
    return Camera_NOP(camera);
}

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Demo5.s")

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Demo6.s")

void Camera_Demo7(Camera* camera) {
    if (camera->animState == 0) {
        camera->unk_14C &= ~4;
        camera->unk_14C |= 0x1000;
        camera->animState++;
    }
}

s32 Camera_Demo8(Camera* camera) {
    return Camera_NOP(camera);
}

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Demo9.s")


s32 Camera_Demo0(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Special0(Camera* camera) {
    s32 pad;
    CameraModeValue* values;
    Vec3f* playerPosRot;

    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        camera->params.spec0.unk_00 = NEXTSETTING * 0.01f;
        camera->params.spec0.unk_04 = NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }

    sCameraInterfaceFlags = camera->params.spec0.unk_04;

    if (camera->animState == 0) {
        camera->animState++;
    }
    if ((camera->target == NULL) || (camera->target->update == NULL)) {
        if (camera->target == NULL) {
            osSyncPrintf(VT_COL(YELLOW, BLACK) "camera: warning: circle: target is not valid, stop!\n" VT_RST);
        }
        camera->target = NULL;
        return true;
    }

    func_8002EEE4(&camera->targetPosRot, camera->target);
    Camera_LERPCeilVec3f(&camera->targetPosRot, &camera->at, camera->params.f, camera->params.f, 0.1f);
    if (1) {
        playerPosRot = &camera->playerPosRot.pos;
    }
    camera->posOffset.x = camera->at.x - playerPosRot->x;
    camera->posOffset.y = camera->at.y - playerPosRot->y;
    camera->posOffset.z = camera->at.z - playerPosRot->z;
    camera->dist = OLib_Vec3fDist(&camera->at, &camera->eye);
    camera->unk_D8 = 0.0f;
    if (camera->unk_160 > 0) {
        camera->unk_160--;
    }
    return true;
}

s32 Camera_Special1(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Special2(Camera* camera) {
    return Camera_Unique2(camera);
}

s32 Camera_Special3(Camera* camera) {
    return Camera_NOP(camera);
}

s32 Camera_Special4(Camera* camera) {
    PosRot sp3C;
    s16 sp3A;
    s16* unk_160 = &camera->unk_160;
    Special4* spec4 = &camera->params.spec4;

    if (camera->animState == 0) {
        sCameraInterfaceFlags = 0x3200;
        camera->fov = 40.0f;
        camera->animState++;
        spec4->unk_00 = camera->unk_160;
    }

    camera->fov = Camera_LERPCeilF(80.0f, camera->fov, 1.0f / *unk_160, 0.1f);
    if ((camera->params.spec4.unk_00 - *unk_160) < 0xF) {
        (*unk_160)--;
        return 0;
    } else {
        camera->roll = -0x1F4;
        func_8002EF14(&sp3C, camera->target);
        camera->at = sp3C.pos;
        camera->at.y -= 150.0f;
        sp3A = (s16)(sp3C.rot.y - 0x7FFF) + 0x3E8;
        camera->eye.x = camera->eyeNext.x = (Math_Sins(sp3A) * 780.0f) + camera->at.x;
        camera->eyeNext.y = (f32)camera->at.y;
        camera->eye.z = camera->eyeNext.z = (Math_Coss(sp3A) * 780.0f) + camera->at.z;
        camera->eye.y = sp3C.pos.y;
        camera->eye.y = func_80044510(camera, &camera->eye) + 20.0f;
        (*unk_160)--;
        return 1;
    }
}

#ifdef NON_MATCHING
s32 Camera_Special5(Camera *camera) {
    Special5* spec5 = &camera->params.spec5;
    f32 t;
    CameraModeValue *values;
    PosRot spA8;
    s16 pad;
    s16 spA4;
    struct_80043D18 sp7C;
    VecSph sp74;
    VecSph sp6C;
    VecSph sp64;
    VecSph sp5C;
    Vec3f *eye = &camera->eye;
    Vec3f *at = &camera->at;
    Vec3f *eyeNext = &camera->eyeNext;
    PosRot *playerPosRot = &camera->playerPosRot;
    f32 temp_f0;
    Special5_Unk1C* unk1C = &spec5->unk_1C;
    f32 temp_f0_2;
    
    temp_f0 = Player_GetCameraYOffset(camera->player);
    if (camera->animState == 0 || camera->animState == 0xA || camera->animState == 0x14 || R_RELOAD_CAM_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        t = ((1.0f + PCT(OREG(46))) - (PCT(OREG(46)) * (68.0f / temp_f0)));
        spec5->unk_00 = NEXTPCT * temp_f0 * t;
        spec5->unk_04 = (f32) NEXTSETTING;
        spec5->unk_08 = (f32) NEXTSETTING;
        spec5->unk_14 = (s16) NEXTSETTING;
        spec5->unk_16 = (s16) (s32) (((f32) NEXTSETTING * (65535.0f / 360.0f)) + 0.5f);
        spec5->unk_0C = (f32) NEXTSETTING;
        spec5->unk_10 = NEXTPCT;
        spec5->unk_18 = (s16) NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }
    OLib_Vec3fDiffToVecSphRot90(&sp64, at, eye);
    OLib_Vec3fDiffToVecSphRot90(&sp5C, at, eyeNext);
    func_8002EF14(&spA8, camera->target);
    sCameraInterfaceFlags = spec5->unk_18;
    if (camera->animState == 0) {
        camera->animState++;
        unk1C->unk_00 = spec5->unk_14;
    }
    if (unk1C->unk_00 > 0) {
        unk1C->unk_00--;
    } else if (unk1C->unk_00 == 0) {
        if (camera->target == NULL || camera->target->update == NULL) {
            camera->target = NULL;
            return 1;
        } else {
            unk1C->unk_00--;
            if (spec5->unk_08 < OLib_Vec3fDist(&spA8, &playerPosRot->pos)) {
                sp6C.theta = playerPosRot->rot.y;
                sp6C.phi = -playerPosRot->rot.x;
                sp6C.r = 20.0f;
                Camera_Vec3fVecSphAdd(&sp7C.unk_00, &spA8.pos, &sp6C);
                func_80043D18(camera, at, &sp7C);
                OLib_Vec3fToVecSphRot90(&sp6C, &sp7C.unk_0C);
                spA4 = playerPosRot->rot.y - sp6C.theta;
                sp74.r = spec5->unk_04;
                temp_f0_2 = Math_Rand_ZeroOne();    
                sp74.theta = (s16)(playerPosRot->rot.y - 0x7FFF) + 
                            (spA4 < 0 ? 
                                -(s16)((s16)(temp_f0_2 * 2730.0f) + 0x1553) :
                                (s16)((s16)(temp_f0_2 * 2730.0f) + 0x1553));

                sp74.phi = spec5->unk_16;
                Camera_Vec3fVecSphAdd(eyeNext, &spA8.pos, &sp74);
                *eye = *eyeNext;
                func_80043F34(camera, &spA8.pos, eye);
            }
            func_800457A8(camera, &sp5C, spec5->unk_00, 0);
            camera->fov = Camera_LERPCeilF(spec5->unk_0C, camera->fov, (OREG(4) * 0.01f) * camera->atLERPStepScale, 1.0f);
            camera->roll = Camera_LERPCeilS(0, camera->roll, 0.5f, 0xA);
            camera->atLERPStepScale = func_800450A4(camera, spec5->unk_10);
        }
    }
    return 1;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Special5.s")
#endif

/**
 * Camera's eye is fixed at points specified at D_8011DA6C / D_8011DA9C
 * depending on the player's position
*/
s32 Camera_Special7(Camera *camera) {
    s32 pad;
    PosRot *playerPosRot = &camera->playerPosRot;
    Vec3f atTarget;
    f32 yOffset;
    f32 temp_f0;

    yOffset = Player_GetCameraYOffset(camera->player);
    if (camera->animState == 0) {
        if (camera->globalCtx->sceneNum == SCENE_JYASINZOU) {
            // Spirit Temple
            camera->params.spec7.idx = 3;
        } else if (playerPosRot->pos.x < 1500.0f) {
            camera->params.spec7.idx = 2;
        } else if (playerPosRot->pos.y < 3000.0f) {
            camera->params.spec7.idx = 0;
        } else {
            camera->params.spec7.idx = 1;
        }
        camera->animState++;
        camera->roll = 0;
    }

    if (camera->at.y < D_8011DACC[camera->params.spec7.idx]) {
        atTarget = playerPosRot->pos;
        atTarget.y -= 20.0f;
        Camera_LERPCeilVec3f(&atTarget, &camera->at, 0.4f, 0.4f, 0.10f);
        camera->eye = camera->eyeNext = D_8011DA6C[camera->params.spec7.idx];
        temp_f0 = (playerPosRot->pos.y - D_8011DADC[camera->params.spec7.idx]) / (D_8011DACC[camera->params.spec7.idx] - D_8011DADC[camera->params.spec7.idx]);
        camera->roll = D_8011DAEC[camera->params.spec7.idx] * temp_f0;
        camera->fov = (20.0f * temp_f0) + 60.0f;
    } else {
        atTarget = playerPosRot->pos;
        atTarget.y += yOffset;
        Camera_LERPCeilVec3f(&atTarget, &camera->at, 0.4f, 0.4f, 0.1f);
        camera->roll = 0;
        camera->eye = camera->eyeNext = D_8011DA9C[camera->params.spec7.idx];
        camera->fov = 70.0f;
    }

    camera->dist = OLib_Vec3fDist(&camera->at, &camera->eye);
    camera->atLERPStepScale = 0.0f;
    camera->posOffset.x = camera->at.x - playerPosRot->pos.x;
    camera->posOffset.y = camera->at.y - playerPosRot->pos.y;
    camera->posOffset.z = camera->at.z - playerPosRot->pos.z;
    return true;
}

#ifdef NON_MATCHING
// Very close, minor regalloc around -sp64.x
s32 Camera_Special6(Camera *camera) {
    s32 pad;
    Vec3f *at = &camera->at;
    Special6 *spec6 = &camera->params.spec6;
    VecSph spAC;
    Vec3f spA0;
    Vec3f sp94;
    Vec3f sp88;
    Vec3f sp7C;
    VecSph sp74;
    CameraModeValue *values;
    CamPosData *sceneCamPos;
    Vec3s sceneCamRot;
    s16 fov;
    Vec3f *eye = &camera->eye;
    f32 timerF;
    f32 timerDivisor;
    f32 sp54;
    
    Vec3f *eyeNext = &camera->eyeNext;
    PosRot* playerPosRot = &camera->playerPosRot;
    Special6_Unk04* unk04 = &spec6->unk_04;

    if (RELOAD_PARAMS) {
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        spec6->unk_00 = NEXTSETTING;
    }

    if (R_RELOAD_CAM_PARAMS) {
        Camera_CopyPREGToModeValues(camera);
    }

    OLib_Vec3fDiffToVecSphRot90(&sp74, eye, at);
    sceneCamPos = func_8004476C(camera);
    Camera_Vec3sToVec3f(&spA0, &sceneCamPos->pos);
    sceneCamRot = sceneCamPos->rot;
    fov = sceneCamPos->fov;
    if (fov == -1) {
        fov = 6000;
    }

    if (fov < 361) {
        fov *= 100;
    }
    sCameraInterfaceFlags = spec6->unk_00;
    if (eyeNext->x != spA0.x || eyeNext->y != spA0.y || eyeNext->z != spA0.z || camera->animState == 0) {
        camera->player->actor.freeze = 12;
        sCameraInterfaceFlags = (sCameraInterfaceFlags & 0xF0FF) | 0x300;
        unk04->unk_00 = playerPosRot->pos.y;
        unk04->unk_04 = 12;
        *eyeNext = spA0;
        if (camera->animState == 0) {
            camera->animState++;
        }
    }

    if (unk04->unk_04 > 0) {
        timerF = unk04->unk_04;
        sp94 = *eyeNext;
        sp94.x += (playerPosRot->pos.x - sp94.x) * 0.5f;
        sp94.y += (playerPosRot->pos.y - unk04->unk_00) * 0.2f;
        sp88 = sp94;
        sp88.y = Camera_LERPCeilF(sp94.y, eye->y, 0.5f, 0.01f);
        spAC.r = 100.0f;
        spAC.phi = -sceneCamRot.x;
        spAC.theta = sceneCamRot.y;
        Camera_Vec3fVecSphAdd(&sp7C, &sp88, &spAC);
        timerDivisor = 1.0f / timerF;
        eye->x += (sp88.x - eye->x) * timerDivisor;
        eye->y += (sp88.y - eye->y) * timerDivisor;
        eye->z += (sp88.z - eye->z) * timerDivisor;
        at->x += (sp7C.x - at->x) * timerDivisor;
        at->y += (sp7C.y - at->y) * timerDivisor;
        at->z += (sp7C.z - at->z) * timerDivisor;
        camera->fov += ((fov * 0.01f) - camera->fov) / unk04->unk_04;
        unk04->unk_04--;
    } else {
        sCameraInterfaceFlags &= 0xF0FF;
        sp94 = *eyeNext;
        sp94.x += (playerPosRot->pos.x - sp94.x) * 0.5f;
        sp94.y += (playerPosRot->pos.y - unk04->unk_00) * 0.2f;
        *eye = sp94;
        eye->y = Camera_LERPCeilF(sp94.y, eye->y, 0.5f, 0.01f);
        spAC.r = 100.0f;
        spAC.phi = -sceneCamRot.x;
        spAC.theta = sceneCamRot.y;
        Camera_Vec3fVecSphAdd(at, eye, &spAC);
    }
    return true;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Special6.s")
#endif

s32 Camera_Special8(Camera* camera) {
    return Camera_NOP(camera);
}

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Special9.s")

Camera* Camera_Create(View* view, CollisionContext* colCtx, GlobalContext* globalCtx) {
    Camera* newCamera = ZeldaArena_MallocDebug(sizeof(*newCamera), "../z_camera.c", 9370);
    if (newCamera != NULL) {
        osSyncPrintf(VT_FGCOL(BLUE) "camera: create --- allocate %d byte" VT_RST "\n", sizeof(*newCamera) * 4);
        Camera_Init(newCamera, view, colCtx, globalCtx);
    } else {
        osSyncPrintf(VT_COL(RED, WHITE) "camera: create: not enough memory\n" VT_RST);
    }
    return newCamera;
}

void Camera_Destroy(Camera* camera) {
    if (camera != NULL) {
        osSyncPrintf(VT_FGCOL(BLUE) "camera: destroy ---" VT_RST "\n");
        ZeldaArena_FreeDebug(camera, "../z_camera.c", 9391);
    } else {
        osSyncPrintf(VT_COL(YELLOW, BLACK) "camera: destroy: already cleared\n" VT_RST);
    }
}

void Camera_Init(Camera *camera, View *view, CollisionContext *colCtx, GlobalContext *globalCtx) {
    Camera *camP;
    s32 i;
    s16 curUID;
    s16 j;

    func_80106860(camera, 0, sizeof(*camera));
    if (sInitRegs) {
        for(i = 0; i < sOREGInitCnt; i++){
            OREG(i) = sOREGInit[i];
        }

        for(i = 0; i < sPREGInitCnt; i++){
            PREG(i) = sPREGInit[i];
        }

        DbgCamera_FirstInit(camera, &D_8015BD80);
        sInitRegs = false;
        PREG(88) = -1;
    }
    camera->globalCtx = D_8015BD7C = globalCtx;
    DbgCamera_Init(&D_8015BD80, camera);
    curUID = sNextUID;
    sNextUID++;
    while(curUID != 0){
        if (curUID == 0) {
            sNextUID++;
        }

        for(j = 0; j < 4; j++){
            camP = camera->globalCtx->cameraPtrs[j];
            if (camP != NULL && curUID == camP->uid) {
                break;
            }
        }

        if(j == 4){
            break;
        }

        curUID = sNextUID++;
    }

    camera->direction.y = 0x3FFF;
    camera->uid = curUID;
    camera->realDir = camera->direction;
    camera->rUpdateRateInv = 10.0f;
    camera->thetaUpdateRateInv = 10.0f;
    camera->unk_68.x = 0.0f;
    camera->unk_68.y = 1.0f;
    camera->unk_68.z = 0.0f;
    camera->fov = 60.0f;
    camera->phiUpdateRateInv = OREG(7);
    camera->xzOffsetUpdateRate = PCT(OREG(2));
    camera->yOffsetUpdateRate = PCT(OREG(3));
    camera->fovUpdateRate = PCT(OREG(4));
    D_8011D3A8 = 0x20;
    D_8011D3A4 = 0;
    camera->unk_14C = 0;
    camera->setting = camera->prevSetting = 0x21;
    camera->camDataIdx = camera->prevCamDataIdx = -1;
    camera->mode = 0;
    camera->unk_146 = 0x32;
    camera->unk_168 = 0x7FFF;
    camera->unk_160 = -1;
    camera->unk_14C |= 0x4000;

    camera->unk_68.y = 1.0f;
    camera->unk_68.z = camera->unk_68.x = 0.0f;
    camera->skyboxOffset.x = camera->skyboxOffset.y = camera->skyboxOffset.z = 0;
    camera->atLERPStepScale = 1;
    sCameraInterfaceFlags = 0xFF00;
    D_8011D398 = -1;
    D_8011D3F0 = 3;
    osSyncPrintf("\x1b[34mcamera: initialize --- \x1b[m UID %d\n", camera->uid);
}

s32 func_8005AD40(Camera* camera, Actor* doorActor, s16 arg2, f32 arg3, s16 arg4, s16 arg5, s16 arg6);

void func_80057FC4(Camera* camera) {
    if (camera != &camera->globalCtx->cameras[0]) {
        camera->prevSetting = camera->setting = CAM_SET_FREE0;
        camera->unk_14C &= ~0x4;
    } else if (camera->globalCtx->roomCtx.curRoom.mesh->polygon.type != 1) {
        switch (camera->globalCtx->roomCtx.curRoom.unk_03) {
            case 1:
                func_8005AD40(camera, 0, -99, 0, 0, 18, 10);
                camera->prevSetting = camera->setting = CAM_SET_DUNGEON0;
                break;
            case 0:
                osSyncPrintf("camera: room type: default set field\n");
                func_8005AD40(camera, 0, -99, 0, 0, 18, 10);
                camera->prevSetting = camera->setting = CAM_SET_NORMAL0;
                break;
            default:
                osSyncPrintf("camera: room type: default set etc (%d)\n", camera->globalCtx->roomCtx.curRoom.unk_03);
                func_8005AD40(camera, 0, -99, 0, 0, 18, 10);
                camera->prevSetting = camera->setting = CAM_SET_NORMAL0;
                camera->unk_14C |= 4;
                break;
        }
    } else {
        osSyncPrintf("camera: room type: prerender\n");
        camera->prevSetting = camera->setting = CAM_SET_FREE0;
        camera->unk_14C &= ~0x4;
    }
}

void Camera_Stub80058140(Camera* camera) {
}

#ifdef NON_MATCHING
void func_80058148(Camera* camera, Player* player) {
    s32 pad;
    PosRot sp54;
    VecSph sp4C;
    s32 sp48;
    Vec3f sp3C;
    f32 temp_f0;

    func_8002EF44(&sp54, &player->actor);
    temp_f0 = Player_GetCameraYOffset(player);
    camera->player = player;
    camera->playerPosRot = sp54;
    sp4C.r = 180.0f;
    sp4C.phi = 0x71C;
    sp4C.theta = camera->direction.y - 0x7FFF;
    camera->dist = 180.0f;
    camera->direction.x = 0x71C;
    camera->direction.y = sp54.rot.y;
    camera->direction.z = 0;
    camera->realDir = camera->direction;
    camera->unk_D8 = 0.0f;
    camera->playerPosDelta.y = 0.0f;
    camera->at = sp54.pos;
    camera->posOffset.x = 0.0f;
    camera->posOffset.y = temp_f0;
    camera->posOffset.z = 0.0f;
    camera->at.y += temp_f0;
    Camera_Vec3fVecSphAdd(&camera->eyeNext, &camera->at, &sp4C);
    camera->eye = camera->eyeNext;
    camera->roll = 0;
    camera->unk_68.x = 0.0f;
    camera->unk_68.z = 0.0f;
    camera->unk_68.y = 1.0f;

    if (func_80044434(camera, &sp3C, &camera->at, &sp48) != -32000.0f) {
        camera->unk_146 = sp48;
    }

    camera->unk_118 = -1;
    camera->unk_11C = -1;
    camera->unk_14C |= 4;

    if (camera == &camera->globalCtx->cameras[0]) {
        sCameraInterfaceFlags = 0xB200;
    } else {
        sCameraInterfaceFlags = 0;
    }
    func_80057FC4(camera);
    camera->unk_14A = 0;
    camera->paramFlags = 0;
    camera->unk_156 = -1;
    camera->atLERPStepScale = 1.0f;
    Camera_CopyModeValuesToPREG(camera, camera->mode);
    Camera_QRegInit();
    osSyncPrintf(VT_FGCOL(BLUE) "camera: personalize ---" VT_RST "\n");
    if (camera->thisIdx == 0) {
        func_800588B4(camera);
    }
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80058148.s")
#endif

s16 Camera_ChangeStatus(Camera* camera, s16 status) {
    CameraModeValue* values;
    CameraModeValue* valueP;
    s32 i;

    if (PREG(82)) {
        osSyncPrintf("camera: change camera status: cond %c%c\n", status == 7 ? 'o' : 'x', camera->status != 7 ? 'o' : 'x');
    }

    if (PREG(82)) {
        osSyncPrintf("camera: res: stat (%d/%d/%d)\n", camera->thisIdx, camera->setting, camera->mode);
    }

    if (status == CAM_STATUS_ACTIVE && camera->status != CAM_STATUS_ACTIVE) {
        // if we're making the camera active, but it is not already active, update PREG values
        values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
        for(i = 0; i <sCameraSettings[camera->setting].cameraModes[camera->mode].valueCnt; i++){
            valueP = &values[i];
            PREG(valueP->param) = valueP->val;
            if(PREG(82)){
                osSyncPrintf("camera: change camera status: PREG(%02d) = %d\n", valueP->param, valueP->val);
            }
        }
    }
    camera->status = status;
    return camera->status;
}

#ifdef NON_MATCHING
void Camera_PrintSettings(Camera *camera) {
    char allCamStatus[5];
    char camDataIdx[8];
    char activeCamStatus[5];
    s32 i;
    const char t = ' ';

    if (OREG(0) & 1 && camera->thisIdx == camera->globalCtx->activeCamera && gDbgCamEnabled == 0) {
        for(i = 0; i < ARRAY_COUNT(allCamStatus) - 1; i++){
            if(camera->globalCtx->cameraPtrs[i] == NULL){
                activeCamStatus[i] = t;
                allCamStatus[i] = '-';
                break;
            }
            // code is using beql over beq, and loading 0x20 each time.
            switch(camera->globalCtx->cameraPtrs[i]->status){
                default: 
                    activeCamStatus[i] = ' '; 
                    allCamStatus[i] = '*'; 
                    break;
                case CAM_STATUS_UNK0: 
                    allCamStatus[i] = 'c';
                    activeCamStatus[i] = ' ';
                    break; 
                case CAM_STATUS_UNK1:
                    allCamStatus[i] = 'w'; 
                    activeCamStatus[i] = ' '; 
                    break; 
                case CAM_STATUS_UNK3: 
                    allCamStatus[i] = 's'; 
                    activeCamStatus[i] = ' '; 
                    break; 
                case CAM_STATUS_ACTIVE:
                    allCamStatus[i] = 'a'; 
                    activeCamStatus[i] = ' '; 
                    break; 
                case CAM_STATUS_UNK100:
                    allCamStatus[i] = 'd'; 
                    activeCamStatus[i] = ' '; 
                    break; 
            }
            
        }

        activeCamStatus[i + 1] = '\0';
        allCamStatus[i + 1] = '\0';
        
        activeCamStatus[camera->globalCtx->activeCamera] = 'a';
        
        func_8006376C(3, 22, 5, allCamStatus);
        func_8006376C(3, 22, 1, activeCamStatus);
        func_8006376C(3, 23, 5, "S:");
        func_8006376C(5, 23, 4, sCameraSettingNames[camera->setting]);
        func_8006376C(3, 24, 5, "M:");
        func_8006376C(5, 24, 4, sCameraModeNames[camera->mode]);
        func_8006376C(3, 25, 5, "F:");
        func_8006376C(5, 25, 4, sCameraFunctionNames[sCameraSettings[camera->setting].cameraModes[camera->mode].funcIdx]);
        
        // there's some ordering issues here.  This might be some kind of macro?
        i = 0;
        if (camera->camDataIdx < 0) {
            camDataIdx[i++] = '-';
        }

        if ((camera->camDataIdx / 10) != 0) {
            camDataIdx[i++] = (i / 10) + '0';
        }

        camDataIdx[i++] = (i % 10) + '0';
        camDataIdx[i++] = t;
        camDataIdx[i++] = t;
        camDataIdx[i++] = t;
        camDataIdx[i++] = t;
        camDataIdx[i++] = '\0';
        func_8006376C(3, 26, 5, "I:");
        func_8006376C(5, 26, 4, camDataIdx);
    }
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_PrintSettings.s")
#endif

#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_800588B4.s")

/**
 * Sets the room to be hot camera quake flag
*/
s32 Camera_SetRoomHotFlag(Camera* camera) {
    camera->unk_152 &= ~1;

    if (camera->globalCtx->roomCtx.curRoom.unk_02 == 3) {
        camera->unk_152 |= 1;
    }

    return 1;
}

s32 func_80058D34(Camera* camera) {
    s32 phi_a2 = 0;

    if (gDbgCamEnabled == 0) {
        if (camera->globalCtx->activeCamera == 0) {
            if (CHECK_PAD(D_8015BD7C->state.input[2].press, U_CBUTTONS)) {
                osSyncPrintf("attention sound URGENCY\n");
                func_80078884(NA_SE_SY_ATTENTION_URGENCY);
            }
            if (CHECK_PAD(D_8015BD7C->state.input[2].press, D_CBUTTONS)) {
                osSyncPrintf("attention sound NORMAL\n");
                func_80078884(NA_SE_SY_ATTENTION_ON);
            }

            if (CHECK_PAD(D_8015BD7C->state.input[2].press, R_CBUTTONS)) {
                phi_a2 = 1;
            }
            if (CHECK_PAD(D_8015BD7C->state.input[2].press, L_CBUTTONS)) {
                phi_a2 = -1;
            }
            if (phi_a2 != 0) {
                D_8011D398 = (D_8011D398 + phi_a2) % 6;
                if (Camera_ChangeSettingDefaultFlags(camera, D_8011DAFC[D_8011D398]) > 0) {
                    osSyncPrintf("camera: force change SET to %s!\n", sCameraSettingNames[D_8011DAFC[D_8011D398]]);
                }
            }
        }
    }
    return 1;
}

#ifdef NON_MATCHING
void func_80058E8C(Camera *camera) {
    static s16 D_8011DB08 = 0x3F0;
    static s16 D_8011DB0C = 0x156;
    f32 sp60;
    f32 sp40;
    f32 sp3C;
    f32 sp38;
    f32 sp34;
    f32 sp2C;
    f32 sp28;
    f32 temp_f12;
    f32 temp_f20;
    f32 nv;
    f32 phi_f14;
    f32 phi_f2;
    f32 phi_f0;
    f32 phi_f20;

    if (camera->unk_152 != 0) {
        if (camera->unk_152 & 4) {
            sp3C = 0.01f;
            phi_f2 = 170.0f;
            sp38 = 0.0f;
            sp40 = -0.01f;
            sp34 = 0.6f;
            phi_f20 = camera->unk_150 / 60.0f;
            sp60 = 1.0f;
            phi_f0 = 0.0f;
        } else if(camera->unk_152 & 8){
            sp3C = 0.3f;
            phi_f2 = -90.0f;
            sp38 = 0.2f;
            sp40 = -0.3f;
            sp34 = 0.2f;
            phi_f20 = camera->unk_150 / 80.0f;
            sp60 = 1.0f;
            phi_f0 = 248.0f;
        } else if(camera->unk_152 & 2){
            sp3C = 0.09f;
            phi_f2 = -18.5f;
            sp38 = 0.001f;
            sp40 = 0.09f;
            sp34 = 0.08f;
            temp_f12 = camera->unk_114 - camera->eye.y;
            if (150.0f < temp_f12) {
                phi_f14 = 1.0f;
            } else {
                phi_f14 = temp_f12 / 150.0f;
            }
            nv = camera->unk_E0 * 0.45f;
            temp_f20 = (phi_f14 * 0.45f) + nv;
            phi_f20 = temp_f20;
            sp60 = temp_f20;
            phi_f0 = 359.2f;
        } else if(camera->unk_152 & 1){
            sp3C = 0.01f;
            phi_f2 = 150.0f;
            sp38 = 0.01f;
            sp40 = -0.01f;
            sp34 = 0.6f;
            phi_f20 = 1.0f;
            sp60 = 1.0f;
            phi_f0 = 0.0f;
        } else {
            return;
        }
        D_8011DB0C += DEGF_TO_BINANG(phi_f2);
        D_8011DB08 += DEGF_TO_BINANG(phi_f0);
        Math_Coss(D_8011DB08);
        Math_Sins(D_8011DB08);
        Math_Sins(D_8011DB0C);
        func_800AA76C(&camera->globalCtx->view, 0.0f, 0.0f, 0.0f);

        func_800AA78C(&camera->globalCtx->view, (Math_Sins(D_8011DB0C) * (sp40 * phi_f20)) + 1.0f, (Math_Coss(D_8011DB0C) * (sp3C * phi_f20)) + 1.0f, (Math_Coss(D_8011DB08) * (sp38 * phi_f20)) + 1.0f);
        func_800AA7AC(&camera->globalCtx->view, sp34 * sp60);
        camera->unk_14C |= 0x40;        
    } else if (camera->unk_14C & 0x40) {
        func_800AA814(&camera->globalCtx->view);
        camera->unk_14C &= ~0x40;
    }
}
#else
s16 D_8011DB08 = 0x3F0;
s16 D_8011DB0C = 0x156;
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/func_80058E8C.s")
#endif


#ifdef NON_MATCHING
Vec3s *Camera_Update(Vec3s *outVec, Camera *camera) {
    static s32 sOOBTimer = 0;
    Vec3f spD4;
    Vec3f spC8;
    Vec3f spBC;
    f32 spB8;
    Vec3f spAC;
    s32 spA8;
    f32 spA4;
    f32 playerXZDiff;
    VecSph sp98;
    s16 temp_v1;
    PosRot curPlayerPosRot;
    QuakeCamCalc quake;
    Player *player;
    s32 oobTimer;

    player = camera->globalCtx->cameraPtrs[0]->player;
    if (R_DBG_CAM_UPDATE) {
        osSyncPrintf("camera: in %x\n", camera);
    }
    if (camera->status == 0) {
        if (R_DBG_CAM_UPDATE) {
            osSyncPrintf("camera: cut out %x\n", camera);
        }
        *outVec = camera->direction;
        return outVec;
    } else {
        sUpdateCameraDirection = 0;
        if (camera->player != NULL) {
            func_8002EF44(&curPlayerPosRot, &camera->player->actor);
            playerXZDiff = OLib_Vec3fDistXZ(&curPlayerPosRot, &camera->playerPosRot);
            camera->unk_D8 = playerXZDiff;
            camera->unk_E0 = func_8007C0A8(playerXZDiff / (func_8002DCE4(camera->player) * (OREG(8) * 0.01f)), 1.0f);
            camera->playerPosDelta.x = curPlayerPosRot.pos.x - camera->playerPosRot.pos.x;
            camera->playerPosDelta.y = curPlayerPosRot.pos.y - camera->playerPosRot.pos.y;
            camera->playerPosDelta.z = curPlayerPosRot.pos.z - camera->playerPosRot.pos.z;
            spAC = curPlayerPosRot.pos;
            spAC.y += Player_GetCameraYOffset(camera->player);

            // This has to do with out of bounds Camera
            spA4 = func_8003CA0C(camera->globalCtx, &camera->globalCtx->colCtx, &playerFloorPoly, &spA8, camera->player, &spAC);
            if (spA4 != -32000.0f) {
                oobTimer = 0;
                camera->unk_108.x = playerFloorPoly->norm.x * (1.0f / 32767.0f);
                camera->unk_108.y = playerFloorPoly->norm.y * (1.0f / 32767.0f);
                camera->unk_108.z = playerFloorPoly->norm.z * (1.0f / 32767.0f);
                camera->unk_146 = spA8;
                camera->unk_104 = spA4;
            } else {
                oobTimer = sOOBTimer + 1;
                // an extra mtc1 zero, fx is being generated.
                camera->unk_108.x = 0.0f;
                camera->unk_108.z = 0.0f;
                camera->unk_108.y = 1.0f;
            }

            camera->playerPosRot = curPlayerPosRot;
            sOOBTimer = oobTimer;
            if (oobTimer < 0xC8) {
                if (camera->status == 7) {
                    func_800588B4(camera);
                    Camera_SetRoomHotFlag(camera);
                }

                if (!(camera->unk_14C & 4)) {
                    camera->unk_156 = -1;
                }

                if (camera->unk_14C & 1) {
                    if ((camera->unk_14C & 4) && (!(camera->unk_14C & 0x400)) &&
                        (!(camera->unk_14C & 0x200) || (player->currentBoots == 1)) &&
                        // cast to u32 is needed to prevent sra over srl
                        (!((u32)camera->unk_14C >> 0xF)) && (spA4 != -32000.0f)) {
                        temp_v1 = func_8004479C(camera, &spA8, playerFloorPoly);
                        if (temp_v1 != -1) {
                            camera->unk_158 = spA8;
                            if (spA8 == 0x32) {
                                camera->unk_156 = temp_v1;
                            }
                        }
                    }
                }

                if (camera->unk_156 != -1 && (fabsf(curPlayerPosRot.pos.y - spA4) < 2.0f) &&
                    (!(camera->unk_14C & 0x200) || (player->currentBoots == 1))) {
                    camera->unk_146 = camera->unk_158;
                    func_8005A7A8(camera, camera->unk_156);
                    camera->unk_156 = -1;
                }
            }
        }

        Camera_PrintSettings(camera);
        func_80058D34(camera);

        if (camera->status == 1) {
            if (R_DBG_CAM_UPDATE) {
                osSyncPrintf("camera: wait out %x\n", camera);
            }
            *outVec = camera->direction;
            return outVec;
        }

        camera->unk_14A = 0;
        camera->unk_14C &= ~(0x400 | 0x20);
        camera->unk_14C |= 0x10;

        if (R_DBG_CAM_UPDATE) {
            osSyncPrintf("camera: engine (%d %d %d) %04x \n", camera->setting, camera->mode, sCameraSettings[camera->setting].cameraModes[camera->mode].funcIdx, camera->unk_14C);
        }

        oobTimer = sOOBTimer;
        if (oobTimer < 0xC8) {
            sCameraFunctions[sCameraSettings[camera->setting].cameraModes[camera->mode].funcIdx](camera);
        } else if (camera->player != NULL) {
            OLib_Vec3fDiffToVecSphRot90(&sp98, &camera->at, &camera->eye);
            func_800457A8(camera, &sp98, 0.0f, 0);
        }

        if (camera->status == 7) {
            if ((gSaveContext.gameMode != 0) && (gSaveContext.gameMode != 3)) {
                sCameraInterfaceFlags = 0;
                Camera_UpdateInterface(sCameraInterfaceFlags);
            } else if ((D_8011D3F0 != 0) && (camera->thisIdx == 0)) {
                D_8011D3F0--;
                sCameraInterfaceFlags = 0x3200;
                Camera_UpdateInterface(sCameraInterfaceFlags);
            } else if (camera->globalCtx->transitionMode != 0) {
                sCameraInterfaceFlags = 0xF200;
                Camera_UpdateInterface(sCameraInterfaceFlags);
            } else if (camera->globalCtx->csCtx.state != 0) {
                sCameraInterfaceFlags = 0x3200;
                Camera_UpdateInterface(sCameraInterfaceFlags);
            } else {
                Camera_UpdateInterface(sCameraInterfaceFlags);
            }
        }

        if (R_DBG_CAM_UPDATE) {
            osSyncPrintf("camera: shrink_and_bitem %x(%d)\n", sCameraInterfaceFlags, camera->globalCtx->transitionMode);
        }

        if (R_DBG_CAM_UPDATE) {
            osSyncPrintf("camera: engine (%s(%d) %s(%d) %s(%d)) ok!\n", &sCameraSettingNames[camera->setting], camera->setting, &sCameraModeNames[camera->mode], camera->mode, &sCameraFunctionNames[sCameraSettings[camera->setting].cameraModes[camera->mode].funcIdx], sCameraSettings[camera->setting].cameraModes[camera->mode].funcIdx);
        }

        if (CHECK_PAD(D_8015BD7C->state.input[2].press, CONT_START)) {
            gDbgCamEnabled ^= 1;
            if (gDbgCamEnabled) {
                DbgCamera_Enable(&D_8015BD80, camera);
            } else {
                if (camera->globalCtx->csCtx.state != 0) {
                    func_80064534(camera->globalCtx, &camera->globalCtx->csCtx);
                }
            }
        }
        if (gDbgCamEnabled) {
            camera->globalCtx->view.fovy = D_8015BD80.fov;
            DbgCamera_Update(&D_8015BD80, camera);
            func_800AA358(&camera->globalCtx->view, &D_8015BD80.eye, &D_8015BD80.at, &D_8015BD80.unk_1C);
            if (R_DBG_CAM_UPDATE) {
                osSyncPrintf("camera: debug out\n");
            }
            *outVec = D_8015BD80.unk_10C6;
            return outVec;
        }
        OREG(0) &= ~8;
        if (camera->status == 3) {
            *outVec = camera->direction;
            return outVec;
        } else {
            if ((Quake_Calc(camera, &quake) != 0) && (camera->setting != 0x38)) {
                spD4.x = camera->at.x + quake.atOffset.x;
                spD4.y = camera->at.y + quake.atOffset.y;
                spD4.z = camera->at.z + quake.atOffset.z;
                spC8.x = camera->eye.x + quake.eyeOffset.x;
                spC8.y = camera->eye.y + quake.eyeOffset.y;
                spC8.z = camera->eye.z + quake.eyeOffset.z;
                OLib_Vec3fDiffToVecSphRot90(&sp98, &spC8, &spD4);
                func_80044E68(&spBC, sp98.phi + quake.zoom, sp98.theta + quake.unk_1A, camera->roll);
                spB8 = camera->fov + (quake.zoom * (360.0f / 65535.0f));
            } else {
                spD4 = camera->at;
                spC8 = camera->eye;
                OLib_Vec3fDiffToVecSphRot90(&sp98, &spC8, &spD4);
                func_80044E68(&spBC, sp98.phi, sp98.theta, camera->roll);
                spB8 = camera->fov;
            }
            if (camera->paramFlags & 4) {
                camera->paramFlags &= ~4;
                spBC = camera->unk_68;
            } else {
                camera->unk_68 = spBC;
            }

            camera->skyboxOffset = quake.eyeOffset;

            func_80058E8C(camera);
            if ((camera->globalCtx->sceneNum == 0x51) && (camera->fov < 59.0f)) {
                View_SetScale(&camera->globalCtx->view, 0.79f);
            } else {
                View_SetScale(&camera->globalCtx->view, 1.0f);
            }
            camera->globalCtx->view.fovy = spB8;
            func_800AA358(&camera->globalCtx->view, &spC8, &spD4, &spBC);
            camera->realDir.x = sp98.phi;
            camera->realDir.y = sp98.theta;
            camera->realDir.z = 0;
            if (sUpdateCameraDirection == 0) {
                camera->direction.x = sp98.phi;
                camera->direction.y = sp98.theta;
                camera->direction.z = 0;
            }
            if (R_DBG_CAM_UPDATE) {
                osSyncPrintf("dir  (%d) %d(%f) %d(%f) 0(0) \n", sUpdateCameraDirection, camera->direction.x, camera->direction.x * (360.0f / 65535.0f), camera->direction.y, camera->direction.y * (360.0f / 65535.0f));
                osSyncPrintf("real (%d) %d(%f) %d(%f) 0(0) \n", sUpdateCameraDirection, camera->realDir.x, camera->realDir.x * (360.0f / 65535.0f), camera->realDir.y, camera->realDir.y * (360.0f / 65535.0f));
            }
            if (camera->unk_160 != -1) {
                if (CHECK_PAD(D_8015BD7C->state.input[0].press, CONT_RIGHT)) {
                    camera->unk_160 = 0;
                }
            }
            if (R_DBG_CAM_UPDATE) {
                osSyncPrintf("camera: out (%f %f %f) (%f %f %f)\n", camera->at.x, camera->at.y, camera->at.z, camera->eye.x, camera->eye.y, camera->eye.z);
                osSyncPrintf("camera: dir (%f %d(%f) %d(%f)) (%f)\n", sp98.r, sp98.phi, sp98.phi * (360.0f / 65535.0f), sp98.theta, sp98.theta * (360.0f / 65535.0f), camera->fov);
                if (camera->player != NULL) {
                    osSyncPrintf("camera: foot(%f %f %f) dist (%f)\n", curPlayerPosRot.pos.x, curPlayerPosRot.pos.y, curPlayerPosRot.pos.z, camera->dist);
                }
            }
            *outVec = camera->direction;
        }
    }
    return outVec;
}
#else
s32 sOOBTimer = 0;
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_Update.s")
#endif

void func_80059EC8(Camera* camera) {
    Camera* sp24 = camera->globalCtx->cameraPtrs[0];
    Player* player = (Player*)camera->globalCtx->actorCtx.actorList[2].first;

    if (camera->unk_160 == 0) {
        Gameplay_ChangeCameraStatus(camera->globalCtx, camera->parentCamIdx, 7);

        if ((camera->parentCamIdx == 0) && (camera->unk_168 != 0)) {
            player->actor.freeze = 0;
            player->stateFlags1 &= ~0x20000000;

            if (player->action != 0) {
                func_8002DF54(camera->globalCtx, &player->actor, 7);
                osSyncPrintf("camera: player demo end!!\n");
            }

            sp24->unk_14C |= 8;
        }

        if (camera->globalCtx->cameraPtrs[camera->childCamIdx]->parentCamIdx == camera->thisIdx) {
            camera->globalCtx->cameraPtrs[camera->childCamIdx]->parentCamIdx = camera->parentCamIdx;
        }

        if (camera->globalCtx->cameraPtrs[camera->parentCamIdx]->childCamIdx == camera->thisIdx) {
            camera->globalCtx->cameraPtrs[camera->parentCamIdx]->childCamIdx = camera->childCamIdx;
        }

        if (camera->globalCtx->cameraPtrs[camera->parentCamIdx]->thisIdx == 0) {
            camera->globalCtx->cameraPtrs[camera->parentCamIdx]->animState = 0;
        }

        camera->parentCamIdx = 0;
        camera->childCamIdx = camera->parentCamIdx;
        camera->unk_160 = -1;
        camera->globalCtx->envCtx.unk_E1 = 0;

        Gameplay_ClearCamera(camera->globalCtx, camera->thisIdx);
    }
}

s32 func_8005A02C(Camera* camera) {
    camera->unk_14C |= 0xC;
    camera->unk_14C &= ~(0x1000 | 0x8);
    return true;
}

#ifdef NON_MATCHING
s32 Camera_ChangeMode(Camera* camera, s16 mode, u8 flags) {
    static s32 D_8011DB14 = 0;
    s32 phi_v0;
    u32 temp_t8;
    s32 phi_at;

    if (QREG(89)) {
        osSyncPrintf("+=+(%d)+=+ recive request -> %s\n", camera->globalCtx->state.frames, sCameraModeNames[mode]);
    }

    if ((camera->unk_14C & 0x20) && (flags == 0)) {
        camera->unk_14A |= 0x20;
        return -1;
    } else if (!(sCameraSettings[camera->setting].validModes & (1 << mode))) {
        if (mode == CAM_MODE_SUBJECT) {
            osSyncPrintf("camera: error sound\n");
            func_80078884(NA_SE_SY_ERROR);
        }
        if (camera->mode != CAM_MODE_NORMAL) {
            osSyncPrintf(VT_COL(YELLOW, BLACK) "camera: change camera mode: force NORMAL: %s %s refused\n" VT_RST,
                         sCameraSettingNames[camera->setting], sCameraModeNames[mode]);
            camera->mode = CAM_MODE_NORMAL;
            Camera_CopyModeValuesToPREG(camera, camera->mode);
            func_8005A02C(camera);
            phi_at = 0xC0000000;
        } else {
            camera->unk_14A = (s16)(camera->unk_14A | 0x20);
            camera->unk_14A = (s16)(camera->unk_14A | 2);
            return 0;
        }
    } else if ((mode == camera->mode) && (flags == 0)) {
        camera->unk_14A |= 0x20;
        camera->unk_14A |= 2;
        return -1;
    } else {
        camera->unk_14A |= 0x20;
        camera->unk_14A |= 2;
        camera = camera;
        Camera_CopyModeValuesToPREG(camera, mode);
        temp_t8 = mode - 1;
        phi_v0 = 0;
        switch (mode) {
            default:
                break;
            case 5: // switch 1
                phi_v0 = 0x20;
                break;
            case 3: // switch 1
                phi_v0 = 4;
                break;
            case 1: // switch 1
                phi_v0 = 0;
                if (camera->target != NULL) {
                    phi_v0 = 0;
                    if (camera->target->id != ACTOR_EN_BOOM) {
                        phi_v0 = 8;
                    }
                }
                break;
            case 0:  // switch 1
            case 2:  // switch 1
            case 7:  // switch 1
            case 14: // switch 1
            case 18: // switch 1
                phi_v0 = 2;
                break;
        }

        switch (camera->mode) {
            default:
                break;
            case 6: // switch 2
                if ((phi_v0 & 0x20) != 0) {
                    camera->animState = (u16)0xAU;
                }
                break;
            case 1: // switch 2
                if ((phi_v0 & 0x10) != 0) {
                    camera->animState = (u16)0xAU;
                }
                phi_v0 |= 1;
                break;
            case 17: // switch 2
                phi_v0 |= 1;
                break;
            case 2: // switch 2
                if ((phi_v0 & 8) != 0) {
                    camera->animState = (u16)0xAU;
                }
                phi_v0 |= 1;
                break;
            case 4: // switch 2
                if ((phi_v0 & 4) != 0) {
                    camera->animState = (u16)0xAU;
                }
                phi_v0 |= 1;
                break;
            case 8:  // switch 2
            case 15: // switch 2
            case 19: // switch 2
                phi_v0 |= 1;
                break;
            case 0: // switch 2
                if ((phi_v0 & 0x10) != 0) {
                    camera->animState = (u16)0xAU;
                }
                break;
        }
        phi_v0 &= ~0x10;
        D_8011DB14 = phi_v0;
        if (camera->status == 7) {
            switch (phi_v0) {
                case 1:
                    func_80078884(NA_SE_PL_WALK_GROUND);
                    break;
                case 2:
                    if (1 == camera->globalCtx->roomCtx.curRoom.unk_03) {
                        func_80078884(NA_SE_SY_ATTENTION_URGENCY);
                    } else {
                        func_80078884(NA_SE_SY_ATTENTION_ON);
                    }
                    break;
                case 4:
                    func_80078884(NA_SE_SY_ATTENTION_URGENCY);
                    break;
                case 8:
                    func_80078884(NA_SE_SY_ATTENTION_ON);
                    break;
            }
        }
        func_8005A02C(camera);
        camera->mode = mode;
        phi_at = 0x80000000;
    }
    return mode | phi_at;
}
#else
s32 D_8011DB14 = 0;
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_ChangeMode.s")
#endif

void Camera_ChangeModeDefaultFlags(Camera* camera, s16 mode) {
    Camera_ChangeMode(camera, mode, 0);
}

s32 Camera_CheckValidMode(Camera* camera, s16 mode) {
    if (QREG(89) != 0) {
        osSyncPrintf("+=+=+=+ recive asking -> %s (%s)\n", sCameraModeNames[mode],
                     sCameraSettingNames[camera->setting]);
    }
    if (!(sCameraSettings[camera->setting].validModes & (1 << mode))) {
        return 0;
    } else if (mode == camera->mode) {
        return -1;
    } else {
        return mode | 0x80000000;
    }
}

#ifdef NON_MATCHING
s16 Camera_ChangeSetting(Camera* camera, s16 setting, s16 flags) {
    s16 temp_t1;
    s32 t;

    if ((camera->unk_14A & 1) && (((sCameraSettings[camera->setting].unk_00 & 0xF000000) >> 0x18) >=
                                  (sCameraSettings[setting].unk_00 & 0xF000000) >> 0x18)) {
        camera->unk_14A |= 0x10;
        return -2;
    }

    if ((setting == CAM_SET_SPOT05A || setting == CAM_SET_SPOT05B) && LINK_IS_ADULT &&
        (camera->globalCtx->sceneNum == 0x56)) {
        camera->unk_14A |= 0x10;
        return -5;
    }

    if (setting == CAM_SET_NONE || setting >= CAM_SET_MAX) {
        osSyncPrintf(VT_COL(RED, WHITE) "camera: error: illegal camera set (%d) !!!!\n" VT_RST, setting);
        return -0x63;
    }

    if (setting == camera->setting && !(flags & 1)) {
        camera->unk_14A |= 0x10;
        if (!(flags & 2)) {
            camera->unk_14A |= 1;
        }
        return -1;
    }

    camera->unk_14A |= 0x10;

    if (1 && !(flags & 2)) {
        camera->unk_14A |= 1;
    }

    camera->unk_14C |= (0x8 | 0x4);
    camera->unk_14C &= ~(0x1000 | 0x8);
    if (!(sCameraSettings[camera->setting].unk_bit1)) {
        camera->prevSetting = camera->setting;
    }

    t = sCameraSettings[camera->setting].unk_00 & 0x40000000;
    if (flags & 8) {
        camera->camDataIdx = camera->prevCamDataIdx;
        camera->prevCamDataIdx = -1;
    } else if (!(flags & 4)) {
        if (!t) {
            camera->prevCamDataIdx = camera->camDataIdx;
        }
        camera->camDataIdx = -1;
    }

    camera->setting = setting;

    if (Camera_ChangeMode(camera, camera->mode, 1) >= 0) {
        Camera_CopyModeValuesToPREG(camera, camera->mode);
    }

    osSyncPrintf(VT_SGR("1") "%06u:" VT_RST " camera: change camera[%d] set %s\n", camera->globalCtx->state.frames,
                 camera->thisIdx, sCameraSettingNames[camera->setting]);

    return setting;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_ChangeSetting.s")
#endif

s32 Camera_ChangeSettingDefaultFlags(Camera* camera, s16 setting) {
    return Camera_ChangeSetting(camera, setting, 0);
}

s32 func_8005A7A8(Camera *arg0, s32 arg1) {
    s16 sp2E;
    s16 temp_v1;

    if (arg1 == -1 || arg1 == arg0->camDataIdx) {
        arg0->unk_14A |= 0x40;
        return -1;
    }

    if ((arg0->unk_14A & 0x40) == 0) {
        sp2E = Camera_GetCamDataSetting(arg0, arg1);
        arg0->unk_14A |= 0x40;
        temp_v1 = Camera_ChangeSetting(arg0, sp2E, 5) >= 0;
        if (temp_v1 || sCameraSettings[arg0->setting].unk_00 & 0x80000000) {
            arg0->camDataIdx = (s16) arg1;
            arg0->unk_14A = (s16) (arg0->unk_14A | 4);
            Camera_CopyModeValuesToPREG(arg0, arg0->mode);
        } else if (temp_v1 < -1) {
            osSyncPrintf("\x1b[41;37mcamera: error: illegal camera ID (%d) !! (%d|%d|%d)\n\x1b[m", arg1, arg0->thisIdx, 0x32, sp2E);
        }
        return 0x80000000 | arg1;
    }
}

Vec3s* func_8005A8C4(Vec3s* arg0, Camera* camera) {
    if (gDbgCamEnabled != 0) {
        *arg0 = D_8015BD80.unk_10C6;
        return arg0;
    } else {
        *arg0 = camera->direction;
        return arg0;
    }
}

s16 func_8005A920(Camera* camera){
    Vec3s sp18;
    func_8005A8C4(&sp18, camera);
    return sp18.x;
}

s16 func_8005A948(Camera* camera) {
    Vec3s sp18;

    func_8005A8C4(&sp18, camera);
    return sp18.y;
}

Vec3s* func_8005A970(Vec3s* arg0, Camera* arg1) {
    if (gDbgCamEnabled != 0) {
        *arg0 = D_8015BD80.unk_10C6;
        return arg0;
    } else {
        *arg0 = arg1->realDir;
        return arg0;
    }
}

s16 func_8005A9CC(s32 arg0) {
    Vec3s sp18;

    func_8005A970(&sp18, arg0);
    return sp18.x;
}

s16 func_8005A9F4(Camera* camera) {
    Vec3s sp18;

    func_8005A970(&sp18, camera);
    return sp18.y;
}

s32 func_8005AA1C(Camera* camera, s32 arg1, s16 y, s32 countdown) {
    s16 quakeIdx;

    quakeIdx = Quake_Add(camera, 3);
    if (quakeIdx == 0) {
        return 0;
    }
    Quake_SetSpeed(quakeIdx, 0x61A8);
    Quake_SetQuakeValues(quakeIdx, y, 0, 0, 0);
    Quake_SetCountdown(quakeIdx, countdown);
    return 1;
}

#ifdef NON_MATCHING
//Missing extra branch
s32 Camera_SetParam(Camera* camera, s32 param, void* value) {
    Vec3f sp4;

    if (value != NULL) {
        switch (param) {
            case 1:
                camera->paramFlags &= ~(0x10 | 0x8 | 0x1);
                camera->at = *(Vec3f*)value;
                break;
            case 16:
                camera->paramFlags &= ~(0x10 | 0x8 | 0x1);
                camera->targetPosRot.pos = *(Vec3f*)value;
                break;
            case 8:
                if (camera->setting == CAM_SET_DEMOC || camera->setting == CAM_SET_DEMO4) {
                    break;
                }
                camera->target = (Actor*)value;
                camera->paramFlags &= ~(0x10 | 0x8 | 0x1);
                break;
            case 2:
                sp4 = *(Vec3f*)value;
                camera->eyeNext = sp4;
                camera->eye = sp4;
                break;
            case 4:
                camera->unk_68 = *(Vec3f*)value;
                break;
            case 0x40:
                camera->roll = *(f32*)value * (M_PI / 180.0f) + 0.5f;
                break;
            case 32:
                camera->fov = *(f32*)value;
                break;
            default:
                return false;
        }
        camera->paramFlags |= param;
        return true;
    }
    return false;
}
#else
#pragma GLOBAL_ASM("asm/non_matchings/code/z_camera/Camera_SetParam.s")
#endif

s32 Camera_UnsetParam(Camera* camera, s16 param) {
    camera->paramFlags &= ~param;
    return true;
}

s32 func_8005AC48(Camera* camera, s16 arg1) {
    camera->unk_14C = arg1;
    return true;
}

s32 func_8005AC60(Camera* camera) {
    camera->animState = 0;
    return 1;
}

s32 func_8005AC6C(Camera* camera, CutsceneCameraPoint* atPoints, CutsceneCameraPoint* eyePoints, Player* player,
                  s16 relativeToPlayer) {
    PosRot playerPosRot;

    camera->atPoints = atPoints;
    camera->eyePoints = eyePoints;
    camera->relativeToPlayer = relativeToPlayer;

    if (camera->relativeToPlayer != 0) {
        camera->player = player;
        func_8002EF44(&playerPosRot, &player->actor);
        camera->playerPosRot = playerPosRot;

        camera->unk_156 = -1;
        camera->unk_D8 = 0.0f;
        camera->unk_E0 = 0.0f;
    }

    return 1;
}

s16 func_8005ACFC(Camera* camera, s16 arg1) {
    camera->unk_14C |= arg1;
    return camera->unk_14C;
}

s16 func_8005AD1C(Camera* camera, s16 arg1) {
    camera->unk_14C &= ~arg1;
    return camera->unk_14C;
}

s32 func_8005AD40(Camera* camera, Actor* doorActor, s16 camDataIdx, f32 arg3, s16 arg4, s16 arg5, s16 arg6) {
    if ((camera->setting == CAM_SET_DEMO4) || (camera->setting == CAM_SET_DOORC)) {
        return 0;
    }

    camera->params.doorCam.door = doorActor;
    camera->params.doorCam.unk_06 = arg4;
    camera->params.doorCam.unk_08 = arg5;
    camera->params.doorCam.unk_0A = arg6;
    camera->params.doorCam.unk_04 = camDataIdx;

    if (camDataIdx == -99) {
        Camera_CopyModeValuesToPREG(camera, camera->mode);
        return -99;
    }

    if (camDataIdx == -1) {
        Camera_ChangeSettingDefaultFlags(camera, CAM_SET_DOORC);
        osSyncPrintf(".... change default door camera (set %d)\n", CAM_SET_DOORC);
    } else {
        s32 setting = Camera_GetCamDataSetting(camera, camDataIdx);
        camera->unk_14A |= 0x40;

        if (Camera_ChangeSettingDefaultFlags(camera, setting) >= 0) {
            camera->camDataIdx = camDataIdx;
            camera->unk_14A |= 4;
        }

        osSyncPrintf("....change door camera ID %d (set %d)\n", camera->camDataIdx, camera->setting);
    }

    Camera_CopyModeValuesToPREG(camera, camera->mode);
    return -1;
}

s32 Camera_Copy(Camera* dstCamera, Camera* srcCamera) {
    s32 pad;

    dstCamera->posOffset.x = 0.0f;
    dstCamera->posOffset.y = 0.0f;
    dstCamera->posOffset.z = 0.0f;
    dstCamera->atLERPStepScale = 0.1f;
    dstCamera->at = srcCamera->at;

    dstCamera->eye = dstCamera->eyeNext = srcCamera->eye;

    dstCamera->dist = OLib_Vec3fDist(&dstCamera->at, &dstCamera->eye);
    dstCamera->fov = srcCamera->fov;
    dstCamera->roll = srcCamera->roll;
    func_80043B60(dstCamera);

    if (dstCamera->player != NULL) {
        func_8002EF14(&dstCamera->playerPosRot, &dstCamera->player->actor);
        dstCamera->posOffset.x = dstCamera->at.x - dstCamera->playerPosRot.pos.x;
        dstCamera->posOffset.y = dstCamera->at.y - dstCamera->playerPosRot.pos.y;
        dstCamera->posOffset.z = dstCamera->at.z - dstCamera->playerPosRot.pos.z;
        dstCamera->dist = OLib_Vec3fDist(&dstCamera->playerPosRot.pos, &dstCamera->eye);
        dstCamera->xzOffsetUpdateRate = 1.0f;
        dstCamera->yOffsetUpdateRate = 1.0f;
    }
    return true;
}

s32 Camera_GetDbgCamEnabled() {
    return gDbgCamEnabled;
}

Vec3f* Camera_GetSkyboxOffset(Vec3f* dst, Camera* camera) {
    *dst = camera->skyboxOffset;
    return dst;
}

void Camera_SetCameraData(Camera* camera, s16 setDataFlags, CutsceneCameraPoint* atPoints, CutsceneCameraPoint* eyePoints,
                          s16 relativeToPlayer, s16 arg5, UNK_TYPE arg6) {
    if (setDataFlags & 0x1) {
        camera->atPoints = atPoints;
    }

    if (setDataFlags & 0x2) {
        camera->eyePoints = eyePoints;
    }

    if (setDataFlags & 0x4) {
        camera->relativeToPlayer = relativeToPlayer;
    }

    if (setDataFlags & 0x8) {
        camera->unk_12E = arg5;
    }

    if (setDataFlags & 0x10) {
        osSyncPrintf(VT_COL(RED, WHITE) "camera: setCameraData: last argument not alive!\n" VT_RST);
    }
}

s32 Camera_QRegInit() {
    if (!R_RELOAD_CAM_PARAMS) {
        QREG(2) = 1;
        QREG(10) = -1;
        QREG(11) = 100;
        QREG(12) = 80;
        QREG(20) = 90;
        QREG(21) = 10;
        QREG(22) = 10;
        QREG(23) = 50;
        QREG(24) = 6000;
        QREG(25) = 240;
        QREG(26) = 40;
        QREG(27) = 85;
        QREG(28) = 55;
        QREG(29) = 87;
        QREG(30) = 23;
        QREG(31) = 20;
        QREG(32) = 4;
        QREG(33) = 5;
        QREG(50) = 1;
        QREG(51) = 20;
        QREG(52) = 200;
        QREG(53) = 1;
        QREG(54) = 15;
        QREG(55) = 60;
        QREG(56) = 15;
        QREG(57) = 30;
        QREG(58) = 0;
    }

    QREG(65) = 50;
    return true;
}

s32 func_8005B198() {
    return D_8011D3AC;
}

s16 func_8005B1A4(Camera* camera) {
    camera->unk_14C |= 0x8;

    if ((camera->thisIdx == 0) && (camera->globalCtx->activeCamera != 0)) {
        camera->globalCtx->cameraPtrs[camera->globalCtx->activeCamera]->unk_14C |= 0x8;
        return camera->globalCtx->activeCamera;
    }

    return camera->thisIdx;
}
